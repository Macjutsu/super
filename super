#!/bin/bash
#
# S.U.P.E.R.M.A.N.
# Software Update Policy Enforcement (with) Recursive Messaging And Notification
#
# S.U.P.E.R.M.A.N. optimizes the macOS software update experience.
# by Kevin M. White
#
# Version 1.1
# 2022/05/20
# https://github.com/Macjutsu/super
#
######## DEBUGGING STUFF ########
#
# The next line disables specific ShellCheck codes for the entire script. https://github.com/koalaman/shellcheck
# shellcheck disable=SC2001,SC2207
#
# Uncomment the next line for debugging code.
# set -x
#
######## FUNCTIONS - DOCUMENTATION ########

# Show usage documentation. 
showUsage() {
echo "
  S.U.P.E.R.M.A.N.
  Software Update Policy Enforcement (with) Recursive Messaging And Notification

  Version 1.1
  2022/05/20
  https://github.com/Macjutsu/super

  Usage:
  sudo ./super

  Options:
  [--default-defer seconds] [--focus-defer seconds]
  [--menu-defer \"seconds,seconds,etc...\"] [--display-timeout seconds]
  [--display-redraw seconds] [--display-icon \"/local/path or URL\"]
  [--icon-size-ibm pixels ] [--icon-size-jamf pixels ] [--prefer-jamf]
  [--focus-deadline YYYY-MM-DD:hh:mm] [--soft-deadline YYYY-MM-DD:hh:mm]
  [--hard-deadline YYYY-MM-DD:hh:mm] [--count-deadline number] [--clear-count]
  [--local-account \"AccountName\"] [--local-password \"Password\"]
  [--admin-account \"AccountName\"] [--admin-password \"Password\"]
  [--super-account \"AccountName\"] [--super-password \"Password\"]
  [--jamf-account \"AccountName\"] [--jamf-password \"Password\"]
  [--purge-accounts] [--policy-triggers \"PolicyTrigger,PolicyTrigger,etc...\"]
  [--skip-updates] [--no-skip-updates] [--force-restart] [--no-force-restart]
  [--test-mode ] [--no-test-mode ] [--test-mode-timeout seconds] [--reset-super]
  [--verbose-mode] [--no-verbose-mode] [--open-logs] [--usage] [--help]

  * Managed preferences override local options via domain: com.macjutsu.super
  <key>DefaultDefer</key> <string>seconds</string>
  <key>FocusDefer</key> <string>seconds</string>
  <key>MenuDefer</key> <string>seconds,seconds,etc...</string>
  <key>DisplayTimeout</key> <string>seconds</string>
  <key>DisplayRedraw</key> <string>seconds</string>
  <key>DisplayIcon</key> <string>path</string>
  <key>IconSizeIbm</key> <string>number</string>
  <key>IconSizeJamf</key> <string>number</string>
  <key>PreferJamf</key> <true/> | <false/>
  <key>FocusDeadline</key> <string>YYYY-MM-DD:hh:mm</string>
  <key>SoftDeadline</key> <string>YYYY-MM-DD:hh:mm</string>
  <key>HardDeadline</key> <string>YYYY-MM-DD:hh:mm</string>
  <key>CountDeadline</key> <string>number</string>
  <key>PolicyTriggers</key> <string>PolicyTrigger,PolicyTrigger,etc...</string>
  <key>SkipUpdates</key> <true/> | <false/>
  <key>ForceRestart</key> <true/> | <false/>
  <key>TestMode</key> <true/> | <false/>
  <key>TestModeTimeout</key> <string>seconds</string>
  <key>VerboseMode</key> <true/> | <false/>
"
}

# Show help documentation.
showHelp() {
echo "  --default-defer seconds | --default-defer X
  * Managed preference: <key>DefaultDefer</key> <string>seconds</string>
  The number of seconds to defer until the next update attempt if a user choses
  not to update restart. This deferral time is also used in cases when a
  required service is temporarily unavailable (for example, network or Jamf Pro
  connectivity issues). Using this option overrides the default deferral time
  which is set to 3600 seconds (1 hour) via the $defaultDeferSECONDS parameter.
  Times less than 120 seconds or more than 86400 seconds (1 day) are rounded
  accordingly. Also see the --menu option to display a pop-up menu allowing the
  user to select an alternate deferral time. Finally, use a value of X to return
  this option to its default.

  --focus-defer seconds | --focus-defer X
  * Managed preference: <key>FocusDefer</key> <string>seconds</string>
  The number of seconds to defer the update restart dialog automatically if a
  process has prevented display sleep (for example, during an active meeting) or
  the user has Focus or Do Not Disturb enabled. With this option you should also
  consider using --focus-deadline and --soft-deadline to ensure users are
  offered a chance to defer before a required update restart is enforced via
  --hard-deadline. Times less than 120 seconds or more than 86400 seconds
  (1 day) are rounded accordingly. Finally, use a value of X to disable this
  option.

  --menu-defer \"seconds,seconds,etc...\" | --focus-defer X
  * Managed preference: <key>MenuDefer</key>
  <string>seconds,seconds,etc...</string>
  Display a deferral time pop-up menu in the non-deadline update restart dialog
  that allows the user to overide the --default-defer time. The time selections
  are specified with one or more number of seconds that are comma separated with
  no spaces. The first number in the list is the default selection for the menu,
  thus it is automatically selected if you also set --display-timeout. Times
  less than 120 seconds or more than 86400 seconds (1 day) are rounded
  accordingly. Finally, use a value of X to disable this option.

  --display-timeout seconds | --display-timeout X
  * Managed preference: <key>DisplayTimeout</key> <string>seconds</string>
  Sets an automatic timeout for interactive update restart dialogs in seconds.
  The countdown of the timeout is displayed in the update restart dialog. Use
  this option with caution, as once the timeout expires, the restart button is
  automatically selected for any dialogs showing that a deadline has passed.
  Finally, use a value of X to disable this option.

  --display-redraw seconds | --display-redraw X
  * Managed preference: <key>DisplayRedraw</key> <string>seconds</string>
  If a user ignores a notification or dialog (for example, it's moved offscreen)
  this specifies the number of seconds to wait before closing and then reopening
  the notification or dialog, thus redrawing the notification or dialog back in
  it's original open possition. Avoid low numbers as re-centering results in a
  \"flash\" of the notification or dialog. Also note that when --display-redraw
  is used along with --display-timeout, timeout seconds that are too low are
  automatically corrected to equal three times the redraw seconds. This results
  in the notification or dialog redrawing twice before the timeout automatically
  selects the \"Restart\" button. Finally, use a value of X to disable this
  option.

  --display-icon \"/local/path or URL\" | --display-icon X
  * Managed preference: <key>DisplayIcon</key> <string>path</string>
  Local path or http(s) URL to a file that is the picture to display in 
  notifications or dialogs. Both local file paths and http(s) URLs are be copied
  to the path at \$cachedICON. If the path or URL can not be found or this option
  is not set, then the file at the \$defaultICON path is used. Because the path
  is quoted, do not use the escape ( \ ) character. Finally, use a value of X to
  return this option to its default.

  --icon-size-ibm pixels
  * Managed preference: <key>IconSizeIbm</key> <string>number</string>
  Number of pixels for the --display-icon in IBM Notifier dialogs. Using this
  option overrides the default IBM Notifier icon size which is set to 96 pixels
  via the $ibmNotifierIconSIZE parameter. Any size less than 32 pixles or more
  than 150 pixles is rounded accordingly. Finally, use a value of X to return
  this option to its default.
  
  --icon-size-jamf pixels
  * Managed preference: <key>IconSizeJamf</key> <string>number</string>
  Number of pixels for the --display-icon in jamfHelper dialogs and
  notifications. Using this option overrides the default jamfHelper icon size
  which is set to 96 pixels via the $jamfHelperIconSIZE parameter. Any size less
  than 32 pixles or more than 256 pixles is rounded accordingly. Finally, use a
  value of X to return this option to its default.
  
  --prefer-jamf
  * Managed preference: <key>PreferJamf</key> <true/>
  Prefer jamfHelpler over IBM Notifier.app for user interactions.

  --no-prefer-jamf
  * Managed preference: <key>PreferJamf</key> <false/>
  Disable preferring jamfHelpler over IBM Notifier.app for user interactions.

  --focus-deadline YYYY-MM-DD:hh:mm | --focus-deadline X
  * Managed preference: <key>FocusDeadline</key>
  <string>YYYY-MM-DD:hh:mm</string>
  Always used along with --focus-defer. If this date has passed, the update
  restart dialog (with deferral options) always appears even if a process is
  preventing display sleep or the user has Focus or Do Not Disturb enabled.
  When used along with --soft-deadline and/or --hard-deadline, the
  --focus-deadline date should always be the earliest. At a minimum, you must
  always specify year-month-day. Hours are represented by a 24-hour clock, and
  any non-specified hours or minutes are rounded to 00. Also see the
  \$dateFORMAT and \$timeFORMAT parameters for date display options. For testing
  use a date:time in the past to simulate this deadline. Finally, use a value of
  X to disable this option.

  --soft-deadline YYYY-MM-DD:hh:mm | --soft-deadline X
  * Managed preference: <key>SoftDeadline</key>
  <string>YYYY-MM-DD:hh:mm</string>
  If this date has passed, an interactive update restart dialog appears
  indicating that no more user deferrals are allowed. When used along with
  --focus-deadline, the --soft-deadline date should always be later. However,
  if used along with --hard-deadline, the --soft-deadline date should always be
  earlier. At a minimum, you must always specify year-month-day. Hours are
  represented by a 24-hour clock, and any non-specified hours or minutes are
  rounded to 00. Also see the \$dateFORMAT and \$timeFORMAT parameters for date
  display options. For testing use a date:time in the past to simulate this
  deadline. Finally, use a value of X to disable this option.

  --hard-deadline YYYY-MM-DD:hh:mm | --hard-deadline X
  * Managed preference: <key>HardDeadline</key>
  <string>YYYY-MM-DD:hh:mm</string>
  If this date has passed, the computer updates and restarts without asking the
  user for approval. However, the user is notified that a restart is pending.
  When used along with --focus-deadline and/or --soft-deadline, the
  --hard-deadline date should always be last. At a minimum, you must always
  specify year-month-day. Hours are represented by a 24-hour clock, and any
  non-specified hours or minutes are rounded to 00. Also see the \$dateFORMAT
  and \$timeFORMAT parameters for date display options. For testing use a
  date:time in the past to simulate this deadline. Finally, use a value of X to
  disable this option.

  --count-deadline number | --count-deadline X
  * Managed preference: <key>CountDeadline</key> <string>number</string>
  The maximum number of user deferrals allowed before an interactive update
  restart dialog appears indicating that no more user deferrals are allowed.
  This is similar to the --soft-deadline behavior, so you may also want to use
  --hard-deadline to enforce a required update restart. Automatic deferrals
  (like when the user has Focus enabled) do not count against the maximum
  deferral deadline. For testing, use 0 to simulate being past this deadline.
  Finally, use a value of X to disable this option.

  -C | --clear-count
  Reset the current local defer count, thus restarting the deferral counter.

  --local-account \"AccountName\"
  Apple Silicon only. A local (standard or admin) user account name with volume
  ownership privileges. You must also provide the --local-password for this
  account. The account you provide is used to authenticate the Apple
  softwareupdate command.

  --local-password \"Password\"
  Apple Silicon only. The local user password to authenticate the account
  specified by --local-account. Note that these credentials are stored in the
  System keychain and can be viewed by any other admin user.

  --admin-account \"AccountName\"
  Apple Silicon only. A local admin user account name with volume ownership
  privileges. You must also provide the --admin-password for this account. The
  account you provide is used to create a new local super service account that
  authenticatates the Apple softwareupdate command.

  --admin-password \"Password\"
  Apple Silicon only. The local admin user password to authenticate the account
  specified by --admin-account. These credentials are never saved to disk.

  --super-account \"AccountName\"
  Apple Silicon only. Specify a unique account name for the local super service
  account. You must also provide --admin-account credentials for modifying the
  super service account. Using this option overrides the default service account
  name \"super\" and full name \"Super Update Service\".

  --super-password \"Password\"
  Apple Silicon only. Specify a unique password for the local super service
  account. You must also provide --admin-account credentials for modifying the
  super service account. Using this option overrides the default service account
  password which is randomized via the uuidgen command. Note that these
  credentials are stored in the System keychain and can be viewed by any other
  admin user.

  --jamf-account \"AccountName\"
  Apple Silicon only. A Jamf Pro user account that can authorize macOS software
  update MDM commands. You must also provide the --jamf-password for this
  account. The default Jamf Pro privileges required for this account are;
  \"Computers Create\", \" Compuers Read\", and  \"Send Computer Remote Command
  to Download and Install macOS Update\". You can avoid the \" Compuers Read\"
  requirement by providing a Configuratino Profile with the following managed
  preference: <key>JamfProID</key> <string>$JSSID</string>. Note that valid
  local update credentials (local user account or super service account) take
  precedence over the the Jamf Pro API credentials.

  --jamf-password \"Password\"
  Apple Silicon only. The Jamf Pro user account password to authenticate the
  account specified by --jamf-account. Note that these credentials are stored in
  the System keychain and can be viewed by any other local admin user.

  -P | --purge-accounts
  Remove any previously created super serivce account and Jamf Pro API
  account credentials. This behavior is automatic when new accounts are
  provided, however this option is also available to remove all credentials even
  if you're not specifying new ones.

  --policy-triggers \"PolicyTrigger,PolicyTrigger,etc...\" | --policy-triggers X
  * Managed preference: <key>PolicyTriggers</key>
  <string>PolicyTrigger,PolicyTrigger,etc...</string>
  One or more Jamf Pro Policy Triggers that are comma separated with no spaces.
  The super workflow runs this list of Jamf Pro Policy Triggers before any
  restart required system updates are installed. However, even if no software
  updates are available, you can still use this option to take advantage of
  dialogs, notifications, deferrals, and deadline workflows. Additionally, this
  option can be used along with the --skip-updates option to ignore software
  updates and only run the Jamf Pro Policy Triggers. Note that if no software
  updates require a restart or you specify the --skip-updates option, the super
  workflow does not restart the computer unless you also speicfy the
  --force-restart option. This is by design as it allows your Jamf Pro Policy to
  restart the computer instead of the super workflow. Finally, use a value of X
  to disable this option.

  -S | --skip-updates
  * Managed preference: <key>SkipUpdates</key> <true/>
  Skip Apple software updates, even if they are available. This option can also
  be used along with --policy-triggers and/or --force-restart to take advantage
  of dialogs, notifications, deferrals, and deadline workflows. Alternatley, use
  this option along with --reset-super to clear any local super preferences,
  kill any existing super processes, and delete the super LaunchDaemon.

  -s | --no-skip-updates
  * Managed preference: <key>SkipUpdates</key> <false/>
  Resume checking Apple software updates in super workflows.

  -F | --force-restart
  * Managed preference: <key>ForceRestart</key> <true/>
  The super workflow forces a restart even if Apple software updates do not
  require it. Useful when used along with --test-mode or if no restart required
  system updates are available but you still want to force a restart.

  -f | --no-force-restart
  * Managed preference: <key>ForceRestart</key> <false/>
  Disable forced restart in super workflows.

  -T | --test-mode
  * Managed preference: <key>TestMode</key> <true/>
  Mode to validate parameters, credentials, dialogs, notifications, deferrals,
  and deadline workflows. This mode does not attempt any Apple software updates,
  Jamf Polices, or restarts. Thus, allowing for quick iteration testing.

  -t | --no-test-mode
  * Managed preference: <key>TestMode</key> <false/>
  Disable test mode in super workflows.

  --test-mode-timeout seconds | --test-mode-timeout X
  * Managed preference: <key>TestModeTimeout</key> <string>seconds</string>
  The amount of time in seconds to leave test notifications and dialogs open
  before moving on in the workflow. Using this option overrides the default test
  mode timeout which is set to 10 seconds via the \$testModeTIMEOUT default
  parameter. Finally, use a value of X to return this option to its default.

  -R | --reset-super
  Reset the local super prefrences, thus clearing all previous settings. Use
  this option along with --skip-updates to clear any super preferences, kill any
  existing super processes and delete the super LaunchDaemon.

  -V | --verbose-mode
  * Managed preference: <key>VerboseMode</key> <true/>
  Mode to generate additional log output. Note that with this mode passwords
  are visible in Terminal but are not saved to \$superLOG.

  -v | --no-verbose-mode
  * Managed preference: <key>VerboseMode</key> <false/>
  Disable test mode in super workflows.

  -o | -O | --open-logs
  If manually running super from the command line while logged into the GUI,
  this option also opens the \$superLOG, \$updateLOG, and if needed the
  \$mdmLOG in Console.app.

  -u | -U | --usage
  Display basic usage documentation.

  -h | -H | --help
  Display this full help documentation.

  [Unrecognized Options]
  Display usage, display help, and unrecognized options errors.
"
}

######## FUNCTIONS - PARAMETERS ########

# Set default parameters that are used throughout the script.
setDefaults(){
# Installation folder:
superFOLDER="/Library/Management/super"

# Symbolic link in default path for super.
superLINK="/usr/local/bin/super"

# Path to a PID file:
superPIDFILE="/var/run/super.pid"

# Path to a local property list file:
superPLIST="$superFOLDER/com.macjutsu.super" # No trailing ".plist"

# Path to a managed property list file:
superMANAGEDPLIST="/Library/Managed Preferences/com.macjutsu.super" # No trailing ".plist"

# Path to main workflow log file:
superLOG="$superFOLDER/super.log"

# Path to filtered MDM progress log file:
mdmLOG="$superFOLDER/mdm.log"

# Path to filtered software update progress log file:
updateLOG="$superFOLDER/update.log"

# This is the name for the LaunchDaemon.
launchDaemonNAME="com.macjutsu.super" # No trailing ".plist"

# Path to the jamf binary:
jamfBINARY="/usr/local/bin/jamf"

# Cache folder used by the jamf binary when installing scripts via Policy:
jamfCACHE="/Library/Application Support/JAMF/tmp"

# Path to the jamfHELPER binary:
jamfHELPER="/Library/Application Support/JAMF/bin/jamfHelper.app/Contents/MacOS/jamfHelper"

# URL to the IBM Notifier.app download:
ibmNotifierURL="https://github.com/IBM/mac-ibm-notifications/releases/download/v-2.5.0-b-76/IBM.Notifier.zip"

# Target version for IBM Notifier.app:
ibmNotifierVERSION="2.5.0"

# Path to the local IBM Notifier.app:
ibmNotifierAPP="$superFOLDER/IBM Notifier.app"

# Path to the local IBM Notifier.app binary:
ibmNotifierBINARY="$ibmNotifierAPP/Contents/MacOS/IBM Notifier"

# The default number of seconds to defer if a user choses not to restart or a required service is temporarily unavailable.
defaultDeferSECONDS=3600

# Path to for the local cached display icon:
cachedICON="$superFOLDER/icon.png"

# The default icon in the if no $displayIconOPTION is specified or found.
defaultICON="/System/Library/PreferencePanes/SoftwareUpdate.prefPane/Contents/Resources/SoftwareUpdate.icns"

# Default icon size for IBM Notifier.app.
ibmNotifierIconSIZE=96

# Default icon size for jamfHelper.
jamfHelperIconSIZE=96

# Text for the restart button in all dialogs. Note that for deadline dialogs this will be the default button.
restartButtonTEXT="Restart"

# Text for the deferral button in all dialogs. Note that for deadline dialogs this will be the default button.
deferButtonTEXT="Defer"

# Deadline date display format.
dateFORMAT="+%B %d, %Y" # Formatting options can be found in the man page for the date command.

# Deadline time display format.
timeFORMAT="+%l:%M %p" # Formatting options can be found in the man page for the date command.

# The default amount of time in seconds to leave test notifications and dialogs open before moving on in the workflow.
testModeTIMEOUT=10

# These parameters identify the macOS version and architecture.
macosMAJOR=$(sw_vers -productVersion | cut -d'.' -f1) # Expected output: 10, 11, 12
macosMINOR=$(sw_vers -productVersion | cut -d'.' -f2) # Expected output: 14, 15, 06, 01
macosVERSION=${macosMAJOR}$(printf "%02d" "$macosMINOR") # Expected output: 1014, 1015, 1106, 1200
macosARCH=$(arch) # Expected output: i386, arm64
}

# Collect input options and set associated parameters.
getOptions() {
unrecognizedOPTIONS=()
while test $# -gt 0; do
	case "$1" in
		--default-defer )
			defaultDeferOPTION="$2"
			shift 2
		;;
		--focus-defer )
			focusDeferOPTION="$2"
			shift 2
		;;
		--menu-defer )
			menuDeferOPTION="$2"
			shift 2
		;;
		--display-timeout )
			displayTimeoutOPTION="$2"
			shift 2
		;;
		--display-redraw )
			displayRedrawOPTION="$2"
			shift 2
		;;
		--display-icon )
			displayIconOPTION="$2"
			shift 2
		;;
		--icon-size-ibm )
			iconSizeIbmOPTION="$2"
			shift 2
		;;
		--icon-size-jamf )
			iconSizeJamfOPTION="$2"
			shift 2
		;;
		--prefer-jamf )
			preferJamfOPTION="TRUE"
			shift
		;;
		--no-prefer-jamf )
			preferJamfOPTION="FALSE"
			shift
		;;
		--focus-deadline )
			focusDeadlineOPTION="$2"
			shift 2
		;;
		--soft-deadline )
			softDeadlineOPTION="$2"
			shift 2
		;;
		--hard-deadline )
			hardDeadlineOPTION="$2"
			shift 2
		;;
		--count-deadline )
			countDeadlineOPTION="$2"
			shift 2
		;;
		-C|--clear-count )
			clearCOUNT="TRUE"
			shift
		;;
		--local-account )
			localOPTION="$2"
			shift 2
		;;
		--local-password )
			localPASSWORD="$2"
			shift 2
		;;
		--admin-account )
			adminACCOUNT="$2"
			shift 2
		;;
		--admin-password )
			adminPASSWORD="$2"
			shift 2
		;;
		--super-account )
			superOPTION="$2"
			shift 2
		;;
		--super-password )
			superPASSWORD="$2"
			shift 2
		;;
		--jamf-account )
			jamfOPTION="$2"
			shift 2
		;;
		--jamf-password )
			jamfPASSWORD="$2"
			shift 2
		;;
		-P|--purge-accounts )
			purgeACCOUNTS="TRUE"
			shift
		;;
		--policy-triggers )
			policyTriggersOPTION="$2"
			shift 2
		;;
		-S|--skip-updates )
			skipUpdatesOPTION="TRUE"
			shift
		;;
		-s|--no-skip-updates )
			skipUpdatesOPTION="FALSE"
			shift
		;;
		-F|--force-restart )
			forceRestartOPTION="TRUE"
			shift
		;;
		-f|--no-force-restart )
			forceRestartOPTION="FALSE"
			shift
		;;
		-T|--test-mode )
			testModeOPTION="TRUE"
			shift
		;;
		-t|--no-test-mode )
			testModeOPTION="FALSE"
			shift
		;;
		--test-mode-timeout )
			testModeTimeoutOPTION="$2"
			shift 2
		;;
		-R|--reset-super )
			resetLocalPROPERTIES="TRUE"
			shift
		;;
		-V|--verbose-mode )
			verboseModeOPTION="TRUE"
			shift
		;;
		-v|--no-verbose-mode )
			verboseModeOPTION="FALSE"
			shift
		;;
		-o|-O|--open-logs )
			openLOGS="TRUE"
			shift
		;;
		-u|-U|--usage )
			showUsage
			echo -e "  Use --help to view detailed usage information.\n"
			exit 0
			shift
		;;
		-h|-H|--help )
			showUsage
			showHelp
			exit 0
			shift
		;;
		*)
			unrecognizedOPTIONS+=("$1")
			shift
		;;
	esac
done

# Log any unrecognized options.
if [[ -n ${unrecognizedOPTIONS[*]} ]]; then
	showUsage
	showHelp
	sendToLog  "Error: Unrecognzied Options: ${unrecognizedOPTIONS[*]}"; parameterERROR="TRUE"
	echo
fi
}

# Collect any parameters stored in $superMANAGEDPLIST and/or $superPLIST.
getPreferences() {
# If $resetLocalPROPERTIES is specified, then clear all local non-account preferences.
if [[ "$resetLocalPROPERTIES" == "TRUE" ]]; then
	defaults delete "$superPLIST" DefaultDefer 2> /dev/null
	defaults delete "$superPLIST" FocusDefer 2> /dev/null
	defaults delete "$superPLIST" MenuDefer 2> /dev/null
	defaults delete "$superPLIST" DisplayTimeout 2> /dev/null
	defaults delete "$superPLIST" DisplayRedraw 2> /dev/null
	defaults delete "$superPLIST" DisplayIcon 2> /dev/null
	defaults delete "$superPLIST" PreferJamf 2> /dev/null
	defaults delete "$superPLIST" IconSizeIbm 2> /dev/null
	defaults delete "$superPLIST" IconSizeJamf 2> /dev/null
	defaults delete "$superPLIST" FocusDeadline 2> /dev/null
	defaults delete "$superPLIST" SoftDeadline 2> /dev/null
	defaults delete "$superPLIST" HardDeadline 2> /dev/null
	defaults delete "$superPLIST" CountDeadline 2> /dev/null
	defaults delete "$superPLIST" PolicyTriggers 2> /dev/null
	defaults delete "$superPLIST" SkipUpdates 2> /dev/null
	defaults delete "$superPLIST" ForceRestart 2> /dev/null
	defaults delete "$superPLIST" TestMode 2> /dev/null
	defaults delete "$superPLIST" TestModeTimeout 2> /dev/null
	rm -r "$cachedICON" > /dev/null 2>&1
fi

# Collect any managed preferences from $superMANAGEDPLIST.
if [[ -f "$superMANAGEDPLIST.plist" ]]; then
	jamfProIdMANAGED=$(defaults read "$superMANAGEDPLIST" JamfProID 2> /dev/null)
	defaultDeferMANAGED=$(defaults read "$superMANAGEDPLIST" DefaultDefer 2> /dev/null)
	focusDeferMANAGED=$(defaults read "$superMANAGEDPLIST" FocusDefer 2> /dev/null)
	menuDeferMANAGED=$(defaults read "$superMANAGEDPLIST" MenuDefer 2> /dev/null)
	displayTimeoutMANAGED=$(defaults read "$superMANAGEDPLIST" DisplayTimeout 2> /dev/null)
	displayRedrawMANAGED=$(defaults read "$superMANAGEDPLIST" DisplayRedraw 2> /dev/null)
	displayIconMANAGED=$(defaults read "$superMANAGEDPLIST" DisplayIcon 2> /dev/null)
	iconSizeIbmMANAGED=$(defaults read "$superMANAGEDPLIST" IconSizeIbm 2> /dev/null)
	iconSizeJamfMANAGED=$(defaults read "$superMANAGEDPLIST" IconSizeJamf 2> /dev/null)
	preferJamfMANAGED=$(defaults read "$superMANAGEDPLIST" PreferJamf 2> /dev/null)
	focusDeadlineMANAGED=$(defaults read "$superMANAGEDPLIST" FocusDeadline 2> /dev/null)
	softDeadlineMANAGED=$(defaults read "$superMANAGEDPLIST" SoftDeadline 2> /dev/null)
	hardDeadlineMANAGED=$(defaults read "$superMANAGEDPLIST" HardDeadline 2> /dev/null)
	countDeadlineMANAGED=$(defaults read "$superMANAGEDPLIST" CountDeadline 2> /dev/null)
	policyTriggersMANAGED=$(defaults read "$superMANAGEDPLIST" PolicyTriggers 2> /dev/null)
	skipUpdatesMANAGED=$(defaults read "$superMANAGEDPLIST" SkipUpdates 2> /dev/null)
	forceRestartMANAGED=$(defaults read "$superMANAGEDPLIST" ForceRestart 2> /dev/null)
	testModeMANAGED=$(defaults read "$superMANAGEDPLIST" TestMode 2> /dev/null)
	testModeTimeoutMANAGED=$(defaults read "$superMANAGEDPLIST" TestModeTimeout 2> /dev/null)
fi

# Collect any local preferences from $superPLIST.
if [[ -f "$superPLIST.plist" ]]; then
	defaultDeferPROPERTY=$(defaults read "$superPLIST" DefaultDefer 2> /dev/null)
	focusDeferPROPERTY=$(defaults read "$superPLIST" FocusDefer 2> /dev/null)
	menuDeferPROPERTY=$(defaults read "$superPLIST" MenuDefer 2> /dev/null)
	displayTimeoutPROPERTY=$(defaults read "$superPLIST" DisplayTimeout 2> /dev/null)
	displayRedrawPROPERTY=$(defaults read "$superPLIST" DisplayRedraw 2> /dev/null)
	iconSizeIbmPROPERTY=$(defaults read "$superPLIST" IconSizeIbm 2> /dev/null)
	iconSizeJamfPROPERTY=$(defaults read "$superPLIST" IconSizeJamf 2> /dev/null)
	preferJamfPROPERTY=$(defaults read "$superPLIST" PreferJamf 2> /dev/null)
	focusDeadlinePROPERTY=$(defaults read "$superPLIST" FocusDeadline 2> /dev/null)
	softDeadlinePROPERTY=$(defaults read "$superPLIST" SoftDeadline 2> /dev/null)
	hardDeadlinePROPERTY=$(defaults read "$superPLIST" HardDeadline 2> /dev/null)
	countDeadlinePROPERTY=$(defaults read "$superPLIST" CountDeadline 2> /dev/null)
	policyTriggersPROPERTY=$(defaults read "$superPLIST" PolicyTriggers 2> /dev/null)
	skipUpdatesPROPERTY=$(defaults read "$superPLIST" SkipUpdates 2> /dev/null)
	forceRestartPROPERTY=$(defaults read "$superPLIST" ForceRestart 2> /dev/null)
	testModePROPERTY=$(defaults read "$superPLIST" TestMode 2> /dev/null)
	testModeTimeoutPROPERTY=$(defaults read "$superPLIST" TestModeTimeout 2> /dev/null)
fi

# This logic ensures the priority order of managed preference overrides the new input option which overrides the saved local preference.
if [[ -n $defaultDeferMANAGED ]]; then
	defaultDeferOPTION="$defaultDeferMANAGED"
elif [[ -z $defaultDeferOPTION ]] && [[ -n $defaultDeferPROPERTY ]]; then
	defaultDeferOPTION="$defaultDeferPROPERTY"
fi
if [[ -n $focusDeferMANAGED ]]; then
	focusDeferOPTION="$focusDeferMANAGED"
elif [[ -z $focusDeferOPTION ]] && [[ -n $focusDeferPROPERTY ]]; then
	focusDeferOPTION="$focusDeferPROPERTY"
fi
if [[ -n $menuDeferMANAGED ]]; then
	menuDeferOPTION="$menuDeferMANAGED"
elif [[ -z $menuDeferOPTION ]] && [[ -n $menuDeferPROPERTY ]]; then
	menuDeferOPTION="$menuDeferPROPERTY"
fi
if [[ -n $displayTimeoutMANAGED ]]; then
	displayTimeoutOPTION="$displayTimeoutMANAGED"
elif [[ -z $displayTimeoutOPTION ]] && [[ -n $displayTimeoutPROPERTY ]]; then
	displayTimeoutOPTION="$displayTimeoutPROPERTY"
fi
if [[ -n $displayRedrawMANAGED ]]; then
	displayRedrawOPTION="$displayRedrawMANAGED"
elif [[ -z $displayRedrawOPTION ]] && [[ -n $displayRedrawPROPERTY ]]; then
	displayRedrawOPTION="$displayRedrawPROPERTY"
fi
[[ -n $displayIconMANAGED ]] && displayIconOPTION="$displayIconMANAGED"
if [[ -n $iconSizeIbmMANAGED ]]; then
	iconSizeIbmOPTION="$iconSizeIbmMANAGED"
elif [[ -z $iconSizeIbmOPTION ]] && [[ -n $iconSizeIbmPROPERTY ]]; then
	iconSizeIbmOPTION="$iconSizeIbmPROPERTY"
fi
if [[ -n $iconSizeJamfMANAGED ]]; then
	iconSizeJamfOPTION="$iconSizeJamfMANAGED"
elif [[ -z $iconSizeJamfOPTION ]] && [[ -n $iconSizeJamfPROPERTY ]]; then
	iconSizeJamfOPTION="$iconSizeJamfPROPERTY"
fi
if [[ -n $preferJamfMANAGED ]]; then
	preferJamfOPTION="$preferJamfMANAGED"
elif [[ -z $preferJamfOPTION ]] && [[ -n $preferJamfPROPERTY ]]; then
	preferJamfOPTION="$preferJamfPROPERTY"
fi
if [[ -n $focusDeadlineMANAGED ]]; then
	focusDeadlineOPTION="$focusDeadlineMANAGED"
elif [[ -z $focusDeadlineOPTION ]] && [[ -n $focusDeadlinePROPERTY ]]; then
	focusDeadlineOPTION="$focusDeadlinePROPERTY"
fi
if [[ -n $softDeadlineMANAGED ]]; then
	softDeadlineOPTION="$softDeadlineMANAGED"
elif [[ -z $softDeadlineOPTION ]] && [[ -n $softDeadlinePROPERTY ]]; then
	softDeadlineOPTION="$softDeadlinePROPERTY"
fi
if [[ -n $hardDeadlineMANAGED ]]; then
	hardDeadlineOPTION="$hardDeadlineMANAGED"
elif [[ -z $hardDeadlineOPTION ]] && [[ -n $hardDeadlinePROPERTY ]]; then
	hardDeadlineOPTION="$hardDeadlinePROPERTY"
fi
if [[ -n $countDeadlineMANAGED ]]; then
	countDeadlineOPTION="$countDeadlineMANAGED"
elif [[ -z $countDeadlineOPTION ]] && [[ -n $countDeadlinePROPERTY ]]; then
	countDeadlineOPTION="$countDeadlinePROPERTY"
fi
if [[ -n $policyTriggersMANAGED ]]; then
	policyTriggersOPTION="$policyTriggersMANAGED"
elif [[ -z $policyTriggersOPTION ]] && [[ -n $policyTriggersPROPERTY ]]; then
	policyTriggersOPTION="$policyTriggersPROPERTY"
fi
if [[ -n $skipUpdatesMANAGED ]]; then
	skipUpdatesOPTION="$skipUpdatesMANAGED"
elif [[ -z $skipUpdatesOPTION ]] && [[ -n $skipUpdatesPROPERTY ]]; then
	skipUpdatesOPTION="$skipUpdatesPROPERTY"
fi
if [[ -n $forceRestartMANAGED ]]; then
	forceRestartOPTION="$forceRestartMANAGED"
elif [[ -z $forceRestartOPTION ]] && [[ -n $forceRestartPROPERTY ]]; then
	forceRestartOPTION="$forceRestartPROPERTY"
fi
if [[ -n $testModeMANAGED ]]; then
	testModeOPTION="$testModeMANAGED"
elif [[ -z $testModeOPTION ]] && [[ -n $testModePROPERTY ]]; then
	testModeOPTION="$testModePROPERTY"
fi
if [[ -n $testModeTimeoutMANAGED ]]; then
	testModeTimeoutOPTION="$testModeTimeoutMANAGED"
elif [[ -z $testModeTimeoutOPTION ]] && [[ -n $testModeTimeoutPROPERTY ]]; then
	testModeTimeoutOPTION="$testModeTimeoutPROPERTY"
fi
}

# Validate non-credential parameters and manage $superPLIST. Any errors set $parameterERROR.
manageParameters() {
# Validate $jamfBINARY if installed and set $jamfVERSION accordingly.
if [[ -e "$jamfBINARY" ]]; then
	jamfMAJOR=$("$jamfBINARY" -version | cut -c 9- | cut -d'.' -f1) # Expected output: 10
	jamfMINOR=$("$jamfBINARY" -version | cut -c 9- | cut -d'.' -f2) # Expected output: 30, 31, 32, etc.
	jamfVERSION=${jamfMAJOR}$(printf "%02d" "$jamfMINOR") # Expected output: 1030, 1031, 1032, etc.
	jamfAPPLE="1035"
	jamfINTEL="1000"
	if [[ "$macosARCH" == "arm64" ]] && [[ "$jamfVERSION" -lt "$jamfAPPLE" ]]; then
		sendToLog "Exit: Jamf Pro $jamfVERSION not supported for Apple Silicon."; parameterERROR="TRUE"
	elif [[ "$macosARCH" == "i386" ]] && [[ "$jamfVERSION" -lt "$jamfINTEL" ]]; then
		sendToLog "Exit: Jamf Pro $jamfVERSION not supported for Intel."; parameterERROR="TRUE"
	fi
else
	sendToLog "Starter: Unable to locate jamf binary at: $jamfBINARY"
	jamfVERSION="FALSE"
fi

# If there is no IBM Notifier.app, then validate $jamfHelper.
if [[ "$ibmNotifierVALID" == "FALSE" ]]; then
	if [[ ! -e "$jamfHELPER" ]]; then
		sendToLog "Exit: Cannot locate fallback jamfHelper at: $jamfHELPER"; parameterERROR="TRUE"
	fi
fi

# Various regular expressions used for parameter validation.
regexNUMBER="^[0-9]+$"
regexMENU="^[0-9*,]+$"
regexDATE="^[0-9][0-9][0-9][0-9]-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$"
regexTIME="^(2[0-3]|[01][0-9]):[0-5][0-9]$"
regexDEADLINE="^[0-9][0-9][0-9][0-9]-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1]):(2[0-3]|[01][0-9]):[0-5][0-9]$"

# Validate $defaultDeferOPTION input and if valid override default $defaultDeferSECONDS parameter and save to $superPLIST.
if [[ "$defaultDeferOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for default deferral."
	defaults delete "$superPLIST" DefaultDefer 2> /dev/null
elif [[ -n $defaultDeferOPTION ]] && [[ $defaultDeferOPTION =~ $regexNUMBER ]]; then
	if [[ $defaultDeferOPTION -lt 120 ]]; then
		sendToLog "Warning: Specified default deferral time of $defaultDeferOPTION seconds is too low, rounding up to 120 seconds."
		defaultDeferSECONDS="120"
	elif [[ $defaultDeferOPTION -gt 86400 ]]; then
		sendToLog "Warning: Specified default deferral time of $defaultDeferOPTION seconds is too high, rounding down to 86400 seconds (1 day)."
		defaultDeferSECONDS="86400"
	else
		defaultDeferSECONDS="$defaultDeferOPTION"
	fi
	defaults write "$superPLIST" DefaultDefer -string "$defaultDeferSECONDS"
elif [[ -n $defaultDeferOPTION ]] && ! [[ $defaultDeferOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The default deferral time must only be a number."; parameterERROR="TRUE"
fi

# Validate $focusDeferOPTION input and if valid set $focusDeferSECONDS and save to $superPLIST.
if [[ "$focusDeferOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for Focus deferral."
	defaults delete "$superPLIST" FocusDefer 2> /dev/null
elif [[ -n $focusDeferOPTION ]] && [[ $focusDeferOPTION =~ $regexNUMBER ]]; then
	if [[ $focusDeferOPTION -lt 120 ]]; then
		sendToLog "Warning: Specified focus deferral time of $focusDeferOPTION seconds is too low, rounding up to 120 seconds."
		focusDeferSECONDS="120"
	elif [[ $focusDeferOPTION -gt 86400 ]]; then
		sendToLog "Warning: Specified focus deferral time of $focusDeferOPTION seconds is too high, rounding down to 86400 seconds (1 day)."
		focusDeferSECONDS="86400"
	else
		focusDeferSECONDS="$focusDeferOPTION"
	fi
	defaults write "$superPLIST" FocusDefer -string "$focusDeferSECONDS"
elif [[ -n $focusDeferOPTION ]] && ! [[ $focusDeferOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The Focus deferral time must only be a number."; parameterERROR="TRUE"
fi

# Validate $menuDeferOPTION input and if valid set $menuDeferSECONDS and save to $superPLIST.
if [[ "$menuDeferOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for menu deferral."
	defaults delete "$superPLIST" MenuDefer 2> /dev/null
elif [[ -n $menuDeferOPTION ]] && [[ $menuDeferOPTION =~ $regexMENU ]]; then
	oldIFS="$IFS"; IFS=','
	read -r -a menuDeferARRAY <<< "$menuDeferOPTION"
	for i in "${!menuDeferARRAY[@]}"; do
		if [[ ${menuDeferARRAY[i]} -lt 120 ]]; then
			sendToLog "Warning: Specified menu deferral time of ${menuDeferARRAY[i]} seconds is too low, rounding up to 120 seconds."
			menuDeferARRAY[i]="120"
		elif [[ ${menuDeferARRAY[i]} -gt 86400 ]]; then
			sendToLog "Warning: Specified menu deferral time of ${menuDeferARRAY[i]} seconds is too high, rounding down to 86400 seconds (1 day)."
			menuDeferARRAY[i]="86400"
		fi
	done
	menuDeferSECONDS="${menuDeferARRAY[*]}"
	defaults write "$superPLIST" MenuDefer -string "$menuDeferSECONDS"
	IFS="$oldIFS"
elif [[ -n $menuDeferOPTION ]] && ! [[ $menuDeferOPTION =~ $regexMENU ]]; then
	sendToLog "Exit: The defer pop-up menu time(s) must only contain numbers and commas (no spaces)."; parameterERROR="TRUE"
fi

# Validate $displayTimeoutOPTION and $displayRedrawOPTION inputs and if valid set $displayTimeoutSECONDS and $displayRedrawSECONDS and save to $superPLIST.
if [[ "$displayTimeoutOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for display timeout."
	defaults delete "$superPLIST" DisplayTimeout 2> /dev/null
elif [[ -n $displayTimeoutOPTION ]] && [[ $displayTimeoutOPTION =~ $regexNUMBER ]]; then
	displayTimeoutSECONDS="$displayTimeoutOPTION"
	defaults write "$superPLIST" DisplayTimeout -string "$displayTimeoutSECONDS"
elif [[ -n $displayTimeoutOPTION ]] && ! [[ $displayTimeoutOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The display timeout must only be a number."; parameterERROR="TRUE"
fi
if [[ "$displayRedrawOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for display redraw."
	defaults delete "$superPLIST" DisplayRedraw 2> /dev/null
elif [[ -n $displayRedrawOPTION ]] && [[ $displayRedrawOPTION =~ $regexNUMBER ]]; then
	displayRedrawSECONDS="$displayRedrawOPTION"
	defaults write "$superPLIST" DisplayRedraw -string "$displayRedrawSECONDS"
elif [[ -n $displayRedrawOPTION ]] && ! [[ $displayRedrawOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The display redraw time must only be a number."; parameterERROR="TRUE"
fi
if [[ "$parameterERROR" != "TRUE" ]] && [[ -n $displayTimeoutSECONDS ]] && [[ -n $displayRedrawSECONDS ]]; then
	displayMinimumTIMEOUT=$((displayRedrawSECONDS * 3))
	if [[ $displayTimeoutSECONDS -lt $displayMinimumTIMEOUT ]];then
		sendToLog "Warning: Specified display timeout of $displayTimeoutSECONDS seconds is too low given a display redraw of $displayRedrawSECONDS seconds, changing display timeout to $displayMinimumTIMEOUT seconds."
		displayTimeoutSECONDS=$displayMinimumTIMEOUT
		defaults write "$superPLIST" DisplayTimeout -string "$displayTimeoutSECONDS"
	fi
fi

# Verify the $displayIconOPTION to be used for the super service account and in notifications and dialogs, and if valid copy and set $cachedICON and save to $superPLIST.
if [[ "$displayIconOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting cached display icon."
	[[ -f "$cachedICON" ]] && rm -f "$cachedICON"
elif [[ -n "$displayIconOPTION" ]] && [[ "$displayIconOPTION" != "$(defaults read "$superPLIST" DisplayIconCache 2> /dev/null)" ]]; then
	if [[ $(echo "$displayIconOPTION" | grep '^http://\|^https://' -c) -eq 1 ]]; then
		sendToLog "Starter: Attempting to download requested icon from: $displayIconOPTION"
		downloadRESULT=$(curl "$displayIconOPTION" -L -o "/tmp/cachedICON" 2>&1)
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: downloadRESULT: \n$downloadRESULT"
		if [[ -f "/tmp/cachedICON" ]]; then
			sipsRESULT=$(sips -s format png "/tmp/cachedICON" --out "$cachedICON" 2>&1)
			[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: sipsRESULT: \n$sipsRESULT"
			defaults write "$superPLIST" DisplayIconCache -string "$displayIconOPTION"
		else
			sendToLog "Warning: Unable to download specified icon from: $displayIconOPTION"
		fi
	elif [[ -e "$displayIconOPTION" ]]; then
		sendToLog "Starter: Copying requested icon from: $displayIconOPTION"
		sipsRESULT=$(sips -s format png "$displayIconOPTION" --out "$cachedICON" 2>&1)
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: sipsRESULT: \n$sipsRESULT"
		defaults write "$superPLIST" DisplayIconCache -string "$displayIconOPTION"
	else
		sendToLog "Warning: Unable to locate specified icon from: $displayIconOPTION"
	fi
fi
if [[ ! -f "$cachedICON" ]]; then
	sendToLog "Starter: No custom display icon found, copying default icon from: $defaultICON"
	sipsRESULT=$(sips -s format png "$defaultICON" --out "$cachedICON" 2>&1)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: sipsRESULT: \n$sipsRESULT"
	defaults write "$superPLIST" DisplayIconCache -string "$defaultICON"
fi

# Validate $iconSizeIbmOPTION input and if valid override default $ibmNotifierIconSIZE parameter and save to $superPLIST.
if [[ "$iconSizeIbmOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for Ibm Notifier icon size."
	defaults delete "$superPLIST" IconSizeIbm 2> /dev/null
elif [[ -n $iconSizeIbmOPTION ]] && [[ $iconSizeIbmOPTION =~ $regexNUMBER ]]; then
	if [[ $iconSizeIbmOPTION -lt 32 ]]; then
		sendToLog "Warning: Specified Ibm Notifier icon size of $iconSizeIbmOPTION pixels is too low, rounding up to 64 pixels."
		ibmNotifierIconSIZE="32"
	elif [[ $iconSizeIbmOPTION -gt 150 ]]; then
		sendToLog "Warning: Specified Ibm Notifier icon size of $iconSizeIbmOPTION pixels is too high, rounding down to 150 pixels."
		ibmNotifierIconSIZE="150"
	else
		ibmNotifierIconSIZE="$iconSizeIbmOPTION"
	fi
	defaults write "$superPLIST" IconSizeIbm -string "$iconSizeIbmOPTION"
elif [[ -n $iconSizeIbmOPTION ]] && ! [[ $iconSizeIbmOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The Ibm Notifier icon size must only be a number."; parameterERROR="TRUE"
fi

# Validate $iconSizeJamfOPTION input and if valid override default $jamfHelperIconSIZE parameter and save to $superPLIST.
if [[ "$iconSizeJamfOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for Ibm Notifier icon size."
	defaults delete "$superPLIST" IconSizeJamf 2> /dev/null
elif [[ -n $iconSizeJamfOPTION ]] && [[ $iconSizeJamfOPTION =~ $regexNUMBER ]]; then
	if [[ $iconSizeJamfOPTION -lt 32 ]]; then
		sendToLog "Warning: Specified Ibm Notifier icon size of $iconSizeJamfOPTION pixels is too low, rounding up to 64 pixels."
		jamfHelperIconSIZE="32"
	elif [[ $iconSizeJamfOPTION -gt 256 ]]; then
		sendToLog "Warning: Specified Ibm Notifier icon size of $iconSizeJamfOPTION pixels is too high, rounding down to 150 pixels."
		jamfHelperIconSIZE="256"
	else
		jamfHelperIconSIZE="$iconSizeJamfOPTION"
	fi
	defaults write "$superPLIST" IconSizeJamf -string "$iconSizeJamfOPTION"
elif [[ -n $iconSizeJamfOPTION ]] && ! [[ $iconSizeJamfOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The Ibm Notifier icon size must only be a number."; parameterERROR="TRUE"
fi

# Manage $preferJamfOPTION and save to $superPLIST.
if [[ -n $preferJamfOPTION ]]; then
	if [[ $preferJamfOPTION -eq 1 ]] || [[ "$preferJamfOPTION" == "TRUE" ]]; then
		if [[ "$jamfVERSION" != "FALSE" ]]; then
			preferJamfOPTION="TRUE"
		else
			sendToLog "Exit: No local Jamf binary detected, thus can not prefer jamfHelper."; parameterERROR="TRUE"
		fi
	else
		preferJamfOPTION="FALSE"
	fi
	defaults write "$superPLIST" PreferJamf -bool "$preferJamfOPTION"
fi

# Validate $focusDeadlineOPTION, if valid set $focusDEADLINE, $focusEPOCH, $focusDATE, $focusTIME, $focusDEADLINE, and $focusDISPLAY.
if [[ "$focusDeadlineOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for Focus deadline."
	defaults delete "$superPLIST" FocusDeadline 2> /dev/null
elif [[ -n $focusDeadlineOPTION ]]; then
	extractDATE=$(echo "$focusDeadlineOPTION" | cut -c-10 )
	if [[ $extractDATE =~ $regexDATE ]]; then
		extractTIME=$(echo "$focusDeadlineOPTION" | cut -c11- )
		if [[ -n $extractTIME ]]; then
			extractHOURS=$(echo "$extractTIME" | cut -d: -f2)
			[[ -z $extractHOURS ]] && extractHOURS="00"
			extractMINUTES=$(echo "$extractTIME" | cut -d: -f3)
			[[ -z $extractMINUTES ]] && extractMINUTES="00"
			extractTIME="$extractHOURS:$extractMINUTES"
		else
			extractTIME="00:00"
		fi
		if [[ $extractTIME =~ $regexTIME ]]; then
			calculatedDEADLINE="$extractDATE:$extractTIME"
		else
			sendToLog "Exit: The Focus deadline time must be a valid 24-hour time formated as hh:mm."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: The Focus deadline date must be a valid date formated as YYYY-MM-DD."; parameterERROR="TRUE"
	fi
	if [[ $calculatedDEADLINE =~ $regexDEADLINE ]]; then
		focusDEADLINE="$calculatedDEADLINE"
		focusEPOCH=$(date -j -f "%Y-%m-%d:%H:%M" "$calculatedDEADLINE" +"%s")
		focusDATE=$(date -r "$focusEPOCH" "$dateFORMAT")
		if [[ "$extractTIME" == "00:00" ]]; then
			focusDISPLAY="$focusDATE"
		else
			focusTIME=$(date -r "$focusEPOCH" "$timeFORMAT")
			focusDISPLAY="$focusDATE at$focusTIME"
		fi
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: focusEPOCH: $focusEPOCH"
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: focusDISPLAY: $focusDISPLAY"
	else
		sendToLog "Exit: The Focus deadline must be a valid and formated as YYYY-MM-DD:hh:mm."; parameterERROR="TRUE"
	fi
fi

# Validate that $focusDeadlineOPTION also includes a coordinating $focusDeferOPTION.
if [[ -n $focusDeadlineOPTION ]] && [[ -z $focusDeferOPTION ]]; then
	sendToLog "Exit: The Focus deadline date requires that you also set defer Focus seconds."; parameterERROR="TRUE"
fi

# Validate $softDeadlineOPTION, if valid set $softEPOCH, $softDATE, $softTIME, $softDEADLINE, and $softDISPLAY.
if [[ "$softDeadlineOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for soft deadline."
	defaults delete "$superPLIST" SoftDeadline 2> /dev/null
elif [[ -n $softDeadlineOPTION ]]; then
	extractDATE=$(echo "$softDeadlineOPTION" | cut -c-10 )
	if [[ $extractDATE =~ $regexDATE ]]; then
		extractTIME=$(echo "$softDeadlineOPTION" | cut -c11- )
		if [[ -n $extractTIME ]]; then
			extractHOURS=$(echo "$extractTIME" | cut -d: -f2)
			[[ -z $extractHOURS ]] && extractHOURS="00"
			extractMINUTES=$(echo "$extractTIME" | cut -d: -f3)
			[[ -z $extractMINUTES ]] && extractMINUTES="00"
			extractTIME="$extractHOURS:$extractMINUTES"
		else
			extractTIME="00:00"
		fi
		if [[ $extractTIME =~ $regexTIME ]]; then
			calculatedDEADLINE="$extractDATE:$extractTIME"
		else
			sendToLog "Exit: The Soft deadline time must be a valid 24-hour time formated as hh:mm."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: The Soft deadline date must be a valid date formated as YYYY-MM-DD."; parameterERROR="TRUE"
	fi
	if [[ $calculatedDEADLINE =~ $regexDEADLINE ]]; then
		softDEADLINE="$calculatedDEADLINE"
		softEPOCH=$(date -j -f "%Y-%m-%d:%H:%M" "$calculatedDEADLINE" +"%s")
		softDATE=$(date -r "$softEPOCH" "$dateFORMAT")
		if [[ "$extractTIME" == "00:00" ]]; then
			softDISPLAY="$softDATE"
		else
			softTIME=$(date -r "$softEPOCH" "$timeFORMAT")
			softDISPLAY="$softDATE at$softTIME"
		fi
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: softEPOCH: $softEPOCH"
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: softDISPLAY: $softDISPLAY"
	else
		sendToLog "Exit: The Soft deadline must be a valid and formated as YYYY-MM-DD:hh:mm."; parameterERROR="TRUE"
	fi
fi

# Validate $hardDeadlineOPTION, if valid set $hardEPOCH, $hardDATE, $hardTIME, $hardDEADLINE, and $hardDISPLAY.
if [[ "$hardDeadlineOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for hard deadline."
	defaults delete "$superPLIST" HardDeadline 2> /dev/null
elif [[ -n $hardDeadlineOPTION ]]; then
	extractDATE=$(echo "$hardDeadlineOPTION" | cut -c-10 )
	if [[ $extractDATE =~ $regexDATE ]]; then
		extractTIME=$(echo "$hardDeadlineOPTION" | cut -c11- )
		if [[ -n $extractTIME ]]; then
			extractHOURS=$(echo "$extractTIME" | cut -d: -f2)
			[[ -z $extractHOURS ]] && extractHOURS="00"
			extractMINUTES=$(echo "$extractTIME" | cut -d: -f3)
			[[ -z $extractMINUTES ]] && extractMINUTES="00"
			extractTIME="$extractHOURS:$extractMINUTES"
		else
			extractTIME="00:00"
		fi
		if [[ $extractTIME =~ $regexTIME ]]; then
			calculatedDEADLINE="$extractDATE:$extractTIME"
		else
			sendToLog "Exit: The Hard deadline time must be a valid 24-hour time formated as hh:mm."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: The Hard deadline date must be a valid date formated as YYYY-MM-DD."; parameterERROR="TRUE"
	fi
	if [[ $calculatedDEADLINE =~ $regexDEADLINE ]]; then
		hardDEADLINE="$calculatedDEADLINE"
		hardEPOCH=$(date -j -f "%Y-%m-%d:%H:%M" "$calculatedDEADLINE" +"%s")
		hardDATE=$(date -r "$hardEPOCH" "$dateFORMAT")
		if [[ "$extractTIME" == "00:00" ]]; then
			hardDISPLAY="$hardDATE"
		else
			hardTIME=$(date -r "$hardEPOCH" "$timeFORMAT")
			hardDISPLAY="$hardDATE at$hardTIME"
		fi
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: hardEPOCH: $hardEPOCH"
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: hardDISPLAY: $hardDISPLAY"
	else
		sendToLog "Exit: The Hard deadline must be a valid and formated as YYYY-MM-DD:hh:mm."; parameterERROR="TRUE"
	fi
fi

# Validate $focusEPOCH, $softEPOCH, and $hardEPOCH in relation to each other. If valid then save deadlines to $superPLIST.
if [[ -n $hardEPOCH ]] && [[ -n $softEPOCH ]] && [[ $hardEPOCH -le $softEPOCH ]]; then
	sendToLog "Exit: The Hard deadline of $hardDATE at $hardTIME must be later than the Soft deadline of $softDATE at $softTIME."; parameterERROR="TRUE"
fi
if [[ -n $hardEPOCH ]] && [[ -n $focusEPOCH ]] && [[ $hardEPOCH -le $focusEPOCH ]]; then
	sendToLog "Exit: The Hard deadline of $hardDATE at $hardTIME must be later than the Focus deadline of $focusDATE at $focusTIME."; parameterERROR="TRUE"
fi
if [[ -n $softEPOCH ]] && [[ -n $focusEPOCH ]] && [[ $softEPOCH -le $focusEPOCH ]]; then
	sendToLog "Exit: The Soft deadline of $softDATE at $softTIME must be later than the Focus deadline of $focusDATE at $focusTIME."; parameterERROR="TRUE"
fi
if [[ "$parameterERROR" != "TRUE" ]]; then
	[[ -n $focusDEADLINE ]] && defaults write "$superPLIST" FocusDeadline -string "$focusDEADLINE"
	[[ -n $softDEADLINE ]] && defaults write "$superPLIST" SoftDeadline -string "$softDEADLINE"
	[[ -n $hardDEADLINE ]] && defaults write "$superPLIST" HardDeadline -string "$hardDEADLINE"
fi

# Validate $countDeadlineOPTION input and if valid set $countDEADLINE and save to $superPLIST.
if [[ "$countDeadlineOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for count deadline."
	defaults delete "$superPLIST" CountDeadline 2> /dev/null
elif [[ -n $countDeadlineOPTION ]] && [[ $countDeadlineOPTION =~ $regexNUMBER ]]; then
	countDEADLINE="$countDeadlineOPTION"
	defaults write "$superPLIST" CountDeadline -string "$countDEADLINE"
elif [[ -n $countDeadlineOPTION ]] && ! [[ $countDeadlineOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The deferral count deadline must only be a number."; parameterERROR="TRUE"
fi

# Validate $policyTriggersOPTION input and if valid set $policyTRIGGERS and save to $superPLIST.
if [[ "$policyTriggersOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for Jamf Pro Policy triggers."
	defaults delete "$superPLIST" PolicyTriggers 2> /dev/null
elif [[ -n $policyTriggersOPTION ]]; then
	policyTRIGGERS="$policyTriggersOPTION"
	defaults write "$superPLIST" PolicyTriggers -string "$policyTRIGGERS"
fi
if [[ "$jamfVERSION" == "FALSE" ]] && [[ -n $policyTRIGGERS ]]; then
	sendToLog "Exit: Unable to run Jamf Pro Policy Triggers due to missing Jamf binary."; parameterERROR="TRUE"
fi

# Manage $skipUpdatesOPTION and save to $superPLIST.
if [[ $skipUpdatesOPTION -eq 1 ]] || [[ "$skipUpdatesOPTION" == "TRUE" ]]; then
	skipUpdatesOPTION="TRUE"
else
	skipUpdatesOPTION="FALSE"
fi
defaults write "$superPLIST" SkipUpdates -bool "$skipUpdatesOPTION"

# Manage $forceRestartOPTION and save to $superPLIST.
if [[ $forceRestartOPTION -eq 1 ]] || [[ "$forceRestartOPTION" == "TRUE" ]]; then
	forceRestartOPTION="TRUE"
else
	forceRestartOPTION="FALSE"
fi
defaults write "$superPLIST" ForceRestart -bool "$forceRestartOPTION"

# Manage $testModeOPTION and save to $superPLIST.
if [[ $testModeOPTION -eq 1 ]] || [[ "$testModeOPTION" == "TRUE" ]]; then
	testModeOPTION="TRUE"
else
	testModeOPTION="FALSE"
fi
defaults write "$superPLIST" TestMode -bool "$testModeOPTION"
if [[ "$testModeOPTION" == "TRUE" ]] && [[ "$currentUSER" == "FALSE" ]]; then
	sendToLog "Exit: Test mode requires that a valid user is logged in."; parameterERROR="TRUE"
fi

# Validate $testModeTimeoutOPTION input and if valid set $testModeTIMEOUT and save to $superPLIST.
if [[ "$testModeTimeoutOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for test mode timeout."
	defaults delete "$superPLIST" TestModeTimeout 2> /dev/null
elif [[ -n $testModeTimeoutOPTION ]] && [[ $testModeTimeoutOPTION =~ $regexNUMBER ]]; then
	testModeTIMEOUT="$testModeTimeoutOPTION"
	defaults write "$superPLIST" TestModeTimeout -string "$testModeTIMEOUT"
elif [[ -n $testModeTimeoutOPTION ]] && ! [[ $testModeTimeoutOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The test mode timeout must only be a number."; parameterERROR="TRUE"
fi
}

# Manage update credentials given $purgeACCOUNTS, $localACCOUNT, $adminACCOUNT, $superACCOUNT, or $jamfACCOUNT. Any errors set $parameterERROR.
manageUpdateCredentials () {
# Validate that $localOPTION and $localPASSWORD are simultaneously provided.
if [[ -n $localOPTION ]] && [[ -z $localPASSWORD ]]; then
	sendToLog "Exit: A local volume owner account name requires that you also set a local volume owner password."; parameterERROR="TRUE"
fi
if [[ -z $localOPTION ]] && [[ -n $localPASSWORD ]]; then
	sendToLog "Exit: A local volume owner password requires that you also set a local volume owner account name."; parameterERROR="TRUE"
fi

# Validate that $localOPTION exists, is a volume owner, and that $localPASSWORD is correct.
if [[ -n $localOPTION ]] && [[ "$parameterERROR" != "TRUE" ]]; then
	localGUID=$(dscl . read "/Users/$localOPTION" GeneratedUID 2> /dev/null | awk '{print $2;}')
	if [[ -n $localGUID ]]; then
		if ! [[ $(diskutil apfs listcryptousers / | grep -c "$localGUID") -ne 0 ]]; then
			sendToLog "Exit: Provided account \"$localOPTION\" is not a system volume owner."; parameterERROR="TRUE"
		fi
		localVALID=$(dscl /Local/Default -authonly "$localOPTION" "$localPASSWORD" 2>&1)
		if ! [[ "$localVALID" == "" ]];then
			sendToLog "Exit: The provided password for account \"$localOPTION\" is not valid."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: Could not retrieve GUID for account \"$localOPTION\". Verify that account exists locally."; parameterERROR="TRUE"
	fi
fi

# Validate that $adminACCOUNT and $adminPASSWORD are simultaneously provided.
if [[ -n $adminACCOUNT ]] && [[ -z $adminPASSWORD ]]; then
	sendToLog "Exit: A local admin account name requires that you also set a local admin password."; parameterERROR="TRUE"
fi
if [[ -z $adminACCOUNT ]] && [[ -n $adminPASSWORD ]]; then
	sendToLog "Exit: A local admin password requires that you also set a local admin account name."; parameterERROR="TRUE"
fi

# Validate that $adminACCOUNT is also specified with $superOPTION.
if [[ -n $superOPTION ]] && [[ -z $adminACCOUNT ]]; then
	sendToLog "Exit: Local admin credentials are required to set a custom super service account name."; parameterERROR="TRUE"
fi

# Validate that $adminACCOUNT exists, is a volume owner, a local admin, and that $adminPASSWORD is correct.
if [[ -n $adminACCOUNT ]] && [[ "$parameterERROR" != "TRUE" ]]; then
	adminGUID=$(dscl . read "/Users/$adminACCOUNT" GeneratedUID 2> /dev/null | awk '{print $2;}')
	if [[ -n $adminGUID ]]; then
		if [[ $(groups "$adminACCOUNT" | grep "admin" -c) -eq 0 ]]; then
			sendToLog "Exit: Provided account \"$adminACCOUNT\" is not a local administrator."; parameterERROR="TRUE"
		fi
		if ! [[ $(diskutil apfs listcryptousers / | grep -c "$adminGUID") -ne 0 ]]; then
			sendToLog "Exit: Provided account \"$adminACCOUNT\" is not a system volume owner."; parameterERROR="TRUE"
		fi
		adminVALID=$(dscl /Local/Default -authonly "$adminACCOUNT" "$adminPASSWORD" 2>&1)
		if ! [[ "$adminVALID" == "" ]];then
			sendToLog "Exit: The provided password for account \"$adminACCOUNT\" is not valid."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: Could not retrieve GUID for account \"$adminACCOUNT\". Verify that account exists locally."; parameterERROR="TRUE"
	fi
fi

# Validate that $jamfOPTION 
if [[ -n $jamfOPTION ]] && [[ "$jamfVERSION" == "FALSE" ]]; then
	sendToLog "Exit: A Jamf Pro API account name requires that this computer is enrolled in Jamf Pro."; parameterERROR="TRUE"
fi

# Validate that $jamfOPTION and $jamfPASSWORD are simultaneously provided.
if [[ -n $jamfOPTION ]] && [[ -z $jamfPASSWORD ]]; then
	sendToLog "Exit: A Jamf Pro API account name requires that you also set a Jamf Pro API password."; parameterERROR="TRUE"
fi
if [[ -z $jamfOPTION ]] && [[ -n $jamfPASSWORD ]]; then
	sendToLog "Exit: A Jamf Pro API password requires that you also set a Jamf Pro API account name."; parameterERROR="TRUE"
fi

# Validate that the account $jamfOPTION and $jamfPASSWORD are valid.
if [[ -n $jamfOPTION ]] && [[ "$parameterERROR" != "TRUE" ]]; then
	jamfACCOUNT="$jamfOPTION"
	jamfKEYCHAIN="$jamfPASSWORD"
	getJamfProServer
	if [[ "$jamfSERVER" != "FALSE" ]]; then
		getJamfProAccount
		[[ "$jamfERROR" == "TRUE" ]] && parameterERROR="TRUE"
	else
		sendToLog "Exit: Unable to connect to Jamf Pro to validate user account."; parameterERROR="TRUE"
	fi
	unset jamfACCOUNT
	unset jamfKEYCHAIN
fi

# Collect any previously saved account names from $superPLIST.
localPROPERTY=$(defaults read "$superPLIST" LocalAccount 2> /dev/null)
superPROPERTY=$(defaults read "$superPLIST" SuperAccount 2> /dev/null)
jamfPROPERTY=$(defaults read "$superPLIST" JamfAccount 2> /dev/null)

# Some messaging to indicate if there are no saved accounts.
{ [[ -z $localPROPERTY ]] && [[ -z $superPROPERTY ]] && [[ -z $jamfPROPERTY ]] && [[ -n $purgeACCOUNTS ]]; } && sendToLog "Starter: No saved accounts to remove."

# If there was a previous $localPROPERTY account and the user specified $localOPTION or $purgeACCOUNTS then delete any previously saved local account credentials.
if [[ -n $localPROPERTY ]] && { [[ -n $localOPTION ]] || [[ "$purgeACCOUNTS" == "TRUE" ]]; }; then
	sendToLog "Starter: Purging saved credentials for local account \"$localPROPERTY\"."
	defaults delete "$superPLIST" LocalAccount > /dev/null 2>&1
	security delete-generic-password -a "$localPROPERTY" -s "Super Local Account" /Library/Keychains/System.keychain > /dev/null 2>&1
	unset localPROPERTY
fi

# If there was a previous $superPROPERTY account and the user specified $adminACCOUNT or $purgeACCOUNTS then delete any previously saved super service account and credentials.
if [[ -n $superPROPERTY ]] && { [[ -n $adminACCOUNT ]] || [[ "$purgeACCOUNTS" == "TRUE" ]]; } then
	sendToLog "Starter: Purging local account and saved cedentials for super service account \"$superPROPERTY\"."
	sysadminctl -deleteUser "$superPROPERTY" > /dev/null 2>&1
	defaults delete "$superPLIST" SuperAccount > /dev/null 2>&1
	security delete-generic-password -a "$superPROPERTY" -s "Super Service Account" /Library/Keychains/System.keychain > /dev/null 2>&1
	unset superPROPERTY
fi

# If there was a previous $jamfPROPERTY account and the user specified $jamfOPTION or $purgeACCOUNTS then delete any previously saved Jamf Pro API credentials.
if [[ -n $jamfPROPERTY ]] && { [[ -n $jamfOPTION ]] || [[ "$purgeACCOUNTS" == "TRUE" ]]; } then
	sendToLog "Starter: Purging saved credentials for Jamf Pro API account \"$jamfPROPERTY\"."
	defaults delete "$superPLIST" JamfAccount > /dev/null 2>&1
	security delete-generic-password -a "$jamfPROPERTY" -s "Super MDM Account" /Library/Keychains/System.keychain > /dev/null 2>&1
	unset jamfPROPERTY
fi

# If any previous validation generated a $parameterERROR then it's not necessary to continue this function.
[[ $parameterERROR == "TRUE" ]] && return 0

# If a new local account was specified, save $localOPTION and $localPASSWORD credentials and then validate retrieval.
if [[ -n $localOPTION ]]; then
	sendToLog "Starter: Saving new credentials for local account \"$localOPTION\"..."
	defaults write "$superPLIST" LocalAccount -string "$localOPTION"
	localACCOUNT=$(defaults read "$superPLIST" LocalAccount 2> /dev/null)
	if [[ "$localOPTION" == "$localACCOUNT" ]]; then
		security add-generic-password -a "$localACCOUNT" -s "Super Local Account" -w "$localPASSWORD" -T /usr/bin/security /Library/Keychains/System.keychain
		localKEYCHAIN=$(security find-generic-password -w -a "$localACCOUNT" -s "Super Local Account" /Library/Keychains/System.keychain 2> /dev/null)
		if [[ "$localPASSWORD" == "$localKEYCHAIN" ]]; then
			sendToLog "Starter: Validated saved credentials for local account \"$localACCOUNT\"."
			localCREDENTIAL="TRUE"
		else
			sendToLog "Exit: Unable to validate saved password for local account \"$localACCOUNT\", deleting saved password."; parameterERROR="TRUE"
			security delete-generic-password -a "$localACCOUNT" -s "Super Local Account" /Library/Keychains/System.keychain > /dev/null 2>&1
		fi
	else
		sendToLog "Exit: Unable to validate saved name for local account \"$localOPTION\", deleting saved name."; parameterERROR="TRUE"
		defaults delete "$superPLIST" LocalAccount > /dev/null 2>&1
	fi
fi

# If an $adminACCOUNT was specified then a new super service account needs to be created and its credentials saved.
if [[ -n $adminACCOUNT ]]; then
	# If the a custom super service account name is requested via $superOPTION.
	if [[ -n $superOPTION ]]; then
		superNEWACCT="$superOPTION"
		superNEWFULL="$superOPTION"
	else # Use the default names for the super service account.
		superNEWACCT="super"
		superNEWFULL="Super Update Service"
	fi
	
	# If a custom super service account password is requested via $superPASSWORD.
	if [[ -n $superPASSWORD ]]; then
		superNEWPASS="$superPASSWORD"
	else # Use the default random password for the super service account.
		superNEWPASS=$(uuidgen)
	fi
	
	# Save and validate new super service account credentials, and validate retrieval.
	sendToLog "Starter: Saving new credentials for super service account \"$superNEWACCT\"..."
	defaults write "$superPLIST" SuperAccount -string "$superNEWACCT"
	superACCOUNT=$(defaults read "$superPLIST" SuperAccount 2> /dev/null)
	if [[ "$superNEWACCT" == "$superACCOUNT" ]]; then
		security add-generic-password -a "$superACCOUNT" -s "Super Service Account" -w "$superNEWPASS" -T /usr/bin/security /Library/Keychains/System.keychain
		superKEYCHAIN=$(security find-generic-password -w -a "$superACCOUNT" -s "Super Service Account" /Library/Keychains/System.keychain 2> /dev/null)
		if [[ "$superNEWPASS" == "$superKEYCHAIN" ]]; then # Only if saved credentials are valid do we create the new super service account.
			sendToLog "Starter: Validated saved credentials for new super service account \"$superACCOUNT\"."
			if [[ $(id "$superACCOUNT" 2>&1 | grep "no such user" -c) -eq 1 ]]; then
				sendToLog "Starter: Deleting existing super service account \"$superACCOUNT\" in preparation for new account."
				sysadminctl -deleteUser "$superACCOUNT" > /dev/null 2>&1
			fi
			# Loop through local IDs to find the first vacant id after 500.
			newUID=501
			while [[ $(id $newUID 2>&1 | grep "no such user" -c) -ne 1 ]]; do
				newUID=$((newUID + 1))
			done
			sendToLog "Starter: Creating new super service account \"$superNEWACCT\" with full name \"$superNEWFULL\" and UID $newUID..."
			addRESULT=$(sysadminctl -addUser "$superNEWACCT" -fullName "$superNEWFULL" -password "$superNEWPASS" -UID $newUID -GID 20 -shell /dev/null -home /dev/null -picture "$cachedICON" -adminUser "$adminACCOUNT" -adminPassword "$adminPASSWORD" 2>&1)
			[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: addRESULT: \n$addRESULT"
			dscl . create /Users/"$superNEWACCT" IsHidden 1
			updateACCOUNT="$superACCOUNT"
			updateKEYCHAIN="$superKEYCHAIN"
			checkLocalUpdateAccount
			if [[ "$accountERROR" != "TRUE" ]]; then
				sendToLog "Starter: Validated the creation of new super service account \"$superACCOUNT\"."
				superCREDENTIAL="TRUE"
			else
				sendToLog "Exit: Unable to validate newly created super service account \"$superACCOUNT\", deleting account"; parameterERROR="TRUE"
				sysadminctl -deleteUser "$superACCOUNT" > /dev/null 2>&1
				defaults delete "$superPLIST" SuperAccount > /dev/null 2>&1
				security delete-generic-password -a "$superACCOUNT" -s "Super Service Account" /Library/Keychains/System.keychain > /dev/null 2>&1
				unset superPROPERTY
			fi
		else
			sendToLog "Exit: Unable to validate saved password for new super service account \"$superNEWACCT\", deleting saved password."; parameterERROR="TRUE"
			security delete-generic-password -a "$superACCOUNT" -s "Super Service Account" /Library/Keychains/System.keychain > /dev/null 2>&1
		fi
	else
		sendToLog "Exit: Unable to validate saved name for new super service account \"$superNEWACCT\",deleting saved name."; parameterERROR="TRUE"
		defaults delete "$superPLIST" SuperAccount > /dev/null 2>&1
	fi
fi

# If a new Jamf Pro API account was specified, save $jamfOPTION and $jamfPASSWORD credentials and then validate retrieval.
if [[ -n $jamfOPTION ]]; then
	sendToLog "Starter: Saving new credentials for Jamf Pro API account \"$jamfOPTION\"..."
	defaults write "$superPLIST" JamfAccount -string "$jamfOPTION"
	jamfACCOUNT=$(defaults read "$superPLIST" JamfAccount 2> /dev/null)
	if [[ "$jamfOPTION" == "$jamfACCOUNT" ]]; then
		security add-generic-password -a "$jamfACCOUNT" -s "Super MDM Account" -w "$jamfPASSWORD" -T /usr/bin/security /Library/Keychains/System.keychain
		jamfKEYCHAIN=$(security find-generic-password -w -a "$jamfACCOUNT" -s "Super MDM Account" /Library/Keychains/System.keychain 2> /dev/null)
		if [[ "$jamfPASSWORD" == "$jamfKEYCHAIN" ]]; then
			sendToLog "Starter: Validated saved credentials for Jamf Pro API account \"$jamfACCOUNT\"."
			jamfCREDENTIAL="TRUE"
		else
			sendToLog "Exit: Unable to validate saved password for Jamf Pro API account \"$jamfACCOUNT\", deleting saved password."; parameterERROR="TRUE"
			security delete-generic-password -a "$jamfACCOUNT" -s "Super MDM Account" /Library/Keychains/System.keychain > /dev/null 2>&1
		fi
	else
		sendToLog "Exit: Unable to validate saved name for Jamf Pro API account \"$jamfOPTION\", deleting saved name."; parameterERROR="TRUE"
		defaults delete "$superPLIST" JamfAccount > /dev/null 2>&1
	fi
fi

# If there is a previously saved local account (that wasn't just purged), validate the account and set $localACCOUNT and $localPASSWORD.
if [[ -n $localPROPERTY ]]; then
	localACCOUNT="$localPROPERTY"
	localKEYCHAIN=$(security find-generic-password -w -a "$localACCOUNT" -s "Super Local Account" /Library/Keychains/System.keychain 2> /dev/null)
	if [[ -n $localKEYCHAIN ]]; then
		sendToLog "Starter: Found saved credentials for local account \"$localACCOUNT\"."
		updateACCOUNT="$localACCOUNT"
		updateKEYCHAIN="$localKEYCHAIN"
		checkLocalUpdateAccount
		if [[ "$accountERROR" != "TRUE" ]]; then
			sendToLog "Starter: Validated saved credentials for local account \"$localACCOUNT\"."
			localCREDENTIAL="TRUE"
		else
			sendToLog "Exit: Unable to validate saved credentials for local account \"$localACCOUNT\"."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: Unable to retrieve password for saved local account \"$localACCOUNT\"."; parameterERROR="TRUE"
	fi
fi

# If there is a previously saved super service account (that wasn't just purged), validate the account and set $superACCOUNT and $superPASSWORD.
if [[ -n $superPROPERTY ]]; then
	superACCOUNT="$superPROPERTY"
	superKEYCHAIN=$(security find-generic-password -w -a "$superACCOUNT" -s "Super Service Account" /Library/Keychains/System.keychain 2> /dev/null)
	if [[ -n $superKEYCHAIN ]]; then
		sendToLog "Starter: Found saved credentials for super service account \"$superACCOUNT\"."
		updateACCOUNT="$superACCOUNT"
		updateKEYCHAIN="$superKEYCHAIN"
		checkLocalUpdateAccount
		if [[ "$accountERROR" != "TRUE" ]]; then
			sendToLog "Starter: Validated saved credentials for super service account \"$superACCOUNT\"."
			superCREDENTIAL="TRUE"
		else
			sendToLog "Exit: Unable to validate saved credentials for super service account \"$superACCOUNT\"."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: Unable to retrieve password for saved super service account \"$superACCOUNT\"."; parameterERROR="TRUE"
	fi
fi

# If there is a previously saved Jamf PRO API account (that wasn't just purged), validate the account and set $jamfACCOUNT and $jamfPASSWORD.
if [[ -n $jamfPROPERTY ]]; then
	jamfACCOUNT="$jamfPROPERTY"
	jamfKEYCHAIN=$(security find-generic-password -w -a "$jamfACCOUNT" -s "Super MDM Account" /Library/Keychains/System.keychain 2> /dev/null)
	if [[ -n $jamfKEYCHAIN ]]; then
		sendToLog "Starter: Found saved credentials for Jamf Pro API account \"$jamfACCOUNT\"."
		getJamfProServer
		if [[ "$jamfSERVER" != "FALSE" ]]; then
			getJamfProAccount
			if [[ "$jamfERROR" != "TRUE" ]]; then
				sendToLog "Starter: Validated saved credentials for Jamf Pro API account \"$jamfACCOUNT\"."
				if [[ $(profiles status -type bootstraptoken 2> /dev/null | grep "YES" -c) -eq 2 ]]; then
					jamfCREDENTIAL="TRUE"
				else
					sendToLog "Exit: Can not use MDM update workflow because this computer's Bootstrap token is not escrowed."; parameterERROR="TRUE"
				fi
			else
				parameterERROR="TRUE"
			fi
		else
			sendToLog "Exit: Unable to connect to Jamf Pro to validate user account."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: Unable to retrieve password for saved Jamf Pro API account \"$jamfACCOUNT\"."; parameterERROR="TRUE"
	fi
fi
}

######## FUNCTIONS - STARTUP ########

# Install items required by super.
superInstaller() {
# Figure out where super is running from and start Installer log if anything needs to be installed.
superPATH="$(dirname "$0")"
{ [[ ! -d "$superFOLDER" ]] || [[ ! -d "$ibmNotifierAPP" ]] || ! { [[ "$superPATH" == "$superFOLDER" ]] || [[ "$superPATH" == "$(dirname "$superLINK")" ]]; } } && sendToLog "**** S.U.P.E.R.M.A.N. INSTALLER ****"

# Make sure the $superFOLDER exists.
if [[ ! -d "$superFOLDER" ]]; then
	mkdir -p "$superFOLDER"
	sendToLog "Installer: Made working folder: $superFOLDER"
fi

# Validate the IBM Notifier.app, if missing or invalid then install and check again.
if [[ "$macosMAJOR" != "10" ]] || { [[ "$macosMAJOR" == "10" ]] && [[ "$macosMINOR" -ge 15 ]]; }; then
	if [[ ! -d "$ibmNotifierAPP" ]]; then
		getIbmNotifier
		[[ -d "$ibmNotifierAPP" ]] && checkIbmNotifier
		[[ "$ibmNotifierVALID" == "FALSE" ]] && sendToLog "Warning: Unable to validate IBM Notifier.app after installation, will attempt fallback to jamfHelper."
	else
		checkIbmNotifier
		if [[ "$ibmNotifierVALID" == "FALSE" ]]; then
			sendToLog "Installer: Removing existing IBM Notifier.app."
			rm -Rf "$ibmNotifierAPP" > /dev/null 2>&1
			[[ -d "$superFOLDER/__MACOSX" ]] && rm -Rf "$superFOLDER/__MACOSX" > /dev/null 2>&1
			getIbmNotifier
			[[ -d "$ibmNotifierAPP" ]] && checkIbmNotifier
		fi
		[[ "$ibmNotifierVALID" == "FALSE" ]] && sendToLog "Warning: Unable to validate IBM Notifier.app after re-installation, will attempt fallback to jamfHelper."
	fi
else
	sendToLog "Warning: IBM Notifier.app is not compatible with this version of macOS, will attempt fallback to jamfHelper."
	ibmNotifierVALID="FALSE"
fi

# Install super if it's running from any location that is not in the $superFOLDER or from the $superLINK.
if ! { [[ "$superPATH" == "$superFOLDER" ]] || [[ "$superPATH" == "$(dirname "$superLINK")" ]]; }; then
	sendToLog "Installer: Copying file: $superFOLDER/super"
	cp "$0" "$superFOLDER/super" > /dev/null 2>&1
	sendToLog "Installer: Creating default path link: $superLINK"
	ln -s "$superFOLDER/super" "$superLINK" > /dev/null 2>&1
	sendToLog "Installer: Creating file: $superFOLDER/super-starter"
/bin/cat <<EOSS > "$superFOLDER/super-starter"
#!/bin/sh
echo "\$(date +"%a %b %d %T") \$(hostname -s) \$(basename "\$0")[\$\$]: **** S.U.P.E.R.M.A.N. LAUNCHDAEMON ****" | tee -a "$superLOG"
"$superFOLDER/super" "\$@" &
disown
exit 0
EOSS
	[[ "$macosARCH" == "arm64" ]] && touch "$mdmLOG"
	[[ "$macosMAJOR" != "10" ]] && touch "$updateLOG"
	sendToLog "Installer: Setting permissions in: $superFOLDER"
	chown -R root:wheel "$superFOLDER"
	chown root:wheel "$superLINK"
	chmod -R a+r "$superFOLDER"
	chmod a+r "$superLINK"
	chmod a+x "$superFOLDER/super"
	chmod a+x "$superFOLDER/super-starter"
	chmod a+x "$superLINK"
	
	# Detect if super was installed via Jamf.
	if [[ "$superPATH" == "$jamfCACHE" ]]; then # Installed via Jamf, so exit this run with the assumption that Jamf is going to restart via "Execute Command" options in Policy.
		sendToLog "Exit: Running from $superPATH, exiting for Jamf Policy restart."
	else # Installed via other location, so restart using super script in $superFOLDER.
		sendToLog "Exit: Running from $superPATH, restarting with parameters: $*"
		bash "$superFOLDER/super" "$@" &
		disown
	fi
	sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
	exit 0
fi
}

# Download and install the IBM Notifier.app.
getIbmNotifier() {
ibmNotifierVALID="FALSE"
sendToLog "Installer: Attempting to download and install IBM Notifier.app..."
downloadRESULT=$(curl "$ibmNotifierURL" -L -o "/tmp/IBM.Notifier.zip" 2>&1)
if [[ -f "/tmp/IBM.Notifier.zip" ]]; then
	unzipRESULT=$(unzip "/tmp/IBM.Notifier.zip" -d "$superFOLDER/" 2>&1)
	if [[ -d "$ibmNotifierAPP" ]]; then
		[[ -d "$superFOLDER/__MACOSX" ]] && rm -Rf "$superFOLDER/__MACOSX" > /dev/null 2>&1
		chmod -R a+rx "$ibmNotifierAPP"
		ibmNotifierVALID="TRUE"
	else
		sendToLog "Warning: Unable to install IBM Notifier.app."
		sendToLog "Verbose Mode: unzipRESULT: \n$unzipRESULT"
	fi
else
	sendToLog "Warning: Unable to download IBM Notifier.app from: $ibmNotifierURL"
	sendToLog "Verbose Mode: downloadRESULT: \n$downloadRESULT"
fi
}


# Check the IBM Notifier.app for validity.
checkIbmNotifier() {
ibmNotifierVALID="FALSE"
ibmNotifierCODESIGN=$(codesign --verify --verbose "$ibmNotifierAPP" 2>&1)
if [[ $(echo "$ibmNotifierCODESIGN" | grep -c "valid on disk") -eq 1 ]]; then
	ibmNotifierRESULT=$(defaults read "$ibmNotifierAPP/Contents/Info.plist" CFBundleShortVersionString)
	if [[ "$ibmNotifierVERSION" == "$ibmNotifierRESULT" ]]; then
		ibmNotifierVALID="TRUE"
	else
		sendToLog "Warning: IBM Notifier at path: $ibmNotifierAPP is version $ibmNotifierRESULT, this does not match target version $ibmNotifierVERSION"
	fi
else
	sendToLog "Warning: unable validate signature for IBM Notifier at path: $ibmNotifierAPP."
	sendToLog "Verbose Mode: ibmNotifierCODESIGN: \n$ibmNotifierCODESIGN"
fi
}

# Prepare super by cleaning after previous super runs, record various maintenance modes, validate parameters, and liberate super from Jamf Policy runs.
superStarter() {
# Record startup of super in $superLOG.
sendToLog "**** S.U.P.E.R.M.A.N. STARTER ****"

# Check for any previous super process still running, if so kill it.
if [[ -f "$superPIDFILE" ]]; then
	previousPID=$(cat "$superPIDFILE")
	sendToLog "Starter: Found previous super instance running with PID $previousPID, killing..."
	kill -9 "$previousPID" > /dev/null 2>&1
fi

# Kill any already running helper processes.
killall -9 "softwareupdate" > /dev/null 2>&1
killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
killall -9 "jamfHelper" > /dev/null 2>&1

# Create $superPIDFILE for this instance of super.
echo $$ > "$superPIDFILE"

# This unloads and removes any previous LaunchDaemons.
if [[ -f "/Library/LaunchDaemons/$launchDaemonNAME.plist" ]]; then
	sendToLog "Starter: Cleaning up previous LaunchDaemon $launchDaemonNAME.plist."
	launchctl bootout system "/Library/LaunchDaemons/$launchDaemonNAME.plist" 2> /dev/null
	rm -f "/Library/LaunchDaemons/$launchDaemonNAME.plist"
fi

# Manage the $verboseModeOPTION and if enabled start additional logging.
if [[ "$resetLocalPROPERTIES" == "TRUE" ]]; then
	sendToLog "Starter: Clearing local super preferences."
	defaults delete "$superPLIST" VerboseMode 2> /dev/null
fi
if [[ -f "$superMANAGEDPLIST.plist" ]]; then
	verboseModeMANAGED=$(defaults read "$superMANAGEDPLIST" VerboseMode 2> /dev/null)
fi
if [[ -f "$superPLIST.plist" ]]; then
	verboseModePROPERTY=$(defaults read "$superPLIST" VerboseMode 2> /dev/null)
fi
if [[ -n $verboseModeMANAGED ]]; then
	verboseModeOPTION="$verboseModeMANAGED"
elif [[ -z $verboseModeOPTION ]] && [[ -n $verboseModePROPERTY ]]; then
	verboseModeOPTION="$verboseModePROPERTY"
fi
if [[ $verboseModeOPTION -eq 1 ]] || [[ "$verboseModeOPTION" == "TRUE" ]]; then
	verboseModeOPTION="TRUE"
else
	verboseModeOPTION="FALSE"
fi
defaults write "$superPLIST" VerboseMode -bool "$verboseModeOPTION"
if [[ "$verboseModeOPTION" == "TRUE" ]]; then
	sendToLog "Starter: Verbose mode enabled."
	sendToLog "Starter: Uptime: $(uptime)"
	sendToLog "Starter: Managed preference file $superMANAGEDPLIST:\n$(defaults read "$superMANAGEDPLIST" 2> /dev/null)"
	sendToLog "Starter: Local preference file before validation $superPLIST:\n$(defaults read "$superPLIST" 2> /dev/null)"
fi

# Parameter and saved credential validation and management.
checkCurrentUser
manageParameters
[[ "$macosARCH" == "arm64" ]] && manageUpdateCredentials
if [[ "$parameterERROR" == "TRUE" ]]; then
	rm -f "$superPIDFILE"
	sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
	exit 1
fi

# Detect if super is running via Jamf and if so restsart via LaunchDaemon to release the jamf process.
# This is late in the starter workflow so as to only create a valid LaunchDaemon after parameter validation and housekeeping.
if [[ $(ps -p "$PPID" | awk '{print $4;}' | grep -c "jamf") -gt 0 ]]; then
	sendToLog "Starter: Detected Jamf as parent, restarting with new LaunchDaemon..."
	makeLaunchDaemonRestartNow
fi

# Workflow for for $openLOGS.
if [[ "$openLOGS" == "TRUE" ]]; then
	if [[ "$currentUSER" != "FALSE" ]]; then
		sendToLog "Starter: Opening logs for user $currentUSER..."
		sudo -u "$currentUSER" open "$superLOG"
		if [[ "$macosMAJOR" != "10" ]]; then
			{ [[ "$jamfCREDENTIAL" == "TRUE" ]] && { [[ "$localCREDENTIAL" != "TRUE" ]] || [[ "$superCREDENTIAL" != "TRUE" ]]; } } && sudo -u "$currentUSER" open "$mdmLOG"
			sudo -u "$currentUSER" open "$updateLOG"
		fi
	else
		sendToLog "Starter: Open logs request denied because there is currently no local user logged into the GUI."
	fi
fi

# Feedback for various alternate workflow modes.
[[ "$preferJamfOPTION" == "TRUE" ]] && sendToLog "Starter: Prefer jamfHelper mode enabled."
[[ "$skipUpdatesOPTION" == "TRUE" ]] && sendToLog "Starter: Skip Apple software udates mode enabled."
[[ "$forceRestartOPTION" == "TRUE" ]] && sendToLog "Starter: Forced restart mode enabled."
[[ "$testModeOPTION" == "TRUE" ]] && sendToLog "Starter: Test mode enabled with $testModeTIMEOUT second timeout."
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Starter: Local preference file after validation $superPLIST:\n$(defaults read "$superPLIST" 2> /dev/null)"
[[ "$verboseModeOPTION" == "TRUE" ]] && logParameters

# Make sure we have a network connection before moving on.
# If there is still no network after two minutes, an automatic deferral is started.
networkTIMEOUT=0
while [[ $(ifconfig -a inet 2>/dev/null | sed -n -e '/127.0.0.1/d' -e '/0.0.0.0/d' -e '/inet/p' | wc -l) -le 0 ]] && [[ $networkTIMEOUT -lt 120 ]]; do
	sendToLog "Starter: Waiting for network..."
	sleep 5
	networkTIMEOUT=$((networkTIMEOUT + 5))
done
if [[ $(ifconfig -a inet 2>/dev/null | sed -n -e '/127.0.0.1/d' -e '/0.0.0.0/d' -e '/inet/p' | wc -l) -le 0 ]]; then
	sendToLog "Starter: Network unavailalbe, trying again in $defaultDeferSECONDS seconds."
	makeLaunchDaemonCalendar
fi

# Detect if super is running after an update restart and set $updateVALIDATE appropriately.
[[ $(defaults read "$superPLIST" UpdateValidate 2> /dev/null) ]] && updateVALIDATE="TRUE"
}

######## FUNCTIONS - LOGGING ########

# Append input to a log located at $superLOG.
sendToLog() {
echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: $*" | tee -a "$superLOG"
}

# Append input to the command line only, so as not to save secrets to the $superLOG.
sendToEcho() {
echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: Not Logged: $*"
}

# Log any parameters that have values.
logParameters() {
sendToLog "Verbose Mode: macosVERSION: $macosVERSION"
sendToLog "Verbose Mode: macosARCH: $macosARCH"
sendToLog "Verbose Mode: jamfVERSION: $jamfVERSION"
[[ -n $jamfSERVER ]] && sendToLog "Verbose Mode: jamfSERVER: $jamfSERVER"
[[ -n $ibmNotifierVALID ]] && sendToLog "Verbose Mode: ibmNotifierVALID: $ibmNotifierVALID"
[[ -n $defaultDeferSECONDS ]] && sendToLog "Verbose Mode: defaultDeferSECONDS: $defaultDeferSECONDS"
[[ -n $focusDeferSECONDS ]] && sendToLog "Verbose Mode: focusDeferSECONDS: $focusDeferSECONDS"
[[ -n $menuDeferSECONDS ]] && sendToLog "Verbose Mode: menuDeferSECONDS: $menuDeferSECONDS"
[[ -n $displayTimeoutSECONDS ]] && sendToLog "Verbose Mode: displayTimeoutSECONDS: $displayTimeoutSECONDS"
[[ -n $displayRedrawSECONDS ]] && sendToLog "Verbose Mode: displayRedrawSECONDS: $displayRedrawSECONDS"
[[ -n $ibmNotifierIconSIZE ]] && sendToLog "Verbose Mode: ibmNotifierIconSIZE: $ibmNotifierIconSIZE"
[[ -n $jamfHelperIconSIZE ]] && sendToLog "Verbose Mode: jamfHelperIconSIZE: $jamfHelperIconSIZE"
[[ -n $preferJamfOPTION ]] && sendToLog "Verbose Mode: preferJamfOPTION: $preferJamfOPTION"
[[ -n $focusDEADLINE ]] && sendToLog "Verbose Mode: focusDEADLINE: $focusDEADLINE"
[[ -n $softDEADLINE ]] && sendToLog "Verbose Mode: softDEADLINE: $softDEADLINE"
[[ -n $hardDEADLINE ]] && sendToLog "Verbose Mode: hardDEADLINE: $hardDEADLINE"
[[ -n $countDEADLINE ]] && sendToLog "Verbose Mode: countDEADLINE: $countDEADLINE"
[[ -n $clearCOUNT ]] && sendToLog "Verbose Mode: clearCOUNT: $clearCOUNT"
[[ -n $localOPTION ]] && sendToLog "Verbose Mode: localOPTION: $localOPTION"
[[ -n $localPASSWORD ]] && sendToEcho "Verbose Mode: localPASSWORD: $localPASSWORD"
[[ -n $localACCOUNT ]] && sendToLog "Verbose Mode: localACCOUNT: $localACCOUNT"
[[ -n $localKEYCHAIN ]] && sendToEcho "Verbose Mode: localKEYCHAIN: $localKEYCHAIN"
[[ -n $localCREDENTIAL ]] && sendToLog "Verbose Mode: localCREDENTIAL: $localCREDENTIAL"
[[ -n $adminACCOUNT ]] && sendToLog "Verbose Mode: adminACCOUNT: $adminACCOUNT"
[[ -n $adminPASSWORD ]] && sendToEcho "Verbose Mode: adminPASSWORD: $adminPASSWORD"
[[ -n $superOPTION ]] && sendToLog "Verbose Mode: superOPTION: $superOPTION"
[[ -n $superPASSWORD ]] && sendToEcho "Verbose Mode: superPASSWORD: $superPASSWORD"
[[ -n $superACCOUNT ]] && sendToLog "Verbose Mode: superACCOUNT: $superACCOUNT"
[[ -n $superKEYCHAIN ]] && sendToEcho "Verbose Mode: superKEYCHAIN: $superKEYCHAIN"
[[ -n $superCREDENTIAL ]] && sendToLog "Verbose Mode: superCREDENTIAL: $superCREDENTIAL"
[[ -n $JamfProID ]] && sendToLog "Verbose Mode: JamfProID: $JamfProID"
[[ -n $jamfOPTION ]] && sendToLog "Verbose Mode: jamfOPTION: $jamfOPTION"
[[ -n $jamfPASSWORD ]] && sendToEcho "Verbose Mode: jamfPASSWORD: $jamfPASSWORD"
[[ -n $jamfACCOUNT ]] && sendToLog "Verbose Mode: jamfACCOUNT: $jamfACCOUNT"
[[ -n $jamfKEYCHAIN ]] && sendToEcho "Verbose Mode: jamfKEYCHAIN: $jamfKEYCHAIN"
[[ -n $jamfCREDENTIAL ]] && sendToLog "Verbose Mode: jamfCREDENTIAL: $jamfCREDENTIAL"
[[ -n $purgeACCOUNTS ]] && sendToLog "Verbose Mode: purgeACCOUNTS: $purgeACCOUNTS"
[[ -n $policyTRIGGERS ]] && sendToLog "Verbose Mode: policyTRIGGERS: $policyTRIGGERS"
}

######## FUNCTIONS - JAMF PRO API ########

# Validate the connection to a managed computer's Jamf Pro service and set $jamfSERVER accordingly.
getJamfProServer() {
jamfSTATUS=$("$jamfBINARY" checkJSSConnection -retry 1)
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: jamfSTATUS is: $jamfSTATUS"
if [[ $(echo "$jamfSTATUS" | grep -c "available") -ne 0 ]]; then
	jamfSERVER=$(defaults read /Library/Preferences/com.jamfsoftware.jamf.plist jss_url)
else
	jamfSERVER="FALSE"
	sendToLog "Status: Jamf Pro service unavaiable."
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: jamfSERVER is: $jamfSERVER"
}

# Attempt to acquire a Jamf Pro $jamfProTOKEN via $jamfACCOUNT and $jamfKEYCHAIN credentials.
getJamfProToken() {
if [[ "$macosMAJOR" -eq 10 ]] || [[ "$macosMAJOR" -eq 11 ]]; then
	jamfProTOKEN=$(curl -X POST -u "$jamfACCOUNT:$jamfKEYCHAIN" -s "${jamfSERVER}api/v1/auth/token" | python -c 'import sys, json; print json.load(sys.stdin)["token"]')
else
	jamfProTOKEN=$(curl -X POST -u "$jamfACCOUNT:$jamfKEYCHAIN" -s "${jamfSERVER}api/v1/auth/token" | plutil -extract token raw -)
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: jamfProTOKEN is: \n$jamfProTOKEN"
}

# Validate that the account $jamfACCOUNT and $jamfKEYCHAIN are valid credentials and has appropriate permissions to send MDM commands. If not set $jamfERROR.
getJamfProAccount() {
getJamfProToken
if [[ -n $jamfProTOKEN ]]; then
	getJamfProComputerID
	if [[ -n $jamfProID ]]; then
		sendBlankPush
			if [[ $commandRESULT != 201 ]]; then
				sendToLog "Exit: Unable to request Blank Push via Jamf Pro API user account \"$jamfACCOUNT\". Verify this account has has the privileges \"Jamf Pro Server Objects > Computers > Create & Read\"."; jamfERROR="TRUE"
			fi
	else
		sendToLog "Exit: Unable to acquire Jamf Pro ID for computer with UDID \"$computerUDID\". Verify that this computer is enrolled in Jamf Pro."
		sendToLog "Exit: Also verify that the Jamf Pro API account \"$jamfACCOUNT\" has the privileges \"Jamf Pro Server Objects > Computers > Create & Read\"."; jamfERROR="TRUE"
	fi
else
	sendToLog "Exit: Unable to acquire authentication token via Jamf Pro API user account \"$jamfACCOUNT\". Verify account name and password."; jamfERROR="TRUE"
fi
}

# Use $jamfProIdMANAGED or $jamfProTOKEN to find the computer's Jamf Pro ID and set $jamfProID.
getJamfProComputerID() {
computerUDID=$(system_profiler SPHardwareDataType | awk '/UUID/ { print $3; }')
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: computerUDID is: $computerUDID"
if [[ -n $jamfProIdMANAGED ]]; then
	jamfProID="$jamfProIdMANAGED"
else
	sendToLog "Warning: Using a Jamf Pro API account with \"Computers > Read\" privileges to collect the computer ID is a security risk. Instead use a custom Configuration Profile with the following; Preference Domain \"com.macjutsu.super\", Key \"JamfProID\", String \"\$JSSID\"."
	jamfProID=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --header "Accept: application/xml" --request GET --url "${jamfSERVER}JSSResource/computers/udid/${computerUDID}/subset/General" 2> /dev/null | xpath -e /computer/general/id 2>&1 | awk -F'<id>|</id>' '{print $2}' | xargs)
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: jamfProID is: $jamfProID"
}

# Attempt to send a Blank Push to Jamf Pro.
sendBlankPush() {
commandRESULT=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --write-out "%{http_code}" --silent --output /dev/null --request POST --url "${jamfSERVER}JSSResource/computercommands/command/BlankPush/id/${jamfProID}")
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: commandRESULT is: \n$commandRESULT"
}

# Validate $jamfProTOKEN and if found invalid, a new token is requested and again validated.
checkJamfProServerToken() {
tokenCHECK=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --write-out "%{http_code}" --silent --output /dev/null --request GET --url "${jamfSERVER}api/v1/auth")
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: tokenCHECK is: $tokenCHECK"
if [[ $tokenCHECK -ne 200 ]]; then
	getJamfProToken
	tokenCHECK=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --write-out "%{http_code}" --silent --output /dev/null --request GET --url "${jamfSERVER}api/v1/auth")
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: tokenCHECK is: $tokenCHECK"
	if [[ $tokenCHECK -ne 200 ]]; then
		sendToLog "Exit: Could not retrieve Jamf Pro API token for account \"$jamfACCOUNT\", verify account credentials." 
		rm -f "$superPIDFILE"
		sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
		exit 1
	fi
fi
}

######## FUNCTIONS - EVALUATE CONDITIONS ########

# Verify that super is running with root privileges.
checkRoot() {
if [[ "$(id -u)" -ne 0 ]]; then
	sendToEcho "Exit: $(basename "$0") must run with root privleges."
	exit 1
fi
}

# Set $currentUSER to the value of the currently logged in GUI user or "FALSE" if there is none or a system account.
checkCurrentUser() {
currentUSER=$(echo "show State:/Users/ConsoleUser" | scutil | awk '/Name :/ && ! /loginwindow/ { print $3 }')
if [[ -z $currentUSER ]]; then
	sendToLog "Starter: No GUI user currently logged in."
	currentUSER="FALSE"
elif [[ "$currentUSER" = "root" ]] || [[ "$currentUSER" = "_mbsetupuser" ]] || [[ "$currentUSER" = "loginwindow" ]]; then
	sendToLog "Starter: Current GUI user is system account $currentUSER."
	currentUSER="FALSE"
else
	sendToLog "Starter: Current GUI user is $currentUSER."
fi
}

# Validate that the account $updateACCOUNT and $updateKEYCHAIN are valid credentials is a volume owner. If not set $accountERROR.
checkLocalUpdateAccount() {
accountGUID=$(dscl . read "/Users/$updateACCOUNT" GeneratedUID 2> /dev/null | awk '{print $2;}')
if [[ -n $accountGUID ]]; then
	if ! [[ $(diskutil apfs listcryptousers / | grep -c "$accountGUID") -ne 0 ]]; then
		sendToLog "Exit: Provided account \"$updateACCOUNT\" is not a system volume owner."; accountERROR="TRUE"
	fi
	accountVALID=$(dscl /Local/Default -authonly "$updateACCOUNT" "$updateKEYCHAIN" 2>&1)
	if ! [[ "$accountVALID" == "" ]];then
		sendToLog "Exit: The provided password for account \"$updateACCOUNT\" is not valid."; accountERROR="TRUE"
	fi
else
	sendToLog "Exit: Could not retrieve GUID for account \"$updateACCOUNT\". Verify that account exists locally."; accountERROR="TRUE"
fi
}

# Evaluate the $focusDEADLINE, $softDEADLINE, and $hardDEADLINE options and set $deadlineSTATUS accordingly.
checkDateDeadlines() {
deadlineSTATUS="FALSE"
if [[ -n $focusDEADLINE ]] && [[ $focusEPOCH -lt $(date +%s) ]]; then
		sendToLog "Status: Focus deadline of $focusDISPLAY has passed."
		deadlineSTATUS="FOCUS"
fi
if [[ -n $softEPOCH ]] && [[ $softEPOCH -lt $(date +%s) ]]; then
		sendToLog "Status: Soft deadline of $softDISPLAY has passed."
		deadlineSTATUS="SOFT"
fi
if [[ -n $hardEPOCH ]] && [[ $hardEPOCH -lt $(date +%s) ]]; then
		sendToLog "Status: Hard deadline of $hardDISPLAY has passed."
		deadlineSTATUS="HARD"
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineSTATUS is: $deadlineSTATUS"
}

# Clear the DeferCount in $superPLIST to disable/reset the maximum deferral counter.
clearMaxDeferralCounter() {
sendToLog "Status: Clearing deferral deadline count."
defaults delete "$superPLIST" DeferCount 2> /dev/null
}

# Evaluate the $countDEADLINE option and set $deadlineSTATUS accordingly.
checkDeferCountDeadline() {
[[ "$clearCOUNT" == "TRUE" ]] && clearMaxDeferralCounter
if [[ -n $countDEADLINE ]]; then
	if [[ "$focusDEFER" == "TRUE" ]]; then
		sendToLog "Status: Focus or Do Not Disturb active, not incrementing defer counter."
	else
		previousCOUNT=$(defaults read "$superPLIST" DeferCount 2> /dev/null)
		if [[ -z $previousCOUNT ]]; then
			sendToLog "Status: Creating new defer counter in $superPLIST."
			currentCOUNT=0
			defaults write "$superPLIST" DeferCount -int $currentCOUNT
		else
			currentCOUNT=$((previousCOUNT + 1))
			defaults write "$superPLIST" DeferCount -int $currentCOUNT
		fi
		if [[ $currentCOUNT -ge $countDEADLINE ]]; then
			sendToLog "Status: Defer count deadline of $countDEADLINE exceeded."
			deadlineSTATUS="COUNT"
		else
			countDISPLAY=$((countDEADLINE - currentCOUNT))
			sendToLog "Status: Defer count deadline of $countDEADLINE not exceeded with $countDISPLAY remaining."
		fi
	fi
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineSTATUS is: $deadlineSTATUS"
}

# Evaluate if a process has told the display to not sleep or the user has enabled Focus or Do Not Disturb, and set $focusDEFER accordingly.
checkUserFocus() {
focusDEFER="FALSE"
if [[ -n $focusDeferSECONDS ]]; then
	if [[ $macosMAJOR -eq 10 ]]; then
		focusSTATUS=$(sudo -u "$currentUSER" defaults -currentHost read "/Users/$currentUSER/Library/Preferences/ByHost/com.apple.notificationcenterui" doNotDisturb 2>/dev/null)
	elif [[ $macosMAJOR -eq 11 ]]; then
		focusSTATUS=$(plutil -extract dnd_prefs xml1 -o - "/Users/$currentUSER/Library/Preferences/com.apple.ncprefs.plist" | xmllint --xpath "string(//data)" - | base64 --decode | plutil -convert xml1 - -o - | grep -ic userPref)
	else
		focusSTATUS=$(plutil -extract data.0.storeAssertionRecords.0.assertionDetails.assertionDetailsModeIdentifier raw -o - "/Users/$currentUSER/Library/DoNotDisturb/DB/Assertions.json" | grep -ic com.apple.)
	fi
	if [[ $focusSTATUS -gt 0 ]]; then
		sendToLog "Status: Focus or Do Not Disturb enabled for user $currentUSER."
		focusDEFER="TRUE"
	fi
	oldIFS="$IFS"; IFS=$'\n'
	displayASSERTIONS=($(pmset -g assertions | awk '/NoDisplaySleepAssertion | PreventUserIdleDisplaySleep/ && match($0,/\(.+\)/) && ! /coreaudiod/ {gsub(/^\ +/,"",$0); print};'))
	if [[ -n ${displayASSERTIONS[*]} ]]; then
		for assertionITEM in "${displayASSERTIONS[@]}"; do
			sendToLog "Status: The following Display Sleep Assertions detected: $(echo "${assertionITEM}" | awk -F: '{print $1}')"
		done
		focusDEFER="TRUE"
	fi
	IFS="$oldIFS"
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: focusDEFER is: $focusDEFER"
}

######## FUNCTIONS - UPDATES ########

# Collect available Apple software updates and set $updateRESULT, $recommendedLABLES[], $updatesRECOMMENDED, $updatesRESTART, and $downloadREQUIRED accordingly.
checkAppleUpdates() {
# Collect Apple software updates list.
sendToLog "Status: Checking available Apple software updates..."
availableOSUPDATES=$(/usr/libexec/mdmclient AvailableOSUpdates 2>&1)
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: availableOSUPDATES is: \n$availableOSUPDATES"
updateRESULT=$(softwareupdate --list 2>&1)
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: updateRESULT is: $updateRESULT"

# Double-checking for false positives on macOS 11 or later.
if [[ "$macosMAJOR" != "10" ]] && [[ $(echo "$updateRESULT" | grep "No new software available." -c) -eq 1 ]]; then
	sendToLog "Status: Double-checking available Apple software updates..."
	launchctl kickstart -k system/com.apple.softwareupdated
	sleep 5
	availableOSUPDATES=$(/usr/libexec/mdmclient AvailableOSUpdates 2>&1)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: availableOSUPDATES is: \n$availableOSUPDATES"
	updateRESULT=$(softwareupdate --list 2>&1)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: updateRESULT is: $updateRESULT"
fi

# After checking updates parse the $updateRESULT and set $updatesRECOMMENDED, $updatesRESTART, and $downloadREQUIRED accordingly.
updatesRECOMMENDED="FALSE"
updatesRESTART="FALSE"
downloadREQUIRED="FALSE"
if [[ $(echo "$updateRESULT" | grep "No new software available." -c) -eq 1 ]]; then
	sendToLog "Status: No Apple software updates available. Some may be deferred via MDM."
else
	oldIFS="$IFS"; IFS=$'\n'
	allLABLES=()
	allTITLES=()
	restartLABLES=()
	recommendedLABLES=()
	# Parse $updateRESULT for individual update labels and save to $allLABLES[], $restartLABLES[], and $recommendedLABLES[].
	if [[ $macosMAJOR -gt 10 ]] || [[ $macosVERSION -eq 1015 ]]; then
		allLABLES=($(echo "$updateRESULT" | awk -F': ' '/Label:/{print $2}'))
		allTITLES=($(echo "$updateRESULT" | awk -F',' '/Title:/ {print $1}' | cut -d ' ' -f 2-))
		restartLABLES=($(echo "$updateRESULT" | grep -B 1 "restart" | awk -F': ' '/Label:/{print $2}'))
	else
		allLABLES=($(echo "$updateRESULT" | awk -F'*' '/\*/{print $2}' | sed 's/^ //'))
		allTITLES=($(echo "$updateRESULT" | awk -F'(' '/\t/ {print $1}' | cut -d $'\t' -f 2 | sed 's/.$//'))
		restartLABLES=($(echo "$updateRESULT" | grep -B 1 "restart" | awk -F'*' '/\*/{print $2}' | sed 's/^ //'))
	fi
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: allLABLES[] is: \n${allLABLES[*]}"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: allTITLES[] is: \n${allTITLES[*]}"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: restartLABLES[] is: \n${restartLABLES[*]}"
	[[ "${allLABLES[*]}" != "${restartLABLES[*]}" ]] && recommendedLABLES=($(echo -e "${allLABLES[*]}\n${restartLABLES[*]}" | sort | uniq -u))
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: recommendedLABLES[] is: \n${recommendedLABLES[*]}"

	# If any updates are available, send to log and evaluate download status.
	if [[ -n ${allLABLES[*]} ]]; then
		if [[ -n ${recommendedLABLES[*]} ]]; then
			sendToLog "Status: ${#recommendedLABLES[@]} available non-restart \"recommended\" software udpate(s)."
			for i in "${!recommendedLABLES[@]}"; do
				sendToLog "Status: Recommended Software Update $((i + 1)): ${recommendedLABLES[i]}"
			done
			updatesRECOMMENDED="TRUE"
		else
			sendToLog "Status: No available non-restart \"recommended\" software udpate(s). Some may be deferred via MDM."
		fi
		if [[ -n ${restartLABLES[*]} ]]; then
			sendToLog "Status: ${#restartLABLES[@]} available restart required system udpate(s)."
			for i in "${!restartLABLES[@]}"; do
				sendToLog "Status: Restart Required System Update $((i + 1)): ${restartLABLES[i]}"
			done
			updatesRESTART="TRUE"
		else
			sendToLog "Status: No available restart required system udpate(s). Some may be deferred via MDM."
		fi
		# Evaluate previously downloaded updates and compare them to currently available updates, setting $downloadREQUIRED accordingly.
		previousDOWNLOADS=$(defaults read "$superPLIST" UpdateDownloads 2> /dev/null)
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: previousDOWNLOADS is: \n$previousDOWNLOADS"
		if [[ -n $previousDOWNLOADS ]]; then
			downloadedTITLES=($(echo "$previousDOWNLOADS" | grep -wv -e '(' -e ')' | sed -e 's/    //g' -e 's/"//g' -e 's/,//g'))
			[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: downloadedTITLES is: \n${downloadedTITLES[*]}"
			if [[ ! $(echo -e "${downloadedTITLES[*]}\n${allTITLES[*]}" | sort | uniq -u) ]]; then
				sendToLog "Status: Previously downloaded update title(s) match currently available updates."
			else
				sendToLog "Status: Previously downloaded update title(s) do not match currently available updates."
				downloadREQUIRED="TRUE"
			fi
		else
			downloadREQUIRED="TRUE"
		fi
	else
		IFS="$oldIFS"
		sendToLog "Exit: Unable to parse Apple softwareupdate results."
		rm -f "$superPIDFILE"
		sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
		exit 1
	fi
	IFS="$oldIFS"
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: updatesRECOMMENDED is: $updatesRECOMMENDED"
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: updatesRESTART is: $updatesRESTART"
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: downloadREQUIRED is: $downloadREQUIRED"
}

# This function checks the update status after recommended software updates are installed.
checkAfterRecommendedUpdates() {
checkAppleUpdates
if [[ "$updatesRECOMMENDED" == "TRUE" ]]; then
	# Double-checking for false positives after recommended software updates
	sendToLog "Status: Double-checking available Apple software updates..."
	launchctl kickstart -k system/com.apple.softwareupdated
	sleep 5
	availableOSUPDATES=$(/usr/libexec/mdmclient AvailableOSUpdates 2>&1)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: availableOSUPDATES is: \n$availableOSUPDATES"
	checkAppleUpdates
fi
if [[ "$updatesRECOMMENDED" == "FALSE" ]]; then
	if [[ "$jamfVERSION" != "FALSE" ]]; then
		getJamfProServer
		if [[ "$jamfSERVER" != "FALSE" ]]; then
			sendToLog "Status: Submiting updated inventory to Jamf Pro. Use \"--verbose-mode\" or check /var/log/jamf.log for more detail..."
			if [[ "$verboseModeOPTION" == "TRUE" ]]; then
				jamfRESULT=$("$jamfBINARY" recon -verbose 2>&1)
				sendToLog "Verbose Mode: jamfRESULT is: \n$jamfRESULT"
			else
				"$jamfBINARY" recon > /dev/null 2>&1
			fi
		else
			sendToLog "Status: Unable to submit inventory to Jamf Pro, continuing update workflow."
		fi
	else
		sendToLog "Status: All recommended software updates complete, but Jamf binary not present, continuing update workflow."
	fi
else
	sendToLog "Exit: All recommended software updates did not complete after attempted installation, trying again in $defaultDeferSECONDS seconds."
	makeLaunchDaemonCalendar
fi
}

# This function checks the update status after a previous super system update.
checkAfterRestartUpdates() {
checkAppleUpdates
if [[ "$updatesRECOMMENDED" == "FALSE" ]] && [[ "$updatesRESTART" == "FALSE" ]]; then
	if [[ "$jamfVERSION" != "FALSE" ]]; then
		getJamfProServer
		if [[ "$jamfSERVER" != "FALSE" ]]; then
			defaults delete "$superPLIST" UpdateValidate 2> /dev/null
			sendToLog "Status: Submiting updated inventory to Jamf Pro. Use \"--verbose-mode\" or check /var/log/jamf.log for more detail..."
			if [[ "$verboseModeOPTION" == "TRUE" ]]; then
				jamfRESULT=$("$jamfBINARY" recon -verbose 2>&1)
				sendToLog "Verbose Mode: jamfRESULT is: \n$jamfRESULT"
			else
				"$jamfBINARY" recon > /dev/null 2>&1
			fi
			sleep 5
			sendToLog "Status: Running Jamf Pro check-in policies. Use \"--verbose-mode\" or check /var/log/jamf.log for more detail..."
			if [[ "$verboseModeOPTION" == "TRUE" ]]; then
				jamfRESULT=$("$jamfBINARY" policy -verbose 2>&1)
				sendToLog "Verbose Mode: jamfRESULT is: \n$jamfRESULT"
			else
				"$jamfBINARY" policy > /dev/null 2>&1
			fi
		else
			sendToLog "Exit: Unable to submit inventory to Jamf Pro, trying again in $defaultDeferSECONDS seconds."
			makeLaunchDaemonCalendar
		fi
	else
		defaults delete "$superPLIST" UpdateValidate 2> /dev/null
		sendToLog "Status: All system updates complete, but Jamf binary not present."
	fi
else
	sendToLog "Status: Apple system updates did not complete after last restart, continuing update workflow."
fi
}

# Install only available recommended updates via Apple softwareupdate, and also save results to $superLOG and $updateLOG.
installRecommendedUpdatesASU() {
# Start log streaming for softwareupdate progress and send to $updateLOG.
if [[ "$macosMAJOR" != "10" ]]; then
	sendToLog "Status: Starting softwareupdate install of recommended updates. Check $updateLOG or /var/log/install.log for more detail..."
	echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. ASU RECOMMENDED INSTALL START ****" >> "$updateLOG"
	log stream --predicate '(subsystem == "com.apple.SoftwareUpdateMacController") && (eventMessage CONTAINS[c] "reported progress")' >> "$updateLOG" &
	updateStreamPID=$!
	disown
else
	sendToLog "Status: Starting softwareupdate install of recommended updates. Check /var/log/install.log for more detail..."
fi

oldIFS="$IFS"; IFS=$'\n'
for i in "${!recommendedLABLES[@]}"; do
	sendToLog "Status: Installing Recommended Software Update $((i + 1)): ${recommendedLABLES[i]}..."
	if [[ $macosMAJOR -eq 10 ]]; then
		recommendedRESULT=$(softwareupdate --install "${recommendedLABLES[i]}" 2>&1)
	else
		recommendedRESULT=$(softwareupdate --install "${recommendedLABLES[i]}" --agree-to-license 2>&1)
	fi
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: recommendedRESULT is: $recommendedRESULT"
	updateRECOMMENDED=$(echo "$recommendedRESULT" | grep "Done with" | cut -c 11-)
	if [[ -n $updateRECOMMENDED ]]; then
		sendToLog "Status: Installed Recommended Software Update: $updateRECOMMENDED."
	else
		sendToLog "Error: Apple softwareupdate failed to install recommended software update: $updateRECOMMENDED."; updateERROR="TRUE"
	fi
done
IFS="$oldIFS"
if [[ "$macosMAJOR" != "10" ]]; then
	kill -9 $updateStreamPID > /dev/null 2>&1
	echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. ASU RECOMMENDED INSTALL END ****" >> "$updateLOG"
fi
}

# Download all available updates via the Apple softwareupdate, and also save results to $superLOG, $updateLOG, and $superPLIST.
downloadAllUpdatesASU() {
sendToLog "Status: Downloading all available Apple software updates via softwareupdate command..."

# Start log streaming for softwareupdate progress and send to $updateLOG.
if [[ "$macosMAJOR" != "10" ]]; then
	echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. ASU DOWNLOAD START ****" >> "$updateLOG"
	log stream --predicate '(subsystem == "com.apple.SoftwareUpdateMacController") && (eventMessage CONTAINS[c] "reported progress")' >> "$updateLOG" &
	updateStreamPID=$!
	disown
fi

# Start the softwareupdate download.
if [[ "$macosARCH" == "arm64" ]]; then # Apple Silicon requires local credentials.
	if [[ "$localCREDENTIAL" == "TRUE" ]]; then
		downloadRESULT=$(softwareupdate --download --all --agree-to-license --user "$localACCOUNT" --stdinpass "$localKEYCHAIN" 2>&1)
	elif [[ "$superCREDENTIAL" == "TRUE" ]]; then
		downloadRESULT=$(softwareupdate --download --all --agree-to-license --user "$superACCOUNT" --stdinpass "$superKEYCHAIN" 2>&1)
	fi
else # Intel. No credentials required, but slightly different between macOS versions.
	if [[ $macosMAJOR -eq 10 ]]; then
		downloadRESULT=$(softwareupdate --download --all 2>&1)
	else
		downloadRESULT=$(softwareupdate --download --all --agree-to-license 2>&1)
	fi
fi
if [[ "$macosMAJOR" != "10" ]]; then
	kill -9 $updateStreamPID > /dev/null 2>&1
	echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. ASU DOWNLOAD END ****" >> "$updateLOG"
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: downloadRESULT is: $downloadRESULT"

# Parse $downloadRESULT for individual downloads and write to $superLOG and $superPLIST.
oldIFS="$IFS"; IFS=$'\n'
downloadedTITLES=($(echo "$downloadRESULT" | grep "Downloaded" | cut -d " " -f 2-))
if [[ ${#downloadedTITLES[@]} -gt 0 ]]; then
	sendToLog "Status: Downloaded ${#downloadedTITLES[@]} software udpate(s)."
	defaults delete "$superPLIST" UpdateDownloads 2> /dev/null
	for i in "${!downloadedTITLES[@]}"; do
		sendToLog "Status: Downloaded Software Update $((i + 1)): ${downloadedTITLES[i]}"
		defaults write "$superPLIST" UpdateDownloads -array-add "${downloadedTITLES[i]}"
	done
else
	sendToLog "Exit: Apple softwareupdate failed to download any updates, trying again in $defaultDeferSECONDS seconds. "
	makeLaunchDaemonCalendar
fi
IFS="$oldIFS"
}

# Download all available updates via Apple MDM push command, and also save results to $superLOG, $mdmLOG, $updateLOG, and $superPLIST.
downloadAllUpdatesMDM() {
sendToLog "Status: Starting MDM download of all updates."
# This pre-flights the MDM query locally and may also be useful for troubleshooting.
availableOSUPDATES=$(/usr/libexec/mdmclient AvailableOSUpdates 2>&1)
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: availableOSUPDATES is: \n$availableOSUPDATES"

# Make sure we still have a valid Jamf Pro API token.
checkJamfProServerToken

# Start log streaming for MDM push acknowledgements and send to $mdmLOG.
echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM DOWNLOAD START ****" >> "$mdmLOG"
log stream --predicate '(subsystem == "com.apple.ManagedClient") && (category == "HTTPUtil")' >> "$mdmLOG" &
mdmStreamPID=$!
disown

# Start log streaming for softwareupdate progress and send to $updateLOG.
echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM DOWNLOAD START ****" >> "$updateLOG"
log stream --predicate '(subsystem == "com.apple.SoftwareUpdateMacController") && (eventMessage CONTAINS[c] "reported progress")' >> "$updateLOG" &
updateStreamPID=$!
disown

# Send the Jamf Pro API command to download via MDM.
if [[ $jamfVERSION -ge 1038 ]]; then
	jamfAPIURL="${jamfSERVER}api/v1/macos-managed-software-updates/send-updates"
	jamfJSON='{ "deviceIds": ["'${jamfProID}'"], "skipVersionVerification": false, "applyMajorUpdate": false, "updateAction": "DOWNLOAD_ONLY" }'
	commandRESULT=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --header "Content-Type: application/json" --write-out "%{http_code}" --silent --output /dev/null --request POST --url "$jamfAPIURL" --data "$jamfJSON")
else
	sendToLog "Warning: Using legacy Jamf Pro Classic API. You should upgrade your Jamf Pro instance to 10.38 or later."
	commandRESULT=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --write-out "%{http_code}" --silent --output /dev/null --request POST --url "${jamfSERVER}JSSResource/computercommands/command/ScheduleOSUpdate/action/download/id/${jamfProID}")
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: commandRESULT is: \n$commandRESULT"

# If the Jamf Pro API command was successfully created, monitor the download progress.
if [[ $commandRESULT -eq 200 ]] || [[ $commandRESULT -eq 201 ]]; then
	sendToLog "Status: Successful MDM download request."
	sendBlankPush
	
	# Some helpfull logging while waiting for Jamf Pro's mandatory 5 minute delay.
	tail -n 0 -f "$mdmLOG" | while read -r logLINE ; do
		if echo "$logLINE" | grep -q "Received HTTP response (200) \[Acknowledged(ScheduleOSUpdateScan):"; then
			sendToLog "Status: Acknowledged MDM update scan request, checking back after Jamf Pro's mandatory 5 minute delay..."
			pkill -P $$ tail
			break
		fi
	done
	timerEND=300
	while [[ $timerEND -ge 0 ]]; do
		echo -ne "Waiting for Jamf Pro's mandatory 5 minute delay: -$(date -u -r $timerEND +%M:%S)\r"
		timerEND=$((timerEND - 1))
		sleep 1
	done
	echo
	sendBlankPush
	
	# Watch $mdmLOG while waiting for the MDM workflow to complete.
	tail -n 0 -f "$mdmLOG" | while read -r logLINE ; do
		if echo "$logLINE" | grep -q 'Received HTTP response (200) \[Idle\]'; then
			sendToLog "Status: Recieved MDM blank push."
		elif echo "$logLINE" | grep -q 'Received HTTP response (200) \[Acknowledged(AvailableOSUpdates):'; then
			sendToLog "Status: Acknowledged MDM return available updates."
		elif echo "$logLINE" | grep -q 'Received HTTP response (200) \[Acknowledged(ScheduleOSUpdate):'; then
			sendToLog "Status: Acknowledged MDM scheduled software update, download should start soon..."
			kill -9 $mdmStreamPID > /dev/null 2>&1
			echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM DOWNLOAD END ****" >> "$mdmLOG"
			pkill -P $$ tail; break
		fi
	done
	
	# Watch $updateLOG while waiting for the download workflow to complete.
	tail -n 0 -f "$updateLOG" | while read -r logLINE ; do
		if echo "$logLINE" | grep -q -w 'phase:DOWNLOADING_SFR\|phase:DOWNLOADING_UPDATE'; then
			[[ "$logPROGRESS" != "Downloading" ]] && sendToLog "Status: Downloading software update..."
			logPROGRESS="Downloading"
			[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: Downloading and preparing update percentage complete: $(echo "$logLINE" | awk -F '[ :]+' '{ print $23*100; }' | cut -c 1-4)%"
		elif echo "$logLINE" | grep -q -w 'phase:PREPARING_UPDATE'; then
			[[ "$logPROGRESS" != "Preparing" ]] && sendToLog "Status: Download complete, preparing software update, should be done in a few minutes..."
			logPROGRESS="Preparing"
			[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: Downloading and preparing update percentage complete: $(echo "$logLINE" | awk -F '[ :]+' '{ print $23*100; }' | cut -c 1-4)%"
		elif echo "$logLINE" | grep -q -w 'phase:COMPLETED'; then
			sendToLog "Status: Software update is downloaded and prepared."
			kill -9 $updateStreamPID > /dev/null 2>&1
			echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM DOWNLOAD END ****" >> "$updateLOG"
			oldIFS="$IFS", IFS=$'\n'
			defaults write "$superPLIST" UpdateDownloads -array-add "${allTITLES[i]}"
			IFS="$oldIFS"
			pkill -P $$ tail; break
		fi
	done
else
	sendToLog "Exit: Failed to send MDM download request. Verify that the Jamf Pro API account \"$jamfACCOUNT\" has the privileges \"Jamf Pro Server Objects > Computers > Create & Read\" and \"Jamf Pro Server Actions > Send Computer Remote Command to Download and Install macOS Update\"."
	kill -9 $mdmStreamPID > /dev/null 2>&1
	rm -f "$superPIDFILE"
	sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
	exit 1
fi
}

# Install any optional $policyTRIGGERS.
runJamfPolicies() {
sendToLog "Status: Starting Jamf Policy triggers. Use \"--verbose-mode\" or check /var/log/jamf.log for more detail..."
oldIFS="$IFS"; IFS=','
read -r -a triggerARRAY <<< "$policyTRIGGERS"
for trigger in "${triggerARRAY[@]}"; do
	if [[ "$testModeOPTION" != "TRUE" ]]; then
		sendToLog "Status: Jamf Policy with Trigger \"$trigger\" is starting..."
		if [[ "$verboseModeOPTION" == "TRUE" ]]; then
			jamfRESULT=$("$jamfBINARY" policy -event "$trigger" -verbose 2>&1)
			jamfRETURN=$?
			sendToLog "Verbose Mode: jamfRESULT is: \n$jamfRESULT"
			sendToLog "Verbose Mode: jamfRETURN is: $jamfRETURN"
		else
			"$jamfBINARY" policy -event "$trigger" > /dev/null 2>&1
			jamfRETURN=$?
		fi
		if [ $jamfRETURN -ne 0 ]; then
			sendToLog "Error: Jamf Policy with Trigger \"$trigger\" failed!"; jamfERROR="TRUE"
		else
			sendToLog "Status: Jamf Policy with Trigger \"$trigger\" was succesfull."
		fi
	else
		sendToLog "Test Mode: Skipping Jamf Policy with Trigger: $trigger."
	fi
done
IFS="$oldIFS"
if [[ "$testModeOPTION" != "TRUE" ]]; then
	if [[ "$jamfERROR" != "TRUE" ]]; then
		sendToLog "Status: All Jamf Policies completed, clearing --policy-triggers option."
		defaults delete "$superPLIST" PolicyTriggers 2> /dev/null
	else
		sendToLog "Status: Some Jamf Policies failed, not clearing --policy-triggers option."
	fi
else
	sendToLog "Test Mode: Killing update restart notification in $testModeTIMEOUT seconds..."
	sleep "$testModeTIMEOUT"
	kill -9 "$notifyPID" > /dev/null 2>&1
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
	else
		killall -9 "jamfHelper" > /dev/null 2>&1
	fi
fi
}

# This is the install and restart workflow when a user is NOT logged in.
installRestartSilent(){
if [[ "$updatesRESTART" == "TRUE" ]]; then # Install restart required system updates if needed.
	if [[ "$localCREDENTIAL" == "TRUE" ]] || [[ "$superCREDENTIAL" == "TRUE" ]] || [[ "$macosARCH" == "i386" ]]; then
		[[ -n $policyTRIGGERS ]] && runJamfPolicies # If requested, run Jamf Policy Triggers.
		installUpdatesRestartASU
	elif [[ "$jamfCREDENTIAL" == "TRUE" ]]; then
		[[ -n $policyTRIGGERS ]] && runJamfPolicies # If requested, run Jamf Policy Triggers.
		installUpdatesRestartMDM
	else # Apple Silicon with no valid update credentials.
		sendToLog "Status: No valid Apple Silicon credentials and no current local user, trying again in $defaultDeferSECONDS seconds."
		makeLaunchDaemonCalendar
	fi
else # Otherwise, this is the workflow when there are no restart required system updates.
	[[ -n $policyTRIGGERS ]] && runJamfPolicies # If requested, run Jamf Policy Triggers.
	if [[ "$forceRestartOPTION" == "TRUE" ]]; then # If requested, force the computer to restart.
		if [[ "$testModeOPTION" != "TRUE" ]]; then
			sendToLog "Forced Restart Mode: Restarting computer..."
			shutdown -o -r +1 &
			disown
		else
			sendToLog "Test Mode: Skipping forced restart."
		fi
	fi
fi
clearMaxDeferralCounter
defaults delete "$superPLIST" UpdateDownloads 2> /dev/null
}

# This is the install and restart workflow when a user is logged in.
installRestartMain(){
if [[ "$updatesRESTART" == "TRUE" ]]; then # Install restart required system updates if needed.
	if [[ "$localCREDENTIAL" == "TRUE" ]] || [[ "$superCREDENTIAL" == "TRUE" ]] || [[ "$macosARCH" == "i386" ]]; then
		notifyRestart
		[[ -n $policyTRIGGERS ]] && runJamfPolicies # If needed run Jamf Policy Triggers.
		installUpdatesRestartASU
	elif [[ "$jamfCREDENTIAL" == "TRUE" ]]; then
		notifyRestartPrepMDM
		[[ -n $policyTRIGGERS ]] && runJamfPolicies # If needed run Jamf Policy Triggers.
		installUpdatesRestartMDM
	else # Can only encourage manual self-update if Apple Silicon with no valid update credentials.
		[[ -n $policyTRIGGERS ]] && sendToLog "Warning: Skipping Jamf Policy triggers because there are no valid Apple Silicon update crednetials to ensure a proper workflow."
		notifySelfUpdate &
		disown
	fi
	defaults delete "$superPLIST" UpdateDownloads 2> /dev/null
else # Otherwise, this is the workflow when there are no restart required system updates.
	notifyRestart
	[[ -n $policyTRIGGERS ]] && runJamfPolicies # If requested, run Jamf Policy Triggers.
	if [[ "$forceRestartOPTION" == "TRUE" ]]; then # If requested, force the computer to restart.
		if [[ "$testModeOPTION" != "TRUE" ]]; then
			sendToLog "Forced Restart Mode: Restarting computer..."
			shutdown -o -r +1 &
			disown
		else
			sendToLog "Test Mode: Skipping forced restart, killing restart notification in $testModeTIMEOUT seconds..."
			sleep "$testModeTIMEOUT"
			kill -9 "$notifyPID" > /dev/null 2>&1
			if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
				killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
			else
				killall -9 "jamfHelper" > /dev/null 2>&1
			fi
		fi
	fi
fi
clearMaxDeferralCounter
}

# Install all available updates and restart the computer via Apple softwareupdate.
installUpdatesRestartASU() {
if [[ "$testModeOPTION" != "TRUE" ]]; then
	sendToLog "Status: Starting softwareupdate install of all updates and restarting..."
	
	# Start log streaming for softwareupdate install progress and send to $updateLOG.
	if [[ "$macosMAJOR" != "10" ]]; then
		echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. ASU FULL INSTALL START ****" >> "$updateLOG"
		log stream --predicate '(subsystem == "com.apple.SoftwareUpdateMacController") && (eventMessage CONTAINS[c] "reported progress")' >> "$updateLOG" &
		updateStreamPID=$!
		disown
	fi
	
	if [[ "$macosARCH" == "arm64" ]]; then # Apple Silicon softwareupdate requires local credentials.
		if [[ "$localCREDENTIAL" == "TRUE" ]]; then
			softwareupdate --install --all --agree-to-license --restart --force --user "$localACCOUNT" --stdinpass "$localKEYCHAIN" &
			disown
		elif [[ "$superCREDENTIAL" == "TRUE" ]]; then
			softwareupdate --install --all --agree-to-license --restart --force --user "$superACCOUNT" --stdinpass "$superKEYCHAIN" &
			disown
		fi
	else # Intel. No credentials required.
		if [[ $macosMAJOR -eq 10 ]]; then # Older versions of macOS.
			softwareupdate --install --all --restart --force &
			disown
		else # Newer versions of macOS require license agreement.
			softwareupdate --install --all --agree-to-license --restart --force &
			disown
		fi
	fi
	defaults delete "$superPLIST" UpdateDownloads 2> /dev/null
	defaults write "$superPLIST" UpdateValidate -bool true
	makeLaunchDaemonOnStartup
else
	sendToLog "Test Mode: Skipping softwareupdate install of all updates and restart."
	sendToLog "Test Mode: Killing update restart notification in $testModeTIMEOUT seconds..."
	sleep "$testModeTIMEOUT"
	kill -9 "$notifyPID" > /dev/null 2>&1
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
	else
		killall -9 "jamfHelper" > /dev/null 2>&1
	fi
fi
}

# Install all available updates and restarts the computer via Apple MDM push command, and also save results to $superLOG, $mdmLOG, $updateLOG, and $superPLIST.
installUpdatesRestartMDM() {
if [[ "$testModeOPTION" != "TRUE" ]]; then
	sendToLog "Status: Starting MDM install of all updates and restarting."
	# This pre-flights the MDM query locally and may also be useful for troubleshooting.
	availableOSUPDATES=$(/usr/libexec/mdmclient AvailableOSUpdates 2>&1)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: availableOSUPDATES is: \n$availableOSUPDATES"
	
	# Make sure we still have a valid Jamf Pro API token.
	checkJamfProServerToken
	
	# Start log streaming for MDM push acknowledgements and send to $mdmLOG.
	echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM UPDATE/RESTART START ****" >> "$mdmLOG"
	log stream --predicate '(subsystem == "com.apple.ManagedClient") && (category == "HTTPUtil")' >> "$mdmLOG" &
	mdmStreamPID=$!
	disown
	
	# Start log streaming for softwareupdate progress and send to $updateLOG.
	echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM UPDATE/RESTART START ****" >> "$updateLOG"
	log stream --predicate '(subsystem == "com.apple.SoftwareUpdateMacController") && (eventMessage CONTAINS[c] "reported progress")' >> "$updateLOG" &
	updateStreamPID=$!
	disown
	
	# Send the Jamf Pro API command to update and restart via MDM.
	if [[ $jamfVERSION -ge 1038 ]]; then
		jamfAPIURL="${jamfSERVER}api/v1/macos-managed-software-updates/send-updates"
		jamfJSON='{ "deviceIds": ["'${jamfProID}'"], "skipVersionVerification": false, "applyMajorUpdate": false, "updateAction": "DOWNLOAD_AND_INSTALL", "forceRestart": true }'
		commandRESULT=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --header "Content-Type: application/json" --write-out "%{http_code}" --silent --output /dev/null --request POST --url "${jamfAPIURL}" --data "${jamfJSON}")
	else
		sendToLog "Warning: Using legacy Jamf Pro Classic API. You should upgrade your Jamf Pro instance to 10.38 or later."
		commandRESULT=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --write-out "%{http_code}" --silent --output /dev/null --request POST --url "${jamfSERVER}JSSResource/computercommands/command/ScheduleOSUpdate/action/install/id/${jamfProID}")
	fi
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: commandRESULT is: \n$commandRESULT"
	
	# If the Jamf Pro API command was successfully created, monitor the update progress.
	if [[ $commandRESULT -eq 200 ]] || [[ $commandRESULT -eq 201 ]]; then
		sendToLog "Status: Successful MDM update and restart request."
		sendBlankPush
		
		# Some helpfull logging while waiting for Jamf Pro's mandatory 5 minute delay.
		tail -n 0 -f "$mdmLOG" | while read -r logLINE ; do
			if echo "$logLINE" | grep -q "Received HTTP response (200) \[Acknowledged(ScheduleOSUpdateScan):"; then
				sendToLog "Status: Acknowledged MDM update scan request, checking back after Jamf Pro's mandatory 5 minute delay..."
				pkill -P $$ tail
				break
			fi
		done
		timerEND=300
		while [[ $timerEND -ge 0 ]]; do
			echo -ne "Waiting for Jamf Pro's mandatory 5 minute delay: -$(date -u -r $timerEND +%M:%S)\r"
			timerEND=$((timerEND - 1))
			sleep 1
		done
		echo
		sendBlankPush
		kill -9 "$notifyPID" > /dev/null 2>&1
		if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
			killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
		else
			killall -9 "jamfHelper" > /dev/null 2>&1
		fi
		notifyRestart
		
		# Watch $mdmLOG while waiting for the MDM workflow to complete.
		tail -n 0 -f "$mdmLOG" | while read -r logLINE ; do
			if echo "$logLINE" | grep -q 'Received HTTP response (200) \[Idle\]'; then
				sendToLog "Status: Recieved MDM blank push."
			elif echo "$logLINE" | grep -q 'Received HTTP response (200) \[Acknowledged(AvailableOSUpdates):'; then
				sendToLog "Status: Acknowledged MDM return available updates."
			elif echo "$logLINE" | grep -q 'Received HTTP response (200) \[Acknowledged(ScheduleOSUpdate):'; then
				sendToLog "Status: Acknowledged MDM scheduled software update and restart, restart should be very soon..."
				kill -9 "$mdmStreamPID" > /dev/null 2>&1
				echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM UPDATE END ****" >> "$mdmLOG"
				pkill -P $$ tail; break
			fi
		done
		
		# Watch $updateLOG while waiting for the update and restart workflow to complete.
		tail -n 0 -f "$updateLOG" | while read -r logLINE ; do
			if echo "$logLINE" | grep -q -w 'phase:APPLYING'; then
				sendToLog "Status: Software update and restart process is complete, restart imminent..."
				kill -9 "$updateStreamPID" > /dev/null 2>&1
				echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM UPDATE END ****" >> "$updateLOG"
				defaults write "$superPLIST" UpdateValidate -bool true
				makeLaunchDaemonOnStartup
				pkill -P $$ tail; break
			fi
		done
	else
		sendToLog "Exit: Failed to send MDM update request. Verify that the Jamf Pro API account \"$jamfACCOUNT\" has the privileges \"Jamf Pro Server Objects > Computers > Create & Read\" and \"Jamf Pro Server Actions > Send Computer Remote Command to Download and Install macOS Update\"."
		kill -9 "$mdmStreamPID" > /dev/null 2>&1
		rm -f "$superPIDFILE"
		sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
		exit 1
	fi
else
	sendToLog "Test Mode: Skipping MDM update and restart request."
	sendToLog "Test Mode: Killing MDM preparation notification in $testModeTIMEOUT seconds..."
	sleep "$testModeTIMEOUT"
	kill -9 "$notifyPID" > /dev/null 2>&1
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
	else
		killall -9 "jamfHelper" > /dev/null 2>&1
	fi
	notifyRestart
	sendToLog "Test Mode: Killing update restart notification in $testModeTIMEOUT seconds..."
	sleep "$testModeTIMEOUT"
	kill -9 "$notifyPID" > /dev/null 2>&1
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
	else
		killall -9 "jamfHelper" > /dev/null 2>&1
	fi
fi
}

######## FUNCTIONS - LAUNCHDAEMON ########

# Create a LaunchDaemon to run super-starter again right now, thus releasing any Jamf Pro Policy that may have started super.
makeLaunchDaemonRestartNow() {
# This creates a LaunchDaemon.plist file.
/bin/cat <<EOLDL > "/Library/LaunchDaemons/$launchDaemonNAME.plist"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>$launchDaemonNAME</string>
	<key>LaunchOnlyOnce</key>
	<true/>
	<key>AbandonProcessGroup</key>
	<true/>
	<key>UserName</key>
	<string>root</string>
	<key>ProgramArguments</key>
	<array>
		<string>$superFOLDER/super-starter</string>
	</array>
	<key>RunAtLoad</key>
	<true/>
</dict>
</plist>
EOLDL

[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "LaunchDaemon: $launchDaemonNAME.plist...\n$(cat "/Library/LaunchDaemons/$launchDaemonNAME.plist")"

# Set proper permissions and load the LaunchDaemon.
chmod 644 "/Library/LaunchDaemons/$launchDaemonNAME.plist"
chown root:wheel "/Library/LaunchDaemons/$launchDaemonNAME.plist"
sendToLog "Exit: LaunchDaemon $launchDaemonNAME.plist is scheduled to start right now."
launchctl bootstrap system "/Library/LaunchDaemons/$launchDaemonNAME.plist"
rm -f "$superPIDFILE"
sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
exit 0
}

# Create a LaunchDaemon to run super-starter again after system restart so we can validate the update progress.
makeLaunchDaemonOnStartup() {
# This creates a LaunchDaemon.plist file.
/bin/cat <<EOLDL > "/Library/LaunchDaemons/$launchDaemonNAME.plist"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>$launchDaemonNAME</string>
	<key>LaunchOnlyOnce</key>
	<true/>
	<key>AbandonProcessGroup</key>
	<true/>
	<key>UserName</key>
	<string>root</string>
	<key>ProgramArguments</key>
	<array>
		<string>$superFOLDER/super-starter</string>
	</array>
	<key>RunAtLoad</key>
	<true/>
</dict>
</plist>
EOLDL

[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "LaunchDaemon: $launchDaemonNAME.plist...\n$(cat "/Library/LaunchDaemons/$launchDaemonNAME.plist")"

# Set proper permissions and load the LaunchDaemon.
chmod 644 "/Library/LaunchDaemons/$launchDaemonNAME.plist"
chown root:wheel "/Library/LaunchDaemons/$launchDaemonNAME.plist"
sendToLog "Exit: LaunchDaemon $launchDaemonNAME.plist is scheduled at next startup."
}

# Create a LaunchDaemon to run super-starter again $defaultDeferSECONDS from now.
makeLaunchDaemonCalendar() {
# Calculate the appropriate deferment timer for the LaunchDaemon.
deferCALC=$(($(date +%s) + defaultDeferSECONDS))
month=$(date -j -f "%s" "$deferCALC" "+%m" | xargs)
day=$(date -j -f "%s" "$deferCALC" "+%e" | xargs)
hour=$(date -j -f "%s" "$deferCALC" "+%H" | xargs)
minute=$(date -j -f "%s" "$deferCALC" "+%M" | xargs)

# This creates a LaunchDaemon.plist file.
/bin/cat <<EOLDL > "/Library/LaunchDaemons/$launchDaemonNAME.plist"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>$launchDaemonNAME</string>
	<key>LaunchOnlyOnce</key>
	<true/>
	<key>AbandonProcessGroup</key>
	<true/>
	<key>UserName</key>
	<string>root</string>
	<key>ProgramArguments</key>
	<array>
		<string>$superFOLDER/super-starter</string>
	</array>
	<key>StartCalendarInterval</key>
	<array>
		<dict>
		<key>Month</key>
		<integer>$month</integer>
		<key>Day</key>
		<integer>$day</integer>
		<key>Hour</key>
		<integer>$hour</integer>
		<key>Minute</key>
		<integer>$minute</integer>
		</dict>
	</array>
</dict>
</plist>
EOLDL

[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "LaunchDaemon: $launchDaemonNAME.plist...\n$(cat "/Library/LaunchDaemons/$launchDaemonNAME.plist")"

# Set proper permissions and load the LaunchDaemon.
chmod 644 "/Library/LaunchDaemons/$launchDaemonNAME.plist"
chown root:wheel "/Library/LaunchDaemons/$launchDaemonNAME.plist"
sendToLog "Exit: LaunchDaemon $launchDaemonNAME.plist is scheduled to start at $hour:$minute on $month/$day."
launchctl bootstrap system "/Library/LaunchDaemons/$launchDaemonNAME.plist"
rm -f "$superPIDFILE"
sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
exit 0
}

######## FUNCTIONS - USER INTERACTION ########

# Open $ibmNotifierBINARY using the $ibmNotifierARRAY[] options including the handling of any $displayTimeoutSECONDS and $displayRedrawSECONDS options.
openIbmNotifier() {
unset dialogRESULT
unset dialogRETURN
if [[ -n $displayRedrawSECONDS ]]; then
	[[ -n $displayTimeoutSECONDS ]] && displayTimeoutSECONDS=$((displayTimeoutSECONDS - 1))
	while [[ -z $dialogRETURN ]] || [[ "$dialogRETURN" -eq 137 ]]; do
		{ [[ -n $displayTimeoutSECONDS ]] && [[ -z $menuDeferSECONDS ]]; } && ibmNotifierARRAY+=(-accessory_view_type timer -accessory_view_payload "Please make selection in %@" -timeout "$displayTimeoutSECONDS")
		{ [[ -n $displayTimeoutSECONDS ]] && [[ -n $menuDeferSECONDS ]]; } && ibmNotifierARRAY+=(-secondary_accessory_view_type timer -secondary_accessory_view_payload "Please make selection in %@" -timeout "$displayTimeoutSECONDS")
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Ibm Notifier.app options: ${ibmNotifierARRAY[*]}"
		(sleep "$displayRedrawSECONDS"; killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1) &
		killerPID=$!
		dialogRESULT=$("$ibmNotifierBINARY" "${ibmNotifierARRAY[@]}")
		dialogRETURN="$?"
		kill -0 $killerPID && kill -9 $killerPID > /dev/null 2>&1
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog result: $dialogRESULT"
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog return: $dialogRETURN"
		[[ -n $displayTimeoutSECONDS ]] && displayTimeoutSECONDS=$((displayTimeoutSECONDS - displayRedrawSECONDS))
	done
else
	{ [[ -n $displayTimeoutSECONDS ]] && [[ -z $menuDeferSECONDS ]]; } && ibmNotifierARRAY+=(-accessory_view_type timer -accessory_view_payload "Please make selection in %@" -timeout "$displayTimeoutSECONDS")
	{ [[ -n $displayTimeoutSECONDS ]] && [[ -n $menuDeferSECONDS ]]; } && ibmNotifierARRAY+=(-secondary_accessory_view_type timer -secondary_accessory_view_payload "Please make selection in %@" -timeout "$displayTimeoutSECONDS")
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Ibm Notifier.app options: ${ibmNotifierARRAY[*]}"
	dialogRESULT=$("$ibmNotifierBINARY" "${ibmNotifierARRAY[@]}")
	dialogRETURN="$?"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog result: $dialogRESULT"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog return: $dialogRETURN"
fi
}

# Open $jamfHELPER using the $jamfHelperARRAY[] options including the handling of any $displayTimeoutSECONDS and $displayRedrawSECONDS options.
openJamfHelper() {
unset dialogRESULT
unset dialogRETURN
if [[ -n $displayRedrawSECONDS ]]; then
	[[ -n $displayTimeoutSECONDS ]] && displayTimeoutSECONDS=$((displayTimeoutSECONDS - 1))
	while [[ -z $dialogRESULT ]]; do
		[[ -n $displayTimeoutSECONDS ]] && jamfHelperARRAY+=(-timeout "$displayTimeoutSECONDS" -countdown)
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "jamfHelper options: ${jamfHelperARRAY[*]}"
		(sleep "$displayRedrawSECONDS"; killall -9 "jamfHelper" > /dev/null 2>&1) &
		killerPID=$!
		dialogRESULT=$("$jamfHELPER" "${jamfHelperARRAY[@]}")
		dialogRETURN="$?"
		kill -0 $killerPID && kill -9 $killerPID > /dev/null 2>&1
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog result: $dialogRESULT"
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog return: $dialogRETURN"
		[[ -n $displayTimeoutSECONDS ]] && displayTimeoutSECONDS=$((displayTimeoutSECONDS - displayRedrawSECONDS))
	done
else
	[[ -n $displayTimeoutSECONDS ]] && jamfHelperARRAY+=(-timeout "$displayTimeoutSECONDS" -countdown)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "jamfHelper options: ${jamfHelperARRAY[*]}"
	dialogRESULT=$("$jamfHELPER" "${jamfHelperARRAY[@]}")
	dialogRETURN="$?"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog result: $dialogRESULT"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog return: $dialogRETURN"
fi
}

# Display a non-interactive notification informing the user that the computer going to restart soon.
notifyRestart() {
# Non-interactive notifications do not need a redraw or timeout.
unset displayRedrawSECONDS
unset displayTimeoutSECONDS

if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
	# Create initial $ibmNotifierARRAY[] settings for the notification.
	ibmNotifierARRAY=(-type popup -always_on_top -position top_right -bar_title "Software Updates Require Restart" -icon_path "$cachedICON" -icon_width "$ibmNotifierIconSIZE" -icon_height "$ibmNotifierIconSIZE" -accessory_view_type progressbar -accessory_view_payload "/percent indeterminate")

	# Body text for pending restart.
	if [[ "$deadlineSTATUS" == "HARD" ]]; then # Only the hard deadline requires additional explanation.
		sendToLog "IBM Notifier: Hard Deadline restart soon notification."
		ibmNotifierARRAY+=(-subtitle "The final deadline of $hardDISPLAY has passed.\n\nThis computer will automatically restart very soon.\n\nSave any open documents now.")
	else # The update preparation notification for all other workflows.
		sendToLog "IBM Notifier: Restart soon notification."
		ibmNotifierARRAY+=(-subtitle "This computer will automatically restart very soon.\n\nSave any open documents now.")
	fi

	# Open notification in the background allowing super to continue.
	openIbmNotifier &
	notifyPID=$!
	disown
else
	# Create initial $jamfHelperARRAY[] settings for the dialog.
	jamfHelperARRAY=(-windowType hud -windowPosition ur -lockHUD -title "Software Updates Require Restart" -icon "$cachedICON" -iconSize "$jamfHelperIconSIZE")
	
	# Body text for pending restart. Note that any invisible characters (tabs and new line) will be "shown" in the jamfHelper dialog.
	if [[ "$deadlineSTATUS" == "HARD" ]]; then # Only the hard deadline requires additional explanation.
		sendToLog "jamfHelper Notification: Hard Deadline restart soon notification."
		jamfHelperARRAY+=(-description "The final deadline of $hardDISPLAY has passed.

This computer will automatically restart very soon.

Save any open documents now.")
	else # The update preparation notification for all other workflows.
		sendToLog "jamfHelper: Restart soon notification."
		jamfHelperARRAY+=(-description "This computer will automatically restart very soon.

Save any open documents now.")
	fi

	# Open notification in the background allowing super to continue.
	openJamfHelper &
	notifyPID=$!
	disown
fi
}

# Display a non-interactive notification informing the user that the MDM update process has started.
notifyRestartPrepMDM() {
# Non-interactive notifications do not need a redraw or timeout.
unset displayRedrawSECONDS
unset displayTimeoutSECONDS

if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
	# Create initial $ibmNotifierARRAY[] settings for the notification.
	ibmNotifierARRAY=(-type popup -always_on_top -position top_right -bar_title "Software Updates Require Restart" -icon_path "$cachedICON" -icon_width "$ibmNotifierIconSIZE" -icon_height "$ibmNotifierIconSIZE" -accessory_view_type progressbar -accessory_view_payload "/percent indeterminate")

	# Body text for MDM preparation.
	if [[ "$deadlineSTATUS" == "HARD" ]]; then # Only the hard deadline requires additional explanation.
		sendToLog "IBM Notifier: Hard Deadline MDM preparation notification."
		ibmNotifierARRAY+=(-subtitle "The final deadline has passed: $hardDISPLAY\n\nA required software update will automatically restart this computer in about 5 minutes.\n\nDuring this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process.")
	else # The update preparation notification for all other workflows.
		sendToLog "IBM Notifier: MDM preparation notification."
		ibmNotifierARRAY+=(-subtitle "A required software update will automatically restart this computer in about 5 minutes.\n\nDuring this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process.")
	fi

	# Open notification in the background allowing super to continue.
	openIbmNotifier &
	notifyPID=$!
	disown
else
	# Create initial $jamfHelperARRAY[] settings for the dialog.
	jamfHelperARRAY=(-windowType hud -windowPosition ur -lockHUD -title "Software Updates Require Restart" -icon "$cachedICON" -iconSize "$jamfHelperIconSIZE")

	# Body text for MDM preparation. Note that any invisible characters (tabs and new line) will be "shown" in the jamfHelper dialog.
	if [[ "$deadlineSTATUS" == "HARD" ]]; then # Only the hard deadline requires additional explanation.
		sendToLog "jamfHelper: Hard Deadline MDM preparation notification."
		jamfHelperARRAY+=(-description "The final deadline has passed: $hardDISPLAY

A required software update will automatically restart this computer in about 5 minutes.

During this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process.")
	else # The update preparation notification for all other workflows.
		sendToLog "jamfHelper: Hard Deadline MDM preparation notification."
		jamfHelperARRAY+=(-description "A required software update will automatically restart this computer in about 5 minutes.

During this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process.")
	fi

	# Open notification in the background allowing super to continue.
	openJamfHelper &
	notifyPID=$!
	disown
fi
}

# Open both a non-interactive notification and the Software Update System Preference in the case where there are no valid Apple Silicon credentials but a restart update is required.
notifySelfUpdate() {
if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
	sendToLog "IBM Notifier: No valid Apple Silicon credentials, opening self-update notification..."
	# Create initial $ibmNotifierARRAY[] settings for the notification.
	ibmNotifierARRAY=(-type popup -always_on_top -position top_left -bar_title "Software Updates Require Restart" -icon_path "$cachedICON" -icon_width "$ibmNotifierIconSIZE" -icon_height "$ibmNotifierIconSIZE" -accessory_view_type progressbar -accessory_view_payload "/percent indeterminate")

	# Body text for self-update notification.
	ibmNotifierARRAY+=(-subtitle "You need to update this Mac as soon as possible by clicking the \"Update Now\" or \"Restart Now\" button in Software Update.")
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Ibm Notifier.app options: ${ibmNotifierARRAY[*]}"
else
	sendToLog "jamfHelper: No valid Apple Silicon credentials, opening self-update notification..."
	# Create initial $jamfHelperARRAY[] settings for the dialog.
	jamfHelperARRAY=(-windowType hud -windowPosition ul -lockHUD -title "Software Updates Require Restart" -icon "$cachedICON" -iconSize "$jamfHelperIconSIZE")

	# Body text for self-update notification. Note that any invisible characters (tabs and new line) will be "shown" in the jamfHelper dialog.
	jamfHelperARRAY+=(-description "You need to update this Mac as soon as possible by clicking the \"Update Now\" or \"Restart Now\" button in Software Update.")
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "jamfHelper Options: ${jamfHelperARRAY[*]}"
fi

# Start System Preferences and the notification.
unset dialogRESULT
if [[ -n $displayRedrawSECONDS ]]; then
	[[ "$testModeOPTION" == "TRUE" ]] && redrawCOUNTER=0
	[[ "$testModeOPTION" == "TRUE" ]] && sendToLog "Test Mode: Killing self-update notification after 3 attempts..."
	[[ "$testModeOPTION" != "TRUE" ]] && sendToLog "Warning: The self-update notification will re-display every $displayRedrawSECONDS seconds until the user restarts the computer."
	while [[ -z $dialogRESULT ]] && [[ redrawCOUNTER -lt 3 ]]; do
		sudo -u "$currentUSER" open "/System/Library/PreferencePanes/SoftwareUpdate.prefPane" -a "/System/Applications/System Preferences.app"
		if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
			"$ibmNotifierBINARY" "${ibmNotifierARRAY[@]}" &
		else
			"$jamfHELPER" "${jamfHelperARRAY[@]}" &
		fi
		sleep "$displayRedrawSECONDS"
		[[ "$testModeOPTION" == "TRUE" ]] && redrawCOUNTER=$((redrawCOUNTER + 1))
		if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
			killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
		else
			killall -9 "jamfHelper" > /dev/null 2>&1
		fi
		killall -9 "System Preferences" > /dev/null 2>&1
	done
else
	[[ "$testModeOPTION" != "TRUE" ]] && sendToLog "Warning: The self-update notification will not close until the user restarts the computer."
	sudo -u "$currentUSER" open "/System/Library/PreferencePanes/SoftwareUpdate.prefPane" -a "/System/Applications/System Preferences.app"
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		"$ibmNotifierBINARY" "${ibmNotifierARRAY[@]}" &
	else
		"$jamfHELPER" "${jamfHelperARRAY[@]}" &
	fi
	if [[ "$testModeOPTION" == "TRUE" ]]; then
		sendToLog "Test Mode: Killing self-update notification in $testModeTIMEOUT seconds..."
		sleep "$testModeTIMEOUT"
		if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
			killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
		else
			killall -9 "jamfHelper" > /dev/null 2>&1
		fi
		killall -9 "System Preferences" > /dev/null 2>&1
	fi
fi
}

# Generate the $ibmNotifierARRAY[] or $jamfHelperARRAY[] to display an interactive dialog when $softDEADLINE has passed.
dialogSoftDeadline() {
if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
	sendToLog "IBM Notifier: Soft deadline passed dialog..."
	# Create initial $ibmNotifierARRAY[] settings for the dialog.
	ibmNotifierARRAY=(-type popup -always_on_top -bar_title "Software Updates Require Restart" -icon_path "$cachedICON" -icon_width "$ibmNotifierIconSIZE" -icon_height "$ibmNotifierIconSIZE" -main_button_label "$restartButtonTEXT")

	# Body text for being past the hard deadline date.
	ibmNotifierARRAY+=(-subtitle "You have reached the deadline of: $softDISPLAY.")

	# Start the dialog.
	openIbmNotifier

	# The $dialogRETURN contains the IBM Notifier.app return code.
	case "$dialogRETURN" in
		0)
			sendToLog "Status: User chose to restart."
		;;
		255)
			sendToLog "Status: Display timeout automatically chose to restart."
		;;
	esac
else
	sendToLog "jamfHelper: Soft deadline passed dialog..."
	# Create initial $jamfHelperARRAY[] settings for the dialog.
	jamfHelperARRAY=(-windowType utility -title "Software Updates Require Restart" -icon "$cachedICON" -iconSize "$jamfHelperIconSIZE" -button1 "$restartButtonTEXT" -defaultButton 1)

	# Body text for being past the hard deadline date. Note that any invisible characters (tabs and new line) will be "shown" in the jamfHelper dialog.
	jamfHelperARRAY+=(-description "You have reached the deadline of: $softDISPLAY.")

	# Start the dialog.
	openJamfHelper
	sendToLog "Status: User or display timeout accepted soft deadline dialog."
fi
}

# Generate the $ibmNotifierARRAY[] or $jamfHelperARRAY[] to display an interactive dialog when $countDEADLINE is exceeded.
dialogCountDeadline() {
if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
	sendToLog "IBM Notifier: Defer count exceeded dialog..."
	# Create initial $ibmNotifierARRAY[] settings for the dialog.
	ibmNotifierARRAY=(-type popup -always_on_top -bar_title "Software Updates Require Restart" -icon_path "$cachedICON" -icon_width "$ibmNotifierIconSIZE" -icon_height "$ibmNotifierIconSIZE" -main_button_label "$restartButtonTEXT")

	# Body text for being past the hard deadline date.
	ibmNotifierARRAY+=(-subtitle "You have deferred the maximum number of $countDEADLINE times.")

	# Start the dialog.
	openIbmNotifier
	
	# The $dialogRETURN contains the IBM Notifier.app return code.
	case "$dialogRETURN" in
		0)
			sendToLog "Status: User chose to restart."
		;;
		255)
			sendToLog "Status: Display timeout automatically chose to restart."
		;;
	esac
else
	sendToLog "jamfHelper: Defer count exceeded dialog..."
	# Create initial $jamfHelperARRAY[] settings for the dialog.
	jamfHelperARRAY=(-windowType utility -title "Software Updates Require Restart" -icon "$cachedICON" -iconSize "$jamfHelperIconSIZE" -button1 "$restartButtonTEXT" -defaultButton 1)

	# Body text for being past the count deadline. Note that any invisible characters (tabs and new line) will be "shown" in the jamfHelper dialog.
	jamfHelperARRAY+=(-description "You have deferred the maximum number of $countDEADLINE times.")

	# Start the dialog.
	openJamfHelper
	sendToLog "Status: User or display timeout accepted defer count exceeded deadline dialog."
fi
}

# Generate the $jamfHelperARRAY[] to display an interactive dialog with deferral options. This sets $choiceINSTALL and if $menuDeferSECONDS then also sets $defaultDeferSECONDS.
dialogAskForUpdate() {
# The soft deadline is always sooner, so it takes priority in the dialog.
[[ -n $hardDEADLINE ]] && dateDISPLAY="$hardDISPLAY"
[[ -n $softDEADLINE ]] && dateDISPLAY="$softDISPLAY"

if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
	sendToLog "IBM Notifier: Ask for restart or defer dialog..."
	# Create initial $ibmNotifierARRAY[] settings for the dialog.
	ibmNotifierARRAY=(-type popup -always_on_top -bar_title "Software Updates Require Restart" -icon_path "$cachedICON" -icon_width "$ibmNotifierIconSIZE" -icon_height "$ibmNotifierIconSIZE" -main_button_label "$deferButtonTEXT" -secondary_button_label "$restartButtonTEXT")

	# Body text variations based on deadline options.
	if [[ -n "$dateDISPLAY" ]] && [[ -n "$countDISPLAY" ]]; then # Show both date and maximum deferral count deadlines.
		ibmNotifierARRAY+=(-subtitle " Deferral available until deadline of: $dateDISPLAY.\n\n $countDISPLAY out of $countDEADLINE deferrals remain available.\n")
	elif [[ -n "$dateDISPLAY" ]]; then # Show only date deadline.
		ibmNotifierARRAY+=(-subtitle " Deferral available until deadline of: $dateDISPLAY.\n")
	elif [[ -n "$countDISPLAY" ]]; then # Show only maximum deferral count deadline.
		ibmNotifierARRAY+=(-subtitle " $countDISPLAY out of $countDEADLINE deferrals remain available.\n")
	else # Show no deadlines.
		ibmNotifierARRAY+=(-subtitle " No deadline date and unlimited deferrals.\n")
	fi

	# If needed, add the $menuDeferSECONDS option to the $ibmNotifierARRAY[].
	if [[ -n $menuDeferSECONDS ]]; then
		oldIFS="$IFS"; IFS=','
		read -r -a menuDeferSecondsARRAY <<< "$menuDeferSECONDS"
		read -r -a menuDeferDisplayARRAY <<< "$menuDeferSECONDS"
		for i in "${!menuDeferDisplayARRAY[@]}"; do
			if [[ ${menuDeferDisplayARRAY[i]} -lt 3600 ]]; then
				menuDeferDisplayARRAY[i]="$((menuDeferDisplayARRAY[i] / 60)) minutes"
			elif [[ ${menuDeferDisplayARRAY[i]} -eq 3600 ]]; then
				menuDeferDisplayARRAY[i]="1 hour"
			elif [[ ${menuDeferDisplayARRAY[i]} -gt 3600 ]] && [[ ${menuDeferDisplayARRAY[i]} -lt 7200 ]]; then
				menuDeferDisplayARRAY[i]="1 hour $((menuDeferDisplayARRAY[i] % 3600 / 60)) Minutes"
			elif [[ ${menuDeferDisplayARRAY[i]} -ge 7200 ]] && [[ ${menuDeferDisplayARRAY[i]} -lt 86400 ]] && [[ $((menuDeferDisplayARRAY[i] % 3600)) -eq 0 ]]; then
				menuDeferDisplayARRAY[i]="$((menuDeferDisplayARRAY[i] / 3600)) hours"
			elif [[ ${menuDeferDisplayARRAY[i]} -gt 7200 ]] && [[ ${menuDeferDisplayARRAY[i]} -lt 86400 ]] && [[ $((menuDeferDisplayARRAY[i] % 3600)) -ne 0 ]]; then
				menuDeferDisplayARRAY[i]="$((menuDeferDisplayARRAY[i] / 3600)) hours $((menuDeferDisplayARRAY[i] % 3600 / 60)) minutes"
			elif [[ ${menuDeferDisplayARRAY[i]} -eq 86400 ]]; then
				menuDeferDisplayARRAY[i]="1 day"
			fi
		done
		IFS=$'\n'
		menuDisplayTEXT="${menuDeferDisplayARRAY[*]}"
		IFS="$oldIFS"
		ibmNotifierARRAY+=(-accessory_view_type dropdown -accessory_view_payload "/title Defer software update for: /list $menuDisplayTEXT /selected 0")
	fi

	# Start the dialog.
	openIbmNotifier

	# The $dialogRETURN contains the IBM Notifier.app return code. If $menuDeferSECONDS was enabled then set $defaultDeferSECONDS.
	case "$dialogRETURN" in
		0)
			choiceINSTALL="FALSE"
			if [[ -n $menuDeferSECONDS ]]; then
				defaultDeferSECONDS="${menuDeferSecondsARRAY[$dialogRESULT]}"
				sendToLog "Status: User chose to defer update for $defaultDeferSECONDS seconds."
			else
				sendToLog "Status: User chose to defer update, using the default defer of $defaultDeferSECONDS seconds."
			fi
		;;
		255)
			choiceINSTALL="FALSE"
			if [[ -n $menuDeferSECONDS ]]; then
				defaultDeferSECONDS="${menuDeferSecondsARRAY[$dialogRESULT]}"
				sendToLog "Status: Display timeout automatically chose to defer update for $defaultDeferSECONDS seconds."
			else
				sendToLog "Status: Display timeout automatically chose to defer update, using the default defer of $defaultDeferSECONDS seconds."
			fi
		;;
		2)
			sendToLog "Status: User chose to restart now."
			choiceINSTALL="TRUE"
		;;
	esac
else
	sendToLog "jamfHelper: Ask for restart or defer dialog..."
	# Create initial $jamfHelperARRAY[] settings for the dialog.
	jamfHelperARRAY=(-windowType utility -title "Software Updates Require Restart" -icon "$cachedICON" -iconSize "$jamfHelperIconSIZE" -button1 "$deferButtonTEXT" -button2 "$restartButtonTEXT" -defaultButton 1 -cancelButton 2)

	# Body text variations based on deadline options. Note that any invisible characters (tabs and new line) will be "shown" in the jamfHelper dialog.
	if [[ -n "$dateDISPLAY" ]] && [[ -n "$countDISPLAY" ]]; then # Show both date and maximum deferral count deadlines.
		jamfHelperARRAY+=(-description " Deferral available until deadline of: $dateDISPLAY.

 $countDISPLAY out of $countDEADLINE deferrals remain available.")
	elif [[ -n "$dateDISPLAY" ]]; then # Show only date deadline.
		jamfHelperARRAY+=(-description " Deferral available until deadline of: $dateDISPLAY.")
	elif [[ -n "$countDISPLAY" ]]; then # Show only maximum deferral count deadline.
		jamfHelperARRAY+=(-description " $countDISPLAY out of $countDEADLINE deferrals remain available.")
	else # Show no deadlines.
		jamfHelperARRAY+=(-description " No deadline date and unlimited deferrals.")
	fi

	# If needed, add the $menuDeferSECONDS option to the $jamfHelperARRAY[].
	if [[ -n $menuDeferSECONDS ]]; then
		menuDeferSECONDS=$(echo "$menuDeferSECONDS" | sed 's/,/, /g')
		jamfHelperARRAY+=(-showDelayOptions "$menuDeferSECONDS")
	fi

	# Start the dialog.
	openJamfHelper

	# The $dialogRESULT contains the user's selection; "0" or "1" for deferral and "2" for restart. If $menuDeferSECONDS was enabled then set $defaultDeferSECONDS.
	case "$dialogRESULT" in
		0 | 1 | *1)
			choiceINSTALL="FALSE"
			if [[ -n $menuDeferSECONDS ]]; then
				defaultDeferSECONDS=$(echo "$dialogRESULT" | sed 's/.$//')
				sendToLog "Status: User or display timeout chose to defer update for $defaultDeferSECONDS seconds."
			else
				sendToLog "Status: User or display timeout chose to defer update, using the default defer of $defaultDeferSECONDS seconds."
			fi
		;;
		*2)
			sendToLog "Status: User chose to restart now."
			choiceINSTALL="TRUE"
		;;
	esac
fi
}

######## MAIN WORKFLOW ########

mainWorkflow(){
# Initial super workflow preparations.
checkRoot
setDefaults
superInstaller "$@"
getOptions "$@"
getPreferences
superStarter

# Now the actual update workflows starts.
if [[ "$macosARCH" == "arm64" ]]; then
	if [[ "$localCREDENTIAL" == "TRUE" ]]; then
		sendToLog "**** S.U.P.E.R.M.A.N. UPDATE APPLE SILICON ASU LOCAL ****"
	elif [[ "$superCREDENTIAL" == "TRUE" ]]; then
		sendToLog "**** S.U.P.E.R.M.A.N. UPDATE APPLE SILICON ASU SERVICE ****"
	elif [[ "$jamfCREDENTIAL" == "TRUE" ]]; then
		sendToLog "**** S.U.P.E.R.M.A.N. UPDATE APPLE SILICON MDM ****"
	else
		sendToLog "**** S.U.P.E.R.M.A.N. UPDATE APPLE SILICON REQUEST ONLY ****"
	fi
else
	sendToLog "**** S.U.P.E.R.M.A.N. UPDATE INTEL ****"
fi

# Use local Apple software update to check for updates. This sets $updatesRECOMMENDED, $updatesRESTART, and $downloadREQUIRED.
if [[ "$updateVALIDATE" == "TRUE" ]]; then # Checking after previous super system update, if successful, submit inventory to Jamf and check for Jamf Policies.
	sendToLog "Status: Detected update restart validation."
	checkAfterRestartUpdates
else # Default super workflow.
	updatesRECOMMENDED="FALSE"
	updatesRESTART="FALSE"
	if [[ "$testModeOPTION" == "TRUE" ]]; then # Test mode logic and logging.
		if [[ "$skipUpdatesOPTION" == "TRUE" ]]; then
			if [[ "$forceRestartOPTION" != "TRUE" ]] && [[ -z $policyTRIGGERS ]]; then
				sendToLog "Test Mode and Skip Update Mode: You need to also use \"--force-restart\" or \"--policy-triggers\" to simulate notificaiton and dialog workflows."
			fi
		else
			sendToLog "Test Mode: Simulating that restart required system updates are available."
			updatesRESTART="TRUE"
		fi
	elif [[ "$skipUpdatesOPTION" == "TRUE" ]]; then
		sendToLog "Skip Update Mode: Not checking for Apple software updates."
	else # Not $testModeOPTION, $skipUpdatesOPTION, or $updateVALIDATE, so it's time to check for new updates.
		checkAppleUpdates
	fi
fi

# If non-restart required "recommended" Apple software updates are available, then install all available recommended software updates.
if [[ "$updatesRECOMMENDED" == "TRUE" ]]; then
	installRecommendedUpdatesASU
	if [[ "$updateERROR" != "TRUE" ]]; then # If all recommended software updates are successful, check Apple softwareupdate again and continue workflow.
		sendToLog "Status: Completed install of all recommended software updates."
		checkAfterRecommendedUpdates
	else
		sendToLog "Exit: Apple softwareupdate failed to install all recommended updates, trying again in $defaultDeferSECONDS seconds."
		makeLaunchDaemonCalendar
	fi
fi

# If restart required system updates are available, then download and prepare all available.
if [[ "$updatesRESTART" == "TRUE" ]] && [[ "$testModeOPTION" != "TRUE" ]]; then # If not in test mode.
	if [[ "$downloadREQUIRED" == "TRUE" ]]; then # Updates have not been downloaded yet.
		if [[ "$localCREDENTIAL" == "TRUE" ]] || [[ "$superCREDENTIAL" == "TRUE" ]] || [[ "$macosARCH" == "i386" ]]; then
			downloadAllUpdatesASU
		elif [[ "$jamfCREDENTIAL" == "TRUE" ]]; then
			downloadAllUpdatesMDM
		else # Apple Silicon with no valid update credentials.
			sendToLog "Status: No valid Apple Silicon credentials, can not download updates."
		fi
	else # Updates were previously downloaded.
		sendToLog "Status: Previously downloaded ${#downloadedTITLES[@]} software udpate(s)."
		for i in "${!downloadedTITLES[@]}"; do
			sendToLog "Previous Download $((i + 1)): ${downloadedTITLES[i]}"
		done
	fi
fi

# This is the main logic for determining what to do in the case of available restart required system updates, $policyTRIGGERS, or the $forceRestartOPTION.
if [[ "$updatesRESTART" == "TRUE" ]] || [[ -n $policyTRIGGERS ]] || [[ "$forceRestartOPTION" == "TRUE" ]]; then
	checkCurrentUser # Checking the user again because it may have been quite a while since the workflow started (due to earlier installations and downloads).
	if [[ "$currentUSER" == "FALSE" ]]; then # A normal user is not logged in.
		installRestartSilent
	else # A normal user is currently logged in.
		checkDateDeadlines
		{ [[ "$deadlineSTATUS" != "HARD" ]] && [[ "$deadlineSTATUS" != "SOFT" ]]; } && checkDeferCountDeadline # Only need to check this if not past any hard or soft date deadlines.
		{ [[ "$deadlineSTATUS" == "FALSE" ]] || [[ "$deadlineSTATUS" != "FOCUS" ]]; } && checkUserFocus # Only need to check this if not past any deadlines.
		if [[ "$deadlineSTATUS" == "HARD" ]]; then # The Hard deadline has passed, similar to no logged in user but with a notification.
			installRestartMain
		elif [[ "$deadlineSTATUS" == "SOFT" ]]; then # The Soft deadline has passed.
			dialogSoftDeadline
			installRestartMain
		elif [[ "$deadlineSTATUS" == "COUNT" ]]; then # The defferal count deadline is exceeded.
			dialogCountDeadline
			installRestartMain
		elif [[ "$focusDEFER" == "TRUE" ]]; then # No deadlines have passed but a process has told the display to not sleep or the user has enabled Focus or Do Not Disturb.
			defaultDeferSECONDS="$focusDeferSECONDS"
			makeLaunchDaemonCalendar
		else # Logically, this is the only time the choice dialog is shown.
			dialogAskForUpdate
			if [[ "$choiceINSTALL" == "TRUE" ]]; then
				installRestartMain
			else
				makeLaunchDaemonCalendar
			fi
		fi
	fi
fi
}

mainWorkflow "$@"
rm -f "$superPIDFILE"
sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
exit 0
