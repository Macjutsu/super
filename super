#!/bin/bash
#
# S.U.P.E.R.M.A.N.
# Software Update Policy Enforcement (with) Recursive Messaging And Notification
#
# S.U.P.E.R.M.A.N. optimizes the macOS software update experience.
# by Kevin M. White
#
# Version 2.0rc1
# 2022/08/23
# https://github.com/Macjutsu/super
#
######## DEBUGGING STUFF ########
#
# The next line disables specific ShellCheck codes for the entire script. https://github.com/koalaman/shellcheck
# shellcheck disable=SC2001,SC2207
#
# Uncomment the next line for debugging code.
# set -x
#
######## FUNCTIONS - DOCUMENTATION ########

# Show usage documentation.
showUsage() {
echo "
  S.U.P.E.R.M.A.N.
  Software Update Policy Enforcement (with) Recursive Messaging And Notification

  Version 2.0rc1
  2022/08/23
  https://github.com/Macjutsu/super

  Usage:
  sudo ./super

  Deferment Timer Options:
  [--default-defer=seconds] [--focus-defer=seconds]
  [--menu-defer=seconds,seconds,etc...] [--recheck-defer=seconds]
  [--delete-deferrals]

  Deferment Count Deadline Options:
  [--focus-count=number] [--soft-count=number] [--hard-count=number]
  [--restart-counts] [--delete-counts]

  Deferment Days Deadline Options:
  [--focus-days=number] [--soft-days=number] [--hard-days=number]
  [--zero-day=YYYY-MM-DD:hh:mm] [--restart-days] [--delete-days]

  Deferment Date Deadline Options:
  [--focus-date=YYYY-MM-DD:hh:mm] [--soft-date=YYYY-MM-DD:hh:mm]
  [--hard-date=YYYY-MM-DD:hh:mm] [--delete-dates]

  Display Options:
  [--display-timeout=seconds] [--display-redraw=seconds]
  [--display-icon=/local/path or URL] [--icon-size-ibm=pixels]
  [--icon-size-jamf=pixels ] [--prefer-jamf] [--no-prefer-jamf]

  Software Update Credential Options:
  [--local-account=AccountName] [--local-password=Password]
  [--admin-account=AccountName] [--admin-password=Password]
  [--super-account=AccountName] [--super-password=Password]
  [--jamf-account=AccountName] [--jamf-password=Password]
  [--delete-accounts]

  Update & Restart Options:
  [--policy-triggers=PolicyTrigger,PolicyTrigger,etc...]
  [--skip-updates] [--no-skip-updates] [--force-restart] [--no-force-restart]

  Special Modes Options:
  [--test-mode ] [--no-test-mode ] [--test-mode-timeout=seconds]
  [--verbose-mode] [--no-verbose-mode] [--open-logs] [--reset-super] [--usage]
  [--help]

  * Managed preferences override local options via domain: com.macjutsu.super
  <key>DefaultDefer</key> <string>seconds</string>
  <key>FocusDefer</key> <string>seconds</string>
  <key>MenuDefer</key> <string>seconds,seconds,etc...</string>
  <key>RecheckDefer</key> <string>seconds</string>
  <key>FocusCount</key> <string>number</string>
  <key>SoftCount</key> <string>number</string>
  <key>HardCount</key> <string>number</string>
  <key>FocusDays</key> <string>number</string>
  <key>SoftDays</key> <string>number</string>
  <key>HardDays</key> <string>number</string>
  <key>ZeroDay</key> <string>YYYY-MM-DD:hh:mm</string>
  <key>FocusDate</key> <string>YYYY-MM-DD:hh:mm</string>
  <key>SoftDate</key> <string>YYYY-MM-DD:hh:mm</string>
  <key>HardDate</key> <string>YYYY-MM-DD:hh:mm</string>
  <key>DisplayTimeout</key> <string>seconds</string>
  <key>DisplayRedraw</key> <string>seconds</string>
  <key>DisplayIcon</key> <string>path</string>
  <key>IconSizeIbm</key> <string>number</string>
  <key>IconSizeJamf</key> <string>number</string>
  <key>PreferJamf</key> <true/> | <false/>
  <key>PolicyTriggers</key> <string>PolicyTrigger,PolicyTrigger,etc...</string>
  <key>SkipUpdates</key> <true/> | <false/>
  <key>ForceRestart</key> <true/> | <false/>
  <key>TestMode</key> <true/> | <false/>
  <key>TestModeTimeout</key> <string>seconds</string>
  <key>VerboseMode</key> <true/> | <false/>
"
}

# Show help documentation.
showHelp() {
echo "  Deferment Timer Options:

  --default-defer=seconds | --default-defer=X
  * Managed preference: <key>DefaultDefer</key> <string>seconds</string>
  The number of seconds to defer until the next update attempt if a user choses
  not to update restart. This deferral time is also used in cases when a
  required service is temporarily unavailable (for example, network or MDM
  connectivity issues). Using this option overrides the default deferral time
  which is set to 3600 seconds (1 hour) via the $defaultDeferSECONDS parameter.
  Times less than 120 seconds or more than 86400 seconds (1 day) are rounded
  accordingly. Also see the --menu-defer option to display a pop-up menu
  allowing the user to select an alternate deferral time. Finally, use a seconds
  value of X to return this option to its default setting.

  --focus-defer=seconds | --focus-defer=X
  * Managed preference: <key>FocusDefer</key> <string>seconds</string>
  The number of seconds to defer automatically if the system is in user-enabled
  Focus/Do Not Disturb or when a process has requested that the display not go
  to sleep (for example, during an active meeting). With this option you should
  also consider using --focus-count, --focus-days, or --focus-date to ensure
  users are offered a chance to defer before an update restart is automatically
  enforced via soft or hard deadlines. Times less than 120 seconds or more than
  86400 seconds (1 day) are rounded accordingly. Finally, use a seconds value of
  X to disable this option.

  --menu-defer=seconds,seconds,etc... | --menu-defer=X
  * Managed preference: <key>MenuDefer</key>
  <string>seconds,seconds,etc...</string>
  Display a deferral time pop-up menu in the non-deadline update restart dialog
  that allows the user to overide the --default-defer time. The time selections
  are specified with one or more number of seconds that are comma separated with
  no spaces. The first number in the list is the default selection for the menu,
  thus it is automatically selected if you also set --display-timeout. Times
  less than 120 seconds or more than 86400 seconds (1 day) are rounded
  accordingly. Finally, use a seconds value of X to disable this option.

  --recheck-defer=seconds | --recheck-defer=X
  * Managed preference: <key>RecheckDefer</key> <string>seconds</string>
  The number of seconds to defer if no software updates are found. Enabaling
  this option results in super acting as a permanent agent that checks for
  software updates on a regular basis. Logically, this option can not be used
  along with the --skip-updates option. Times less than 120 seconds or more than
  2628288 seconds (30 days) are rounded accordingly. Finally, use a seconds
  value of X to disable this option.

  --delete-deferrals
  Delete all locally set deferral options, resulting in only the default defer,
  which is set the via the $defaultDeferSECONDS parameter. Note that options
  specified via a managed preference still remain in effect.

  Deferment Count Deadline Options:

  --focus-count=number | --focus-count=X
  * Managed preference: <key>FocusCount</key> <string>number</string>
  The maximum number of automatic deferrals allowed if the system is in
  user-enabled Focus/Do Not Disturb or when a process has requested that the
  display not go to sleep (for example, during an active meeting). After this
  deadline the update restart dialogs always appear as normal. With this option
  you should also consider setting a specific --focus-defer time, otherwise the
  focus deferrment time is based on the --default-defer time. Note that if a
  user is always in a Focus mode, the --focus-count deadline must pass first
  before the --soft-count or --hard-count options are started. Additionally,
  other maximum days or date deadlines that have passed can overide this option.
  For testing, use a number value of 0 to simulate being past the maximum focus
  count deadline. Finally, use a number value of X to disable this option.

  --soft-count=number | --soft-count=X
  * Managed preference: <key>SoftCount</key> <string>number</string>
  The maximum number of user selected deferrals allowed before the soft deadline
  dialog. The soft deadline is an interactive update restart dialog indicating
  that no more deferrals are allowed. This option can not be used along with the
  --hard-count option as logically there can only be one behavior after passing
  the maximum number of user deferrals. Note that if this option is also used
  with the --focus-count option and the user is always in a Focus mode, then the
  --focus-count deadline must pas first before the --soft-count is started.
  Additionally, other maximum days or date deadlines that have passed can
  overide this option. For testing, use a number value of 0 to simulate being
  past the maximum soft count deadline. Finally, use a number value of X to
  disable this option.

  --hard-count=number | --hard-count=X
  * Managed preference: <key>HardCount</key> <string>number</string>
  The maximum number of user selected deferrals allowed before the computer
  automatically restarts for updates without asking the user for approval.
  However, the user is notified that a restart is pending. This option can not
  be used along with the --soft-count option as logicially there can only be one
  behavior after passing the maximum number of user deferrals. Note that if this
  option is also used with the --focus-count option and the user is always in a
  Focus mode, then the --focus-count deadline must pas first before the
  --hard-count is started. Additionally, other maximum days or date deadlines
  that have passed can overide this option. For testing, use a number value of 0
  to simulate being past the maximum hard count deadline. Finally, use a number
  value of X to disable this option.

  --restart-counts
  Restart all active defer counters, thus allowing for the maximum number of
  deferrals again.

  --delete-counts
  Delete all locally set maximum deferral deadlines, thus returning to the
  default of an unlimited number of deferrals. Note that options specified via
  a managed preference still remain in effect.

  Deferment Days Deadline Options:

  --focus-days=number | focus-days=X
  * Managed preference: <key>FocusDays</key> <string>number</string>
  The maximum number of days that automatic deferrals are allowed if the system
  is in user-enabled Focus/Do Not Disturb or when a process has requested that
  the display not go to sleep (for example, during an active meeting). After
  this deadline the update restart dialogs always appear. With this option you
  should also consider setting a specific --focus-defer time, otherwise the
  focus deferrment time is be based on the --default-defer time. Note that when
  used along with the --soft-days or --hard-days options, logically the
  --focus-days value must always be the least number of days. Additionally,
  other maximum deferral count or date deadlines that have passed can overide
  this option. For testing, use a day value of 0 or the --zero-day option to'
  simulate being past the maxiumum number of days deadline. Finally, use a days
  value of X to disable this option.

  --soft-days=number | --soft-days=X
  * Managed preference: <key>SoftDays</key> <string>number</string>
  The maximum number of days allowed before the soft deadline dialog. The soft
  deadline is an interactive update restart dialog indicating that no more
  deferrals are allowed. Note that when used along with the --focus-days or
  --hard-days options, logically the --soft-days value must always be more than
  the --focus-days value and less than the --hard-days value. Additionally,
  other maximum deferral count or date deadlines that have passed can overide
  this option. For testing, use a day value of 0 or the --zero-day option to
  simulate being past the maxiumum number of days deadline. Finally, use a days
  value of X to disable this option.

  --hard-days=number | --hard-days=X
  * Managed preference: <key>HardDays</key> <string>number</string>
  The maximum number of days allowed before the computer automatically restarts
  for updates without asking the user for approval. However, the user is
  notified that a restart is pending. Note that when used along with the
  --focus-days or --soft-days options, logically the --hard-days value must
  always be the most number of days. Additionally, other maximum deferral count
  or date deadlines that have passed can overide this option. For testing, use
  a day value of 0 or the --zero-day option to simulate being past the maxiumum
  number of days deadline. Finally, use a days value of X to disable this
  option.

  --zero-day=YYYY-MM-DD:hh:mm | --zero-day=X
  * Managed preference: <key>ZeroDay</key> <string>YYYY-MM-DD:hh:mm</string>
  Instead of having the days deadline counter automatically select the day zero
  date, this option sets a specific date and time as day zero. Note that you
  need to manually update this value every time you want to set a new day zero.
  Finally, use a date value of X to disable this option.

  --restart-days
  Restart the automatically selected zero day date and time, thus allowing for
  the maximum number of days allowed for deferral again. Note that using the
  --zero-day option overrides the automatically seleted zero day, and thus also
  overrides this restart option.

  --delete-days
  Delete all locally set maximum days deadlines and manual day zero date, thus
  returning to the default of an unlimited number of days allowed for deferrals.
  Note that options specified via a managed preference still remain in effect.

  Deferment Date Deadline Options:

  --focus-date=YYYY-MM-DD:hh:mm | --focus-date=X
  * Managed preference: <key>FocusDate</key> <string>YYYY-MM-DD:hh:mm</string>
  This is the last date and time when automatic deferrals are allowed if the
  system is in user-enabled Focus/Do Not Disturb or when a process has requested
  that the display not go to sleep (for example, during an active meeting).
  After this deadline the update restart dialogs always appear. At a minimum,
  you must always specify year-month-day. Hours are represented by a 24-hour
  clock, and any non-specified hours or minutes are rounded to 00. Also see the
  \$dateFORMAT and \$timeFORMAT parameters for date display options. Note that
  when used along with the --soft-date or --hard-date options, the --focus-date
  value must always be the earliest in time. Additionally, other maximum
  deferral count or maximum days deadlines that have passed can overide this
  option. For testing use a date and time value in the past to simulate being
  past this date deadline. Finally, use a date value of X to disable this
  option.

  --soft-date=YYYY-MM-DD:hh:mm | --soft-date=X
  * Managed preference: <key>SoftDate</key> <string>YYYY-MM-DD:hh:mm</string>
  If this date and time have passed, an interactive update restart dialog
  appears indicating that no more user deferrals are allowed. At a minimum, you
  must always specify year-month-day. Hours are represented by a 24-hour clock,
  and any non-specified hours or minutes are rounded to 00. Also see the
  \$dateFORMAT and \$timeFORMAT parameters for date display options. Note that
  when used along with the --focus-date or --hard-date options, the --soft-date
  value must always be after the --focus-date in time but before the --hard-date
  in time. Additionally, other maximum deferral count or maximum days deadlines
  that have passed can overide this option. For testing use a date and time
  value in the past to simulate being past this date deadline. Finally, use a
  date value of X to disable this option.

  --hard-date=YYYY-MM-DD:hh:mm | --hard-date=X
  * Managed preference: <key>HardDate</key> <string>YYYY-MM-DD:hh:mm</string>
  If this date has passed, the computer restarts and udpates without asking the
  user for approval. However, the user is notified that a restart is pending. At
  a minimum, you must always specify year-month-day. Hours are represented by a
  24-hour clock, and any non-specified hours or minutes are rounded to 00. Also
  see the \$dateFORMAT and \$timeFORMAT parameters for date display options.
  Note that when used along with the --focus-date or --soft-date options, the
  --hard-date value must always be the latest in time. Additionally, other
  maximum deferral count or maximum days deadlines that have passed can overide
  this option. For testing use a date and time value in the past to simulate
  being past this date deadline. Finally, use a date value of X to disable this
  option.

  --delete-dates
  Delete all locally set date deadlines, thus returning to the default of no
  date deadline for deferrals. Note that options specified via a managed
  preference still remain in effect.

  Display Options:

  --display-timeout=seconds | --display-timeout=X
  * Managed preference: <key>DisplayTimeout</key> <string>seconds</string>
  Sets an automatic timeout for interactive update restart dialogs in seconds.
  The countdown of the timeout is displayed in the update restart dialog. Use
  this option with caution, as once the timeout expires, the restart button is
  automatically selected for any dialogs showing that a deadline has passed.
  Finally, use a seconds value of X to disable this option.

  --display-redraw=seconds | --display-redraw=X
  * Managed preference: <key>DisplayRedraw</key> <string>seconds</string>
  If a user ignores a notification or dialog (for example, it's moved offscreen)
  this specifies the number of seconds to wait before closing and then reopening
  the notification or dialog, thus redrawing the notification or dialog back in
  it's original open possition. Avoid low numbers as re-centering results in a
  flash of the notification or dialog. Also note that when --display-redraw
  is used along with --display-timeout, timeout seconds that are too low are
  automatically corrected to equal three times the redraw seconds. This results
  in the notification or dialog redrawing twice before the timeout automatically
  selects the Restart button. Finally, use a seconds value of X to disable
  this option.

  --display-icon=/local/path or URL | --display-icon=X
  * Managed preference: <key>DisplayIcon</key> <string>path</string>
  Local path or http(s) URL to a file that is the picture to display in
  notifications or dialogs. If there is a space in the local path, you must use
  quotes or the escape ( \ ) character. Both local file paths and http(s) URLs
  are be copied to the path at \$cachedICON. If the path or URL can not be found
  or this option is not set, then the file at the \$defaultICON path is used.
  Finally, use a path value of X to return this option to its default.

  --icon-size-ibm=pixels | --icon-size-ibm=X
  * Managed preference: <key>IconSizeIbm</key> <string>number</string>
  Number of pixels for the --display-icon in IBM Notifier dialogs. Using this
  option overrides the default IBM Notifier icon size which is set to 96 pixels
  via the $ibmNotifierIconSIZE parameter. Any size less than 32 pixles or more
  than 150 pixles is rounded accordingly. Finally, use a pixels value of X to
  return this option to its default.

  --icon-size-jamf=pixels | --icon-size-jamf=X
  * Managed preference: <key>IconSizeJamf</key> <string>number</string>
  Number of pixels for the --display-icon in jamfHelper dialogs and
  notifications. Using this option overrides the default jamfHelper icon size
  which is set to 96 pixels via the $jamfHelperIconSIZE parameter. Any size less
  than 32 pixles or more than 256 pixles is rounded accordingly. Finally, use a
  pixels value of X to return this option to its default.

  -J | --prefer-jamf
  * Managed preference: <key>PreferJamf</key> <true/>
  Prefer jamfHelpler over IBM Notifier.app for user interactions.

  -j | --no-prefer-jamf
  * Managed preference: <key>PreferJamf</key> <false/>
  Disable preferring jamfHelpler over IBM Notifier.app for user interactions.

  Apple Silicon Credential Options:

  --local-account=AccountName
  Apple Silicon only. A local (standard or admin) user account name with volume
  ownership privileges. You must also provide the --local-password for this
  account. The account you provide is used to authenticate the Apple
  softwareupdate command.

  --local-password=Password
  Apple Silicon only. The local user password to authenticate the account
  specified by --local-account. Note that these credentials are stored in the
  System keychain and can be viewed by any other admin user.

  --admin-account=AccountName
  Apple Silicon only. A local admin user account name with volume ownership
  privileges. You must also provide the --admin-password for this account. The
  account you provide is used to create a new local super service account that
  authenticatates the Apple softwareupdate command.

  --admin-password=Password
  Apple Silicon only. The local admin user password to authenticate the account
  specified by --admin-account. These credentials are never saved to disk.

  --super-account=AccountName
  Apple Silicon only. Specify a unique account name for the local super service
  account. You must also provide --admin-account credentials for modifying the
  super service account. Using this option overrides the default service account
  name super and full name Super Update Service.

  --super-password=Password
  Apple Silicon only. Specify a unique password for the local super service
  account. You must also provide --admin-account credentials for modifying the
  super service account. Using this option overrides the default service account
  password which is randomized via the uuidgen command. Note that these
  credentials are stored in the System keychain and can be viewed by any other
  admin user.

  --jamf-account=AccountName
  A Jamf Pro user account that can authorize macOS software update MDM commands.
  You must also provide the --jamf-password for this account. The default Jamf
  Pro privileges required for this account are; Computers Create, Compuers Read,
  and Send Computer Remote Command to Download and Install macOS Update. You can
  avoid the Compuers Read requirement by providing a Configuratino Profile with
  the following managed preference: <key>JamfProID</key><string>$JSSID</string>.
  Note that only computers with macOS 11.5 or later can reliably update via MDM
  commands. As such, on older systems valid credentials will be saved but the
  MDM method will not be attempted until the system is at least macOS 11.5.
  Also, on Apple Silicon, valid local update credentials (local user account or
  super service account) take precedence over the the MDM update workflow.

  --jamf-password=Password
  The Jamf Pro user account password to authenticate the account specified by
  --jamf-account. Note that these credentials are stored in the System keychain
  and can be viewed by any other local admin user.

  -D | --delete-accounts
  Delete all previously saved Apple Silicon update credentials. This includes
  deleting saved local account credentials, and any automatically generated
  super serivce account and saved credentials, and saved Jamf Pro API account
  credentials. Additionally you can use the --reset-super option to delete any
  locally saved options.

  Update/Restart Options:

  --policy-triggers=PolicyTrigger,PolicyTrigger,etc... | --policy-triggers=X
  * Managed preference: <key>PolicyTriggers</key>
  <string>PolicyTrigger,PolicyTrigger,etc...</string>
  One or more Jamf Pro Policy Triggers that are comma separated with no spaces.
  If there is a space in any of the Policy Trigger names, you must use quotes or
  the escape ( \ ) character. The super workflow runs this list of Jamf Pro
  Policy Triggers before any restart required system updates are installed. As a
  default behavior, these Jamf Pro Policies only run if the system is going to
  restart for updates. However, this option can be used along with the
  --skip-updates option so even when there are no updates available you can
  still take advantage of dialogs, notifications, deferrals, and deadline
  workflows. Note that if you specify the --skip-updates option, the super
  workflow does not restart the computer unless you also speicfy the
  --force-restart option. This is by design as it allows one of your Jamf Pro
  Policies to restart the computer instead of the super workflow. Finally, use a
  value of X to disable this option.

  -S | --skip-updates
  * Managed preference: <key>SkipUpdates</key> <true/>
  Skip Apple software updates, even if they are available. This option can also
  be used along with --policy-triggers and/or --force-restart to take advantage
  of dialogs, notifications, deferrals, and deadline workflows. Alternatley, use
  this option along with --reset-super to delete any local super preferences,
  kill any existing super processes, and delete the super LaunchDaemon.
  Finally, this option can not be used along with the --recheck-defer option.

  -s | --no-skip-updates
  * Managed preference: <key>SkipUpdates</key> <false/>
  Resume checking Apple software updates in super workflows.

  -F | --force-restart
  * Managed preference: <key>ForceRestart</key> <true/>
  The super workflow forces a restart even if Apple software updates do not
  require it. Useful when used along with --test-mode or if no restart required
  system updates are available but you still want to force a restart.

  -f | --no-force-restart
  * Managed preference: <key>ForceRestart</key> <false/>
  Disable forced restart in super workflows.

  Special Modes Options:

  -T | --test-mode
  * Managed preference: <key>TestMode</key> <true/>
  Mode to validate parameters, credentials, dialogs, notifications, deferrals,
  and deadline workflows. This mode does not attempt any Apple software updates,
  Jamf Polices, or restarts. Thus, allowing for quick iteration testing.

  -t | --no-test-mode
  * Managed preference: <key>TestMode</key> <false/>
  Disable test mode in super workflows.

  --test-mode-timeout=seconds | --test-mode-timeout=X
  * Managed preference: <key>TestModeTimeout</key> <string>seconds</string>
  The amount of time in seconds to leave test notifications and dialogs open
  before moving on in the workflow. Using this option overrides the default test
  mode timeout which is set to 10 seconds via the \$testModeTIMEOUT default
  parameter. Finally, use a seconds value of X to return this option to its
  default.

  -V | --verbose-mode
  * Managed preference: <key>VerboseMode</key> <true/>
  Mode to generate additional log output. Note that with this mode passwords
  are visible in Terminal but are not saved to \$superLOG.

  -v | --no-verbose-mode
  * Managed preference: <key>VerboseMode</key> <false/>
  Disable test mode in super workflows.

  -o | -O | --open-logs
  As long as someone is logged into the GUI this option opens the \$superLOG,
  \$updateLOG, and if needed the \$mdmLOG in Console.app.

  -x | -X | --reset-super
  Delete all locally saved options, thus returning super to it's defaults. Use
  this option along with --delete-accounts to delete any saved Apple Silicon
  update credentials. Additionally, you can use the --skip-updates option to
  also kill any existing super processes and delete any lingering super
  LaunchDaemons. Finally, note that options specified via a managed preference
  still remain in effect.

  -u | -U | --usage
  Display basic usage documentation.

  -h | -H | --help
  Display this full help documentation.

  [Unrecognized Options]
  Display usage and specific unrecognized option errors.
"
}

######## FUNCTIONS - PARAMETERS ########

# Set default parameters that are used throughout the script.
setDefaults(){
# Installation folder:
superFOLDER="/Library/Management/super"

# Symbolic link in default path for super.
superLINK="/usr/local/bin/super"

# Path to a PID file:
superPIDFILE="/var/run/super.pid"

# Path to a local property list file:
superPLIST="$superFOLDER/com.macjutsu.super" # No trailing ".plist"

# Path to a managed property list file:
superMANAGEDPLIST="/Library/Managed Preferences/com.macjutsu.super" # No trailing ".plist"

# Path to main workflow log file:
superLOG="$superFOLDER/super.log"

# Path to filtered MDM progress log file:
mdmLOG="$superFOLDER/mdm.log"

# Path to filtered software update progress log file:
updateLOG="$superFOLDER/update.log"

# This is the name for the LaunchDaemon.
launchDaemonNAME="com.macjutsu.super" # No trailing ".plist"

# Path to the jamf binary:
jamfBINARY="/usr/local/bin/jamf"

# Path to the jamfHELPER binary:
jamfHELPER="/Library/Application Support/JAMF/bin/jamfHelper.app/Contents/MacOS/jamfHelper"

# URL to the IBM Notifier.app download:
ibmNotifierURL="https://github.com/IBM/mac-ibm-notifications/releases/download/v-2.8.0-b-87/IBM.Notifier.zip"

# Target version for IBM Notifier.app:
ibmNotifierVERSION="2.8.0"

# Path to the local IBM Notifier.app:
ibmNotifierAPP="$superFOLDER/IBM Notifier.app"

# Path to the local IBM Notifier.app binary:
ibmNotifierBINARY="$ibmNotifierAPP/Contents/MacOS/IBM Notifier"

# The default number of seconds to defer if a user choses not to restart or a required service is temporarily unavailable.
defaultDeferSECONDS=3600

# Path to for the local cached display icon:
cachedICON="$superFOLDER/icon.png"

# The default icon in the if no $displayIconOPTION is specified or found.
defaultICON="/System/Library/PreferencePanes/SoftwareUpdate.prefPane/Contents/Resources/SoftwareUpdate.icns"

# Default icon size for IBM Notifier.app.
ibmNotifierIconSIZE=96

# Default icon size for jamfHelper.
jamfHelperIconSIZE=96

# Deadline date display format.
dateFORMAT="+%B %d, %Y" # Formatting options can be found in the man page for the date command.

# Deadline time display format.
timeFORMAT="+%l:%M %p" # Formatting options can be found in the man page for the date command.

# The default amount of time in seconds to leave test notifications and dialogs open before moving on in the workflow.
testModeTIMEOUT=10

# These parameters identify the macOS version and architecture.
macosMAJOR=$(sw_vers -productVersion | cut -d'.' -f1) # Expected output: 10, 11, 12
macosMINOR=$(sw_vers -productVersion | cut -d'.' -f2) # Expected output: 14, 15, 06, 01
macosVERSION=${macosMAJOR}$(printf "%02d" "$macosMINOR") # Expected output: 1014, 1015, 1106, 1200
macosARCH=$(arch) # Expected output: i386, arm64
}

# Collect input options and set associated parameters.
getOptions() {
# If super is running via Jamf Policy installation then the first 3 input parameters are skipped.
if [[ $1 == "/" ]]; then
	shift 3
	jamfPARENT="TRUE"
fi

# This is a standard while/case loop to collect all the input parameters.
while [[ -n $1 ]]; do
	case "$1" in
		--default-defer* )
			defaultDeferOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--focus-defer* )
			focusDeferOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--menu-defer* )
			menuDeferOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--recheck-defer* )
			recheckDeferOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--delete-deferrals )
			deleteDEFFERALS="TRUE"
		;;
		--focus-count* )
			focusCountOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--soft-count* )
			softCountOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--hard-count* )
			hardCountOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--restart-counts )
			restartCOUNTS="TRUE"
		;;
		--delete-counts )
			deleteCOUNTS="TRUE"
		;;
		--focus-days* )
			focusDaysOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--soft-days* )
			softDaysOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--hard-days* )
			hardDaysOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--zero-day* )
			zeroDayOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--restart-days )
			restartDAYS="TRUE"
		;;
		--delete-days )
			deleteDAYS="TRUE"
		;;
		--focus-date* )
			focusDateOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--soft-date* )
			softDateOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--hard-date* )
			hardDateOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--delete-dates )
			deleteDATES="TRUE"
		;;
		--display-timeout* )
			displayTimeoutOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--display-redraw* )
			displayRedrawOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--display-icon* )
			displayIconOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--icon-size-ibm* )
			iconSizeIbmOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--icon-size-jamf* )
			iconSizeJamfOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		-J|--prefer-jamf )
			preferJamfOPTION="TRUE"
		;;
		-j|--no-prefer-jamf )
			preferJamfOPTION="FALSE"
		;;
		--local-account* )
			localOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--local-password* )
			localPASSWORD=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--admin-account* )
			adminACCOUNT=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--admin-password* )
			adminPASSWORD=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--super-account* )
			superOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--super-password* )
			superPASSWORD=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--jamf-account* )
			jamfOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		--jamf-password* )
			jamfPASSWORD=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		-D|--delete-accounts )
			deleteACCOUNTS="TRUE"
		;;
		--policy-triggers* )
			policyTriggersOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		-S|--skip-updates )
			skipUpdatesOPTION="TRUE"
		;;
		-s|--no-skip-updates )
			skipUpdatesOPTION="FALSE"
		;;
		-F|--force-restart )
			forceRestartOPTION="TRUE"
		;;
		-f|--no-force-restart )
			forceRestartOPTION="FALSE"
		;;
		-T|--test-mode )
			testModeOPTION="TRUE"
		;;
		-t|--no-test-mode )
			testModeOPTION="FALSE"
		;;
		--test-mode-timeout* )
			testModeTimeoutOPTION=$(echo "$1" | sed -e 's|^[^=]*=||g')
		;;
		-V|--verbose-mode )
			verboseModeOPTION="TRUE"
		;;
		-v|--no-verbose-mode )
			verboseModeOPTION="FALSE"
		;;
		-o|-O|--open-logs )
			openLOGS="TRUE"
		;;
		-x|-X|--reset-super )
			resetLocalPROPERTIES="TRUE"
		;;
		-u|-U|--usage )
			showUsage
			echo -e "  Use --help to view detailed usage information.\n"
			exit 0
		;;
		-h|-H|--help )
			showUsage
			showHelp
			exit 0
		;;
		*)
			unrecognizedOptionsARRAY+=("$1")
		;;
	esac
	shift
done

# Error log any unrecognized options.
if [[ -n ${unrecognizedOptionsARRAY[*]} ]]; then
	sendToLog  "Error: Unrecognzied Options: ${unrecognizedOptionsARRAY[*]}"; parameterERROR="TRUE"
	[[ "$jamfPARENT" == "TRUE" ]] && sendToLog  "Error: Note that each Jamf Pro Policy Parameter can only contain a single option."
	showUsage
	sendToLog  "Error: Unrecognzied Options: ${unrecognizedOptionsARRAY[*]}" # Logging twice for improved readability.
	[[ "$jamfPARENT" == "TRUE" ]] && sendToLog  "Error: Note that each Jamf Pro Policy Parameter can only contain a single option."
fi
}

# Collect any parameters stored in $superMANAGEDPLIST and/or $superPLIST.
getPreferences() {
# If $deleteDEFFERALS is specified, then delete all local deferral preferences.
if [[ "$deleteDEFFERALS" == "TRUE" ]]; then
	sendToLog "Starter: Deleting all local deferral preferences."
	defaults delete "$superPLIST" DefaultDefer 2> /dev/null
	defaults delete "$superPLIST" FocusDefer 2> /dev/null
	defaults delete "$superPLIST" MenuDefer 2> /dev/null
	defaults delete "$superPLIST" RecheckDefer 2> /dev/null
fi

# If $deleteCOUNTS is specified, then delete all local maximum deferral count deadline preferences.
if [[ "$deleteCOUNTS" == "TRUE" ]]; then
	sendToLog "Starter: Deleting all local maximum deferral count deadline preferences."
	defaults delete "$superPLIST" FocusCount 2> /dev/null
	defaults delete "$superPLIST" SoftCount 2> /dev/null
	defaults delete "$superPLIST" HardCount 2> /dev/null
fi

# If $deleteDAYS is specified, then delete all local maximum day deadline preferences.
if [[ "$deleteDAYS" == "TRUE" ]]; then
	sendToLog "Starter: Deleting all local maximum day deadline preferences."
	defaults delete "$superPLIST" FocusDays 2> /dev/null
	defaults delete "$superPLIST" SoftDays 2> /dev/null
	defaults delete "$superPLIST" HardDays 2> /dev/null
	defaults delete "$superPLIST" ZeroDay 2> /dev/null
fi

# If $deleteDATES is specified, then delete all local date deadline preferences.
if [[ "$deleteDATES" == "TRUE" ]]; then
	sendToLog "Starter: Deleting all local date deadline preferences."
	defaults delete "$superPLIST" FocusDate 2> /dev/null
	defaults delete "$superPLIST" SoftDate 2> /dev/null
	defaults delete "$superPLIST" HardDate 2> /dev/null
fi

# If $resetLocalPROPERTIES is specified, then delete all local non-account preferences.
if [[ "$resetLocalPROPERTIES" == "TRUE" ]]; then
	sendToLog "Starter: Deleting all local non-account preferences."
	defaults delete "$superPLIST" DefaultDefer 2> /dev/null
	defaults delete "$superPLIST" FocusDefer 2> /dev/null
	defaults delete "$superPLIST" MenuDefer 2> /dev/null
	defaults delete "$superPLIST" RecheckDefer 2> /dev/null
	defaults delete "$superPLIST" FocusCount 2> /dev/null
	defaults delete "$superPLIST" SoftCount 2> /dev/null
	defaults delete "$superPLIST" HardCount 2> /dev/null
	defaults delete "$superPLIST" FocusDays 2> /dev/null
	defaults delete "$superPLIST" SoftDays 2> /dev/null
	defaults delete "$superPLIST" HardDays 2> /dev/null
	defaults delete "$superPLIST" ZeroDay 2> /dev/null
	defaults delete "$superPLIST" FocusDate 2> /dev/null
	defaults delete "$superPLIST" SoftDate 2> /dev/null
	defaults delete "$superPLIST" HardDate 2> /dev/null
	defaults delete "$superPLIST" DisplayTimeout 2> /dev/null
	defaults delete "$superPLIST" DisplayRedraw 2> /dev/null
	defaults delete "$superPLIST" DisplayIcon 2> /dev/null
	rm -r "$cachedICON" > /dev/null 2>&1
	defaults delete "$superPLIST" IconSizeIbm 2> /dev/null
	defaults delete "$superPLIST" IconSizeJamf 2> /dev/null
	defaults delete "$superPLIST" PreferJamf 2> /dev/null
	defaults delete "$superPLIST" PolicyTriggers 2> /dev/null
	defaults delete "$superPLIST" SkipUpdates 2> /dev/null
	defaults delete "$superPLIST" ForceRestart 2> /dev/null
	defaults delete "$superPLIST" TestMode 2> /dev/null
	defaults delete "$superPLIST" TestModeTimeout 2> /dev/null
	defaults delete "$superPLIST" VerboseMode 2> /dev/null
fi

# Collect any managed preferences from $superMANAGEDPLIST.
if [[ -f "$superMANAGEDPLIST.plist" ]]; then
	jamfProIdMANAGED=$(defaults read "$superMANAGEDPLIST" JamfProID 2> /dev/null)
	defaultDeferMANAGED=$(defaults read "$superMANAGEDPLIST" DefaultDefer 2> /dev/null)
	focusDeferMANAGED=$(defaults read "$superMANAGEDPLIST" FocusDefer 2> /dev/null)
	menuDeferMANAGED=$(defaults read "$superMANAGEDPLIST" MenuDefer 2> /dev/null)
	recheckDeferMANAGED=$(defaults read "$superMANAGEDPLIST" RecheckDefer 2> /dev/null)
	focusCountMANAGED=$(defaults read "$superMANAGEDPLIST" FocusCount 2> /dev/null)
	softCountMANAGED=$(defaults read "$superMANAGEDPLIST" SoftCount 2> /dev/null)
	hardCountMANAGED=$(defaults read "$superMANAGEDPLIST" HardCount 2> /dev/null)
	focusDaysMANAGED=$(defaults read "$superMANAGEDPLIST" FocusDays 2> /dev/null)
	softDaysMANAGED=$(defaults read "$superMANAGEDPLIST" SoftDays 2> /dev/null)
	hardDaysMANAGED=$(defaults read "$superMANAGEDPLIST" HardDays 2> /dev/null)
	zeroDayMANAGED=$(defaults read "$superMANAGEDPLIST" ZeroDay 2> /dev/null)
	focusDateMANAGED=$(defaults read "$superMANAGEDPLIST" FocusDate 2> /dev/null)
	softDateMANAGED=$(defaults read "$superMANAGEDPLIST" SoftDate 2> /dev/null)
	hardDateMANAGED=$(defaults read "$superMANAGEDPLIST" HardDate 2> /dev/null)
	displayTimeoutMANAGED=$(defaults read "$superMANAGEDPLIST" DisplayTimeout 2> /dev/null)
	displayRedrawMANAGED=$(defaults read "$superMANAGEDPLIST" DisplayRedraw 2> /dev/null)
	displayIconMANAGED=$(defaults read "$superMANAGEDPLIST" DisplayIcon 2> /dev/null)
	iconSizeIbmMANAGED=$(defaults read "$superMANAGEDPLIST" IconSizeIbm 2> /dev/null)
	iconSizeJamfMANAGED=$(defaults read "$superMANAGEDPLIST" IconSizeJamf 2> /dev/null)
	preferJamfMANAGED=$(defaults read "$superMANAGEDPLIST" PreferJamf 2> /dev/null)
	policyTriggersMANAGED=$(defaults read "$superMANAGEDPLIST" PolicyTriggers 2> /dev/null)
	skipUpdatesMANAGED=$(defaults read "$superMANAGEDPLIST" SkipUpdates 2> /dev/null)
	forceRestartMANAGED=$(defaults read "$superMANAGEDPLIST" ForceRestart 2> /dev/null)
	testModeMANAGED=$(defaults read "$superMANAGEDPLIST" TestMode 2> /dev/null)
	testModeTimeoutMANAGED=$(defaults read "$superMANAGEDPLIST" TestModeTimeout 2> /dev/null)
	verboseModeMANAGED=$(defaults read "$superMANAGEDPLIST" VerboseMode 2> /dev/null)
fi

# Collect any local preferences from $superPLIST.
if [[ -f "$superPLIST.plist" ]]; then
	defaultDeferPROPERTY=$(defaults read "$superPLIST" DefaultDefer 2> /dev/null)
	focusDeferPROPERTY=$(defaults read "$superPLIST" FocusDefer 2> /dev/null)
	menuDeferPROPERTY=$(defaults read "$superPLIST" MenuDefer 2> /dev/null)
	recheckDeferPROPERTY=$(defaults read "$superPLIST" RecheckDefer 2> /dev/null)
	focusCountPROPERTY=$(defaults read "$superPLIST" FocusCount 2> /dev/null)
	softCountPROPERTY=$(defaults read "$superPLIST" SoftCount 2> /dev/null)
	hardCountPROPERTY=$(defaults read "$superPLIST" HardCount 2> /dev/null)
	focusDaysPROPERTY=$(defaults read "$superPLIST" FocusDays 2> /dev/null)
	softDaysPROPERTY=$(defaults read "$superPLIST" SoftDays 2> /dev/null)
	hardDaysPROPERTY=$(defaults read "$superPLIST" HardDays 2> /dev/null)
	zeroDayPROPERTY=$(defaults read "$superPLIST" ZeroDay 2> /dev/null)
	focusDatePROPERTY=$(defaults read "$superPLIST" FocusDate 2> /dev/null)
	softDatePROPERTY=$(defaults read "$superPLIST" SoftDate 2> /dev/null)
	hardDatePROPERTY=$(defaults read "$superPLIST" HardDate 2> /dev/null)
	displayTimeoutPROPERTY=$(defaults read "$superPLIST" DisplayTimeout 2> /dev/null)
	displayRedrawPROPERTY=$(defaults read "$superPLIST" DisplayRedraw 2> /dev/null)
	iconSizeIbmPROPERTY=$(defaults read "$superPLIST" IconSizeIbm 2> /dev/null)
	iconSizeJamfPROPERTY=$(defaults read "$superPLIST" IconSizeJamf 2> /dev/null)
	preferJamfPROPERTY=$(defaults read "$superPLIST" PreferJamf 2> /dev/null)
	policyTriggersPROPERTY=$(defaults read "$superPLIST" PolicyTriggers 2> /dev/null)
	skipUpdatesPROPERTY=$(defaults read "$superPLIST" SkipUpdates 2> /dev/null)
	forceRestartPROPERTY=$(defaults read "$superPLIST" ForceRestart 2> /dev/null)
	testModePROPERTY=$(defaults read "$superPLIST" TestMode 2> /dev/null)
	testModeTimeoutPROPERTY=$(defaults read "$superPLIST" TestModeTimeout 2> /dev/null)
	verboseModePROPERTY=$(defaults read "$superPLIST" VerboseMode 2> /dev/null)
fi

# This logic ensures the priority order of managed preference overrides the new input option which overrides the saved local preference.
if [[ -n $defaultDeferMANAGED ]]; then
	defaultDeferOPTION="$defaultDeferMANAGED"
elif [[ -z $defaultDeferOPTION ]] && [[ -n $defaultDeferPROPERTY ]]; then
	defaultDeferOPTION="$defaultDeferPROPERTY"
fi
if [[ -n $focusDeferMANAGED ]]; then
	focusDeferOPTION="$focusDeferMANAGED"
elif [[ -z $focusDeferOPTION ]] && [[ -n $focusDeferPROPERTY ]]; then
	focusDeferOPTION="$focusDeferPROPERTY"
fi
if [[ -n $menuDeferMANAGED ]]; then
	menuDeferOPTION="$menuDeferMANAGED"
elif [[ -z $menuDeferOPTION ]] && [[ -n $menuDeferPROPERTY ]]; then
	menuDeferOPTION="$menuDeferPROPERTY"
fi
if [[ -n $recheckDeferMANAGED ]]; then
	recheckDeferOPTION="$recheckDeferMANAGED"
elif [[ -z $recheckDeferOPTION ]] && [[ -n $recheckDeferPROPERTY ]]; then
	recheckDeferOPTION="$recheckDeferPROPERTY"
fi
if [[ -n $focusCountMANAGED ]]; then
	focusCountOPTION="$focusCountMANAGED"
elif [[ -z $focusCountOPTION ]] && [[ -n $focusCountPROPERTY ]]; then
	focusCountOPTION="$focusCountPROPERTY"
fi
if [[ -n $softCountMANAGED ]]; then
	softCountOPTION="$softCountMANAGED"
elif [[ -z $softCountOPTION ]] && [[ -n $softCountPROPERTY ]]; then
	softCountOPTION="$softCountPROPERTY"
fi
if [[ -n $hardCountMANAGED ]]; then
	hardCountOPTION="$hardCountMANAGED"
elif [[ -z $hardCountOPTION ]] && [[ -n $hardCountPROPERTY ]]; then
	hardCountOPTION="$hardCountPROPERTY"
fi
if [[ -n $focusDaysMANAGED ]]; then
	focusDaysOPTION="$focusDaysMANAGED"
elif [[ -z $focusDaysOPTION ]] && [[ -n $focusDaysPROPERTY ]]; then
	focusDaysOPTION="$focusDaysPROPERTY"
fi
if [[ -n $softDaysMANAGED ]]; then
	softDaysOPTION="$softDaysMANAGED"
elif [[ -z $softDaysOPTION ]] && [[ -n $softDaysPROPERTY ]]; then
	softDaysOPTION="$softDaysPROPERTY"
fi
if [[ -n $hardDaysMANAGED ]]; then
	hardDaysOPTION="$hardDaysMANAGED"
elif [[ -z $hardDaysOPTION ]] && [[ -n $hardDaysPROPERTY ]]; then
	hardDaysOPTION="$hardDaysPROPERTY"
fi
if [[ -n $zeroDayMANAGED ]]; then
	zeroDayOPTION="$zeroDayMANAGED"
elif [[ -z $zeroDayOPTION ]] && [[ -n $zeroDayPROPERTY ]]; then
	zeroDayOPTION="$zeroDayPROPERTY"
fi
if [[ -n $focusDateMANAGED ]]; then
	focusDateOPTION="$focusDateMANAGED"
elif [[ -z $focusDateOPTION ]] && [[ -n $focusDatePROPERTY ]]; then
	focusDateOPTION="$focusDatePROPERTY"
fi
if [[ -n $softDateMANAGED ]]; then
	softDateOPTION="$softDateMANAGED"
elif [[ -z $softDateOPTION ]] && [[ -n $softDatePROPERTY ]]; then
	softDateOPTION="$softDatePROPERTY"
fi
if [[ -n $hardDateMANAGED ]]; then
	hardDateOPTION="$hardDateMANAGED"
elif [[ -z $hardDateOPTION ]] && [[ -n $hardDatePROPERTY ]]; then
	hardDateOPTION="$hardDatePROPERTY"
fi
if [[ -n $displayTimeoutMANAGED ]]; then
	displayTimeoutOPTION="$displayTimeoutMANAGED"
elif [[ -z $displayTimeoutOPTION ]] && [[ -n $displayTimeoutPROPERTY ]]; then
	displayTimeoutOPTION="$displayTimeoutPROPERTY"
fi
if [[ -n $displayRedrawMANAGED ]]; then
	displayRedrawOPTION="$displayRedrawMANAGED"
elif [[ -z $displayRedrawOPTION ]] && [[ -n $displayRedrawPROPERTY ]]; then
	displayRedrawOPTION="$displayRedrawPROPERTY"
fi
[[ -n $displayIconMANAGED ]] && displayIconOPTION="$displayIconMANAGED"
if [[ -n $iconSizeIbmMANAGED ]]; then
	iconSizeIbmOPTION="$iconSizeIbmMANAGED"
elif [[ -z $iconSizeIbmOPTION ]] && [[ -n $iconSizeIbmPROPERTY ]]; then
	iconSizeIbmOPTION="$iconSizeIbmPROPERTY"
fi
if [[ -n $iconSizeJamfMANAGED ]]; then
	iconSizeJamfOPTION="$iconSizeJamfMANAGED"
elif [[ -z $iconSizeJamfOPTION ]] && [[ -n $iconSizeJamfPROPERTY ]]; then
	iconSizeJamfOPTION="$iconSizeJamfPROPERTY"
fi
if [[ -n $preferJamfMANAGED ]]; then
	preferJamfOPTION="$preferJamfMANAGED"
elif [[ -z $preferJamfOPTION ]] && [[ -n $preferJamfPROPERTY ]]; then
	preferJamfOPTION="$preferJamfPROPERTY"
fi
if [[ -n $policyTriggersMANAGED ]]; then
	policyTriggersOPTION="$policyTriggersMANAGED"
elif [[ -z $policyTriggersOPTION ]] && [[ -n $policyTriggersPROPERTY ]]; then
	policyTriggersOPTION="$policyTriggersPROPERTY"
fi
if [[ -n $skipUpdatesMANAGED ]]; then
	skipUpdatesOPTION="$skipUpdatesMANAGED"
elif [[ -z $skipUpdatesOPTION ]] && [[ -n $skipUpdatesPROPERTY ]]; then
	skipUpdatesOPTION="$skipUpdatesPROPERTY"
fi
if [[ -n $forceRestartMANAGED ]]; then
	forceRestartOPTION="$forceRestartMANAGED"
elif [[ -z $forceRestartOPTION ]] && [[ -n $forceRestartPROPERTY ]]; then
	forceRestartOPTION="$forceRestartPROPERTY"
fi
if [[ -n $testModeMANAGED ]]; then
	testModeOPTION="$testModeMANAGED"
elif [[ -z $testModeOPTION ]] && [[ -n $testModePROPERTY ]]; then
	testModeOPTION="$testModePROPERTY"
fi
if [[ -n $testModeTimeoutMANAGED ]]; then
	testModeTimeoutOPTION="$testModeTimeoutMANAGED"
elif [[ -z $testModeTimeoutOPTION ]] && [[ -n $testModeTimeoutPROPERTY ]]; then
	testModeTimeoutOPTION="$testModeTimeoutPROPERTY"
fi
if [[ -n $verboseModeMANAGED ]]; then
	verboseModeOPTION="$verboseModeMANAGED"
elif [[ -z $verboseModeOPTION ]] && [[ -n $verboseModePROPERTY ]]; then
	verboseModeOPTION="$verboseModePROPERTY"
fi
}

# Validate non-credential parameters and manage $superPLIST. Any errors set $parameterERROR.
manageParameters() {
# Validate $jamfBINARY if installed and set $jamfVERSION accordingly.
if [[ -e "$jamfBINARY" ]]; then
	jamfMAJOR=$("$jamfBINARY" -version | cut -c 9- | cut -d'.' -f1) # Expected output: 10
	jamfMINOR=$("$jamfBINARY" -version | cut -c 9- | cut -d'.' -f2) # Expected output: 30, 31, 32, etc.
	jamfVERSION=${jamfMAJOR}$(printf "%02d" "$jamfMINOR") # Expected output: 1030, 1031, 1032, etc.
	jamfAPPLE="1035"
	jamfINTEL="1000"
	if [[ "$macosARCH" == "arm64" ]] && [[ "$jamfVERSION" -lt "$jamfAPPLE" ]]; then
		sendToLog "Exit: Jamf Pro $jamfVERSION not supported for Apple Silicon."; parameterERROR="TRUE"
	elif [[ "$macosARCH" == "i386" ]] && [[ "$jamfVERSION" -lt "$jamfINTEL" ]]; then
		sendToLog "Exit: Jamf Pro $jamfVERSION not supported for Intel."; parameterERROR="TRUE"
	fi
else
	sendToLog "Starter: Unable to locate jamf binary at: $jamfBINARY"
	jamfVERSION="FALSE"
fi

# If there is no IBM Notifier.app, then validate $jamfHelper.
if [[ "$ibmNotifierVALID" == "FALSE" ]]; then
	if [[ ! -e "$jamfHELPER" ]]; then
		sendToLog "Exit: Cannot locate fallback jamfHelper at: $jamfHELPER"; parameterERROR="TRUE"
	fi
fi

# Various regular expressions used for parameter validation.
regexNUMBER="^[0-9]+$"
regexMENU="^[0-9*,]+$"
regexDATE="^[0-9][0-9][0-9][0-9]-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$"
regexTIME="^(2[0-3]|[01][0-9]):[0-5][0-9]$"
regexDATETIME="^[0-9][0-9][0-9][0-9]-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1]):(2[0-3]|[01][0-9]):[0-5][0-9]$"

# Validate $defaultDeferOPTION input and if valid override default $defaultDeferSECONDS parameter and save to $superPLIST.
if [[ "$defaultDeferOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for default deferral."
	defaults delete "$superPLIST" DefaultDefer 2> /dev/null
elif [[ -n $defaultDeferOPTION ]] && [[ $defaultDeferOPTION =~ $regexNUMBER ]]; then
	if [[ $defaultDeferOPTION -lt 120 ]]; then
		sendToLog "Warning: Specified default deferral time of $defaultDeferOPTION seconds is too low, rounding up to 120 seconds."
		defaultDeferSECONDS="120"
	elif [[ $defaultDeferOPTION -gt 86400 ]]; then
		sendToLog "Warning: Specified default deferral time of $defaultDeferOPTION seconds is too high, rounding down to 86400 seconds (1 day)."
		defaultDeferSECONDS="86400"
	else
		defaultDeferSECONDS="$defaultDeferOPTION"
	fi
	defaults write "$superPLIST" DefaultDefer -string "$defaultDeferSECONDS"
elif [[ -n $defaultDeferOPTION ]] && ! [[ $defaultDeferOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The default deferral time must only be a number."; parameterERROR="TRUE"
fi

# Validate $focusDeferOPTION input and if valid set $focusDeferSECONDS and save to $superPLIST.
if [[ "$focusDeferOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for Focus deferral."
	defaults delete "$superPLIST" FocusDefer 2> /dev/null
elif [[ -n $focusDeferOPTION ]] && [[ $focusDeferOPTION =~ $regexNUMBER ]]; then
	if [[ $focusDeferOPTION -lt 120 ]]; then
		sendToLog "Warning: Specified focus deferral time of $focusDeferOPTION seconds is too low, rounding up to 120 seconds."
		focusDeferSECONDS="120"
	elif [[ $focusDeferOPTION -gt 86400 ]]; then
		sendToLog "Warning: Specified focus deferral time of $focusDeferOPTION seconds is too high, rounding down to 86400 seconds (1 day)."
		focusDeferSECONDS="86400"
	else
		focusDeferSECONDS="$focusDeferOPTION"
	fi
	defaults write "$superPLIST" FocusDefer -string "$focusDeferSECONDS"
elif [[ -n $focusDeferOPTION ]] && ! [[ $focusDeferOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The focus deferral time must only be a number."; parameterERROR="TRUE"
fi

# Validate $menuDeferOPTION input and if valid set $menuDeferSECONDS and save to $superPLIST.
if [[ "$menuDeferOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for menu deferral."
	defaults delete "$superPLIST" MenuDefer 2> /dev/null
elif [[ -n $menuDeferOPTION ]] && [[ $menuDeferOPTION =~ $regexMENU ]]; then
	oldIFS="$IFS"; IFS=','
	read -r -a menuDeferARRAY <<< "$menuDeferOPTION"
	for i in "${!menuDeferARRAY[@]}"; do
		if [[ ${menuDeferARRAY[i]} -lt 120 ]]; then
			sendToLog "Warning: Specified menu deferral time of ${menuDeferARRAY[i]} seconds is too low, rounding up to 120 seconds."
			menuDeferARRAY[i]="120"
		elif [[ ${menuDeferARRAY[i]} -gt 86400 ]]; then
			sendToLog "Warning: Specified menu deferral time of ${menuDeferARRAY[i]} seconds is too high, rounding down to 86400 seconds (1 day)."
			menuDeferARRAY[i]="86400"
		fi
	done
	menuDeferSECONDS="${menuDeferARRAY[*]}"
	defaults write "$superPLIST" MenuDefer -string "$menuDeferSECONDS"
	IFS="$oldIFS"
elif [[ -n $menuDeferOPTION ]] && ! [[ $menuDeferOPTION =~ $regexMENU ]]; then
	sendToLog "Exit: The defer pop-up menu time(s) must only contain numbers and commas (no spaces)."; parameterERROR="TRUE"
fi

# Validate $recheckDeferOPTION input and if valid set $recheckDeferSECONDS and save to $superPLIST.
if [[ "$recheckDeferOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for recheck deferral."
	defaults delete "$superPLIST" RecheckDefer 2> /dev/null
elif [[ -n $recheckDeferOPTION ]] && [[ $recheckDeferOPTION =~ $regexNUMBER ]]; then
	if [[ $recheckDeferOPTION -lt 120 ]]; then
		sendToLog "Warning: Specified recheck deferral time of $recheckDeferOPTION seconds is too low, rounding up to 120 seconds."
		recheckDeferSECONDS="120"
	elif [[ $recheckDeferOPTION -gt 2628288 ]]; then
		sendToLog "Warning: Specified recheck deferral time of $recheckDeferOPTION seconds is too high, rounding down to 2628288 seconds (30 days)."
		recheckDeferSECONDS="2628288"
	else
		recheckDeferSECONDS="$recheckDeferOPTION"
	fi
	defaults write "$superPLIST" RecheckDefer -string "$recheckDeferSECONDS"
elif [[ -n $recheckDeferOPTION ]] && ! [[ $recheckDeferOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The recheck deferral time must only be a number."; parameterERROR="TRUE"
fi

# Validated that $recheckDeferOPTION and $skipUpdatesOPTION are not both active
if [[ -n $recheckDeferOPTION ]] && [[ "$skipUpdatesOPTION" == "TRUE" ]]; then
	sendToLog "Exit: You can not specify both the --recheck-defer and --skip-updates options at the same time."; parameterERROR="TRUE"
fi

# Validate $focusCountOPTION input and if valid set $focusCountMAX and save to $superPLIST.
if [[ "$focusCountOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for focus count deadline."
	defaults delete "$superPLIST" FocusCount 2> /dev/null
elif [[ -n $focusCountOPTION ]] && [[ $focusCountOPTION =~ $regexNUMBER ]]; then
	focusCountMAX="$focusCountOPTION"
	defaults write "$superPLIST" FocusCount -string "$focusCountMAX"
elif [[ -n $focusCountOPTION ]] && ! [[ $focusCountOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The focus count deadline must only be a number."; parameterERROR="TRUE"
fi

# Validate $softCountOPTION input and if valid set $softCountMAX.
if [[ "$softCountOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for soft count deadline."
	defaults delete "$superPLIST" SoftCount 2> /dev/null
elif [[ -n $softCountOPTION ]] && [[ $softCountOPTION =~ $regexNUMBER ]]; then
	softCountMAX="$softCountOPTION"
elif [[ -n $softCountOPTION ]] && ! [[ $softCountOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The soft count deadline must only be a number."; parameterERROR="TRUE"
fi

# Validate $hardCountOPTION input and if valid set $hardCountMAX.
if [[ "$hardCountOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for hard count deadline."
	defaults delete "$superPLIST" HardCount 2> /dev/null
elif [[ -n $hardCountOPTION ]] && [[ $hardCountOPTION =~ $regexNUMBER ]]; then
	hardCountMAX="$hardCountOPTION"
elif [[ -n $hardCountOPTION ]] && ! [[ $hardCountOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The hard count deadline must only be a number."; parameterERROR="TRUE"
fi

# Validated that $softCountMAX and $hardCountMAX are not both active, if not then save $softCountMAX or $hardCountMAX to $superPLIST.
if [[ -n $softCountMAX ]] && [[ -n $hardCountMAX ]]; then
	sendToLog "Exit: There cannot be simultaneous deferral maximums for both soft count and hard count deadlines. You must pick one maximum deferral count behavior."; parameterERROR="TRUE"
else
	[[ -n $softCountMAX ]] && defaults write "$superPLIST" SoftCount -string "$softCountMAX"
	[[ -n $hardCountMAX ]] && defaults write "$superPLIST" HardCount -string "$hardCountMAX"
fi

# Validate $focusDaysOPTION input and if valid set $focusDaysMAX and $focusDaysSECONDS.
if [[ "$focusDaysOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for focus days deadline."
	defaults delete "$superPLIST" FocusDays 2> /dev/null
elif [[ -n $focusDaysOPTION ]] && [[ $focusDaysOPTION =~ $regexNUMBER ]]; then
	focusDaysMAX="$focusDaysOPTION"
	focusDaysSECONDS=$((focusDaysMAX*86400))
elif [[ -n $focusDaysOPTION ]] && ! [[ $focusDaysOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The focus days deadline must only be a number."; parameterERROR="TRUE"
fi

# Validate $softDaysOPTION input and if valid set $softDaysMAX and $softDaysSECONDS.
if [[ "$softDaysOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for soft days deadline."
	defaults delete "$superPLIST" SoftDays 2> /dev/null
elif [[ -n $softDaysOPTION ]] && [[ $softDaysOPTION =~ $regexNUMBER ]]; then
	softDaysMAX="$softDaysOPTION"
	softDaysSECONDS=$((softDaysMAX*86400))
elif [[ -n $softDaysOPTION ]] && ! [[ $softDaysOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The soft days deadline must only be a number."; parameterERROR="TRUE"
fi

# Validate $hardDaysOPTION input and if valid set $hardDaysMAX and $hardDaysSECONDS.
if [[ "$hardDaysOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for hard days deadline."
	defaults delete "$superPLIST" HardDays 2> /dev/null
elif [[ -n $hardDaysOPTION ]] && [[ $hardDaysOPTION =~ $regexNUMBER ]]; then
	hardDaysMAX="$hardDaysOPTION"
	hardDaysSECONDS=$((hardDaysMAX*86400))
elif [[ -n $hardDaysOPTION ]] && ! [[ $hardDaysOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The hard days deadline must only be a number."; parameterERROR="TRUE"
fi

# Validate $focusDaysMAX, $softDaysMAX, and $hardDaysMAX in relation to each other. If valid then save maximum day deadlines to $superPLIST.
if [[ -n $hardDaysMAX ]] && [[ -n $softDaysMAX ]] && [[ $hardDaysMAX -le $softDaysMAX ]]; then
	sendToLog "Exit: The maximum hard days deadline of $hardDaysMAX day(s) must be more than the maximum soft days deadline of $softDaysMAX day(s)."; parameterERROR="TRUE"
fi
if [[ -n $hardDaysMAX ]] && [[ -n $focusDaysMAX ]] && [[ $hardDaysMAX -le $focusDaysMAX ]]; then
	sendToLog "Exit: The maximum hard days deadline of $hardDaysMAX day(s) must be more than the maximum focus days deadline of $focusDaysMAX day(s)."; parameterERROR="TRUE"
fi
if [[ -n $softDaysMAX ]] && [[ -n $focusDaysMAX ]] && [[ $softDaysMAX -le $focusDaysMAX ]]; then
	sendToLog "Exit: The maximum soft days deadline of $softDaysMAX day(s) must be more than the maximum focus days deadline of $focusDaysMAX day(s)."; parameterERROR="TRUE"
fi
if [[ "$parameterERROR" != "TRUE" ]]; then
	[[ -n $focusDaysMAX ]] && defaults write "$superPLIST" FocusDays -string "$focusDaysMAX"
	[[ -n $softDaysMAX ]] && defaults write "$superPLIST" SoftDays -string "$softDaysMAX"
	[[ -n $hardDaysMAX ]] && defaults write "$superPLIST" HardDays -string "$hardDaysMAX"
fi

# Validate $zeroDayOPTION, and if valid set $zeroDayOVERRIDE.
if [[ "$zeroDayOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for manual zero day override date."
	defaults delete "$superPLIST" ZeroDay 2> /dev/null
elif [[ -n $zeroDayOPTION ]]; then
	extractDATE=$(echo "$zeroDayOPTION" | cut -c-10 )
	if [[ $extractDATE =~ $regexDATE ]]; then
		extractTIME=$(echo "$zeroDayOPTION" | cut -c11- )
		if [[ -n $extractTIME ]]; then
			extractHOURS=$(echo "$extractTIME" | cut -d: -f2)
			[[ -z $extractHOURS ]] && extractHOURS="00"
			extractMINUTES=$(echo "$extractTIME" | cut -d: -f3)
			[[ -z $extractMINUTES ]] && extractMINUTES="00"
			extractTIME="$extractHOURS:$extractMINUTES"
		else
			extractTIME="00:00"
		fi
		if [[ $extractTIME =~ $regexTIME ]]; then
			calculatedDEADLINE="$extractDATE:$extractTIME"
		else
			sendToLog "Exit: The manual zero day override date time must be a valid 24-hour time formated as hh:mm."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: The manual zero day override date must be a valid date formated as YYYY-MM-DD."; parameterERROR="TRUE"
	fi
	if [[ $calculatedDEADLINE =~ $regexDATETIME ]]; then
		zeroDayOVERRIDE="$calculatedDEADLINE"
	else
		sendToLog "Exit: The manual zero day override date must be a valid and formated as YYYY-MM-DD:hh:mm."; parameterERROR="TRUE"
	fi
fi

# Validate that any $zeroDayOVERRIDE also includes a day deadline, if valid save to $superPLIST.
if { [[ -z $focusDaysMAX ]] && [[ -z $softDaysMAX ]] && [[ -z $hardDaysMAX ]]; } && [[ -n $zeroDayOVERRIDE ]]; then
	sendToLog "Exit: Specifying a manual zero day date also requres that you set a day deadline."; parameterERROR="TRUE"
fi
if [[ "$parameterERROR" != "TRUE" ]]; then
	[[ -n $zeroDayOVERRIDE ]] && defaults write "$superPLIST" ZeroDay -string "$zeroDayOVERRIDE"
fi

# Validate $focusDateOPTION, if valid set $focusDateMAX and $focusDateEPOCH.
if [[ "$focusDateOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for focus date deadline."
	defaults delete "$superPLIST" FocusDate 2> /dev/null
elif [[ -n $focusDateOPTION ]]; then
	extractDATE=$(echo "$focusDateOPTION" | cut -c-10 )
	if [[ $extractDATE =~ $regexDATE ]]; then
		extractTIME=$(echo "$focusDateOPTION" | cut -c11- )
		if [[ -n $extractTIME ]]; then
			extractHOURS=$(echo "$extractTIME" | cut -d: -f2)
			[[ -z $extractHOURS ]] && extractHOURS="00"
			extractMINUTES=$(echo "$extractTIME" | cut -d: -f3)
			[[ -z $extractMINUTES ]] && extractMINUTES="00"
			extractTIME="$extractHOURS:$extractMINUTES"
		else
			extractTIME="00:00"
		fi
		if [[ $extractTIME =~ $regexTIME ]]; then
			calculatedDEADLINE="$extractDATE:$extractTIME"
		else
			sendToLog "Exit: The focus date deadline time must be a valid 24-hour time formated as hh:mm."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: The focus date deadline date must be a valid date formated as YYYY-MM-DD."; parameterERROR="TRUE"
	fi
	if [[ $calculatedDEADLINE =~ $regexDATETIME ]]; then
		focusDateMAX="$calculatedDEADLINE"
		focusDateEPOCH=$(date -j -f "%Y-%m-%d:%H:%M" "$calculatedDEADLINE" +"%s")
	else
		sendToLog "Exit: The focus date deadline must be a valid and formated as YYYY-MM-DD:hh:mm."; parameterERROR="TRUE"
	fi
fi

# Validate $softDateOPTION, if valid set $softDateMAX and $softDateEPOCH.
if [[ "$softDateOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for soft date deadline."
	defaults delete "$superPLIST" SoftDate 2> /dev/null
elif [[ -n $softDateOPTION ]]; then
	extractDATE=$(echo "$softDateOPTION" | cut -c-10 )
	if [[ $extractDATE =~ $regexDATE ]]; then
		extractTIME=$(echo "$softDateOPTION" | cut -c11- )
		if [[ -n $extractTIME ]]; then
			extractHOURS=$(echo "$extractTIME" | cut -d: -f2)
			[[ -z $extractHOURS ]] && extractHOURS="00"
			extractMINUTES=$(echo "$extractTIME" | cut -d: -f3)
			[[ -z $extractMINUTES ]] && extractMINUTES="00"
			extractTIME="$extractHOURS:$extractMINUTES"
		else
			extractTIME="00:00"
		fi
		if [[ $extractTIME =~ $regexTIME ]]; then
			calculatedDEADLINE="$extractDATE:$extractTIME"
		else
			sendToLog "Exit: The soft date deadline time must be a valid 24-hour time formated as hh:mm."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: The soft date deadline date must be a valid date formated as YYYY-MM-DD."; parameterERROR="TRUE"
	fi
	if [[ $calculatedDEADLINE =~ $regexDATETIME ]]; then
		softDateMAX="$calculatedDEADLINE"
		softDateEPOCH=$(date -j -f "%Y-%m-%d:%H:%M" "$calculatedDEADLINE" +"%s")
	else
		sendToLog "Exit: The soft date deadline must be a valid and formated as YYYY-MM-DD:hh:mm."; parameterERROR="TRUE"
	fi
fi

# Validate $hardDateOPTION, if valid set $hardDateMAX and $hardDateEPOCH.
if [[ "$hardDateOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for hard date deadline."
	defaults delete "$superPLIST" HardDate 2> /dev/null
elif [[ -n $hardDateOPTION ]]; then
	extractDATE=$(echo "$hardDateOPTION" | cut -c-10 )
	if [[ $extractDATE =~ $regexDATE ]]; then
		extractTIME=$(echo "$hardDateOPTION" | cut -c11- )
		if [[ -n $extractTIME ]]; then
			extractHOURS=$(echo "$extractTIME" | cut -d: -f2)
			[[ -z $extractHOURS ]] && extractHOURS="00"
			extractMINUTES=$(echo "$extractTIME" | cut -d: -f3)
			[[ -z $extractMINUTES ]] && extractMINUTES="00"
			extractTIME="$extractHOURS:$extractMINUTES"
		else
			extractTIME="00:00"
		fi
		if [[ $extractTIME =~ $regexTIME ]]; then
			calculatedDEADLINE="$extractDATE:$extractTIME"
		else
			sendToLog "Exit: The hard date deadline time must be a valid 24-hour time formated as hh:mm."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: The hard date deadline date must be a valid date formated as YYYY-MM-DD."; parameterERROR="TRUE"
	fi
	if [[ $calculatedDEADLINE =~ $regexDATETIME ]]; then
		hardDateMAX="$calculatedDEADLINE"
		hardDateEPOCH=$(date -j -f "%Y-%m-%d:%H:%M" "$calculatedDEADLINE" +"%s")
	else
		sendToLog "Exit: The hard date deadline must be a valid and formated as YYYY-MM-DD:hh:mm."; parameterERROR="TRUE"
	fi
fi

# Validate $focusDateEPOCH, $softDateEPOCH, and $hardDateEPOCH in relation to each other. If valid then save date deadlines to $superPLIST.
if [[ -n $hardDateEPOCH ]] && [[ -n $softDateEPOCH ]] && [[ $hardDateEPOCH -le $softDateEPOCH ]]; then
	sendToLog "Exit: The hard date deadline of $hardDateMAX must be later than the soft date deadline of $softDateMAX."; parameterERROR="TRUE"
fi
if [[ -n $hardDateEPOCH ]] && [[ -n $focusDateEPOCH ]] && [[ $hardDateEPOCH -le $focusDateEPOCH ]]; then
	sendToLog "Exit: The hard date deadline of $hardDateMAX must be later than the focus date deadline of $focusDateMAX."; parameterERROR="TRUE"
fi
if [[ -n $softDateEPOCH ]] && [[ -n $focusDateEPOCH ]] && [[ $softDateEPOCH -le $focusDateEPOCH ]]; then
	sendToLog "Exit: The soft date deadline of $softDateMAX must be later than the focus date deadline of $focusDateMAX."; parameterERROR="TRUE"
fi
if [[ "$parameterERROR" != "TRUE" ]]; then
	[[ -n $focusDateMAX ]] && defaults write "$superPLIST" FocusDate -string "$focusDateMAX"
	[[ -n $softDateMAX ]] && defaults write "$superPLIST" SoftDate -string "$softDateMAX"
	[[ -n $hardDateMAX ]] && defaults write "$superPLIST" HardDate -string "$hardDateMAX"
fi

# Validate that any focus deadlines also include a coordinating $focusDeferSECONDS, if not then set $focusDeferSECONDS to $defaultDeferSECONDS.
if { [[ -n $focusCountMAX ]] || [[ -n $focusDaysMAX ]] || [[ -n $focusDateMAX ]]; } && [[ -z $focusDeferSECONDS ]]; then
	sendToLog "Warning: No focus defer seconds specified, setting to default defer of $defaultDeferSECONDS seconds."
	focusDeferSECONDS="$defaultDeferSECONDS"
fi

# Validate $displayTimeoutOPTION and $displayRedrawOPTION inputs and if valid set $displayTimeoutSECONDS and $displayRedrawSECONDS and save to $superPLIST.
if [[ "$displayTimeoutOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for display timeout."
	defaults delete "$superPLIST" DisplayTimeout 2> /dev/null
elif [[ -n $displayTimeoutOPTION ]] && [[ $displayTimeoutOPTION =~ $regexNUMBER ]]; then
	displayTimeoutSECONDS="$displayTimeoutOPTION"
	defaults write "$superPLIST" DisplayTimeout -string "$displayTimeoutSECONDS"
elif [[ -n $displayTimeoutOPTION ]] && ! [[ $displayTimeoutOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The display timeout must only be a number."; parameterERROR="TRUE"
fi
if [[ "$displayRedrawOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for display redraw."
	defaults delete "$superPLIST" DisplayRedraw 2> /dev/null
elif [[ -n $displayRedrawOPTION ]] && [[ $displayRedrawOPTION =~ $regexNUMBER ]]; then
	displayRedrawSECONDS="$displayRedrawOPTION"
	defaults write "$superPLIST" DisplayRedraw -string "$displayRedrawSECONDS"
elif [[ -n $displayRedrawOPTION ]] && ! [[ $displayRedrawOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The display redraw time must only be a number."; parameterERROR="TRUE"
fi
if [[ "$parameterERROR" != "TRUE" ]] && [[ -n $displayTimeoutSECONDS ]] && [[ -n $displayRedrawSECONDS ]]; then
	displayMinimumTIMEOUT=$((displayRedrawSECONDS * 3))
	if [[ $displayTimeoutSECONDS -lt $displayMinimumTIMEOUT ]];then
		sendToLog "Warning: Specified display timeout of $displayTimeoutSECONDS seconds is too low given a display redraw of $displayRedrawSECONDS seconds, changing display timeout to $displayMinimumTIMEOUT seconds."
		displayTimeoutSECONDS=$displayMinimumTIMEOUT
		defaults write "$superPLIST" DisplayTimeout -string "$displayTimeoutSECONDS"
	fi
fi

# Verify the $displayIconOPTION to be used for the super service account and in notifications and dialogs, and if valid copy and set $cachedICON and save to $superPLIST.
if [[ "$displayIconOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting cached display icon."
	[[ -f "$cachedICON" ]] && rm -f "$cachedICON"
elif [[ -n "$displayIconOPTION" ]] && [[ "$displayIconOPTION" != "$(defaults read "$superPLIST" DisplayIconCache 2> /dev/null)" ]]; then
	if [[ $(echo "$displayIconOPTION" | grep '^http://\|^https://' -c) -eq 1 ]]; then
		sendToLog "Starter: Attempting to download requested icon from: $displayIconOPTION"
		downloadRESULT=$(curl "$displayIconOPTION" -L -o "/tmp/cachedICON" 2>&1)
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: downloadRESULT: \n$downloadRESULT"
		if [[ -f "/tmp/cachedICON" ]]; then
			sipsRESULT=$(sips -s format png "/tmp/cachedICON" --out "$cachedICON" 2>&1)
			[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: sipsRESULT: \n$sipsRESULT"
			defaults write "$superPLIST" DisplayIconCache -string "$displayIconOPTION"
		else
			sendToLog "Warning: Unable to download specified icon from: $displayIconOPTION"
		fi
	elif [[ -e "$displayIconOPTION" ]]; then
		sendToLog "Starter: Copying requested icon from: $displayIconOPTION"
		sipsRESULT=$(sips -s format png "$displayIconOPTION" --out "$cachedICON" 2>&1)
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: sipsRESULT: \n$sipsRESULT"
		defaults write "$superPLIST" DisplayIconCache -string "$displayIconOPTION"
	else
		sendToLog "Warning: Unable to locate specified icon from: $displayIconOPTION"
	fi
fi
if [[ ! -f "$cachedICON" ]]; then
	sendToLog "Starter: No custom display icon found, copying default icon from: $defaultICON"
	sipsRESULT=$(sips -s format png "$defaultICON" --out "$cachedICON" 2>&1)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: sipsRESULT: \n$sipsRESULT"
	defaults write "$superPLIST" DisplayIconCache -string "$defaultICON"
fi

# Validate $iconSizeIbmOPTION input and if valid override default $ibmNotifierIconSIZE parameter and save to $superPLIST.
if [[ "$iconSizeIbmOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for Ibm Notifier icon size."
	defaults delete "$superPLIST" IconSizeIbm 2> /dev/null
elif [[ -n $iconSizeIbmOPTION ]] && [[ $iconSizeIbmOPTION =~ $regexNUMBER ]]; then
	if [[ $iconSizeIbmOPTION -lt 32 ]]; then
		sendToLog "Warning: Specified Ibm Notifier icon size of $iconSizeIbmOPTION pixels is too low, rounding up to 32 pixels."
		ibmNotifierIconSIZE="32"
	elif [[ $iconSizeIbmOPTION -gt 150 ]]; then
		sendToLog "Warning: Specified Ibm Notifier icon size of $iconSizeIbmOPTION pixels is too high, rounding down to 150 pixels."
		ibmNotifierIconSIZE="150"
	else
		ibmNotifierIconSIZE="$iconSizeIbmOPTION"
	fi
	defaults write "$superPLIST" IconSizeIbm -string "$ibmNotifierIconSIZE"
elif [[ -n $iconSizeIbmOPTION ]] && ! [[ $iconSizeIbmOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The Ibm Notifier icon size must only be a number."; parameterERROR="TRUE"
fi

# Validate $iconSizeJamfOPTION input and if valid override default $jamfHelperIconSIZE parameter and save to $superPLIST.
if [[ "$iconSizeJamfOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for Ibm Notifier icon size."
	defaults delete "$superPLIST" IconSizeJamf 2> /dev/null
elif [[ -n $iconSizeJamfOPTION ]] && [[ $iconSizeJamfOPTION =~ $regexNUMBER ]]; then
	if [[ $iconSizeJamfOPTION -lt 32 ]]; then
		sendToLog "Warning: Specified Ibm Notifier icon size of $iconSizeJamfOPTION pixels is too low, rounding up to 32 pixels."
		jamfHelperIconSIZE="32"
	elif [[ $iconSizeJamfOPTION -gt 150 ]]; then
		sendToLog "Warning: Specified Ibm Notifier icon size of $iconSizeJamfOPTION pixels is too high, rounding down to 150 pixels."
		jamfHelperIconSIZE="150"
	else
		jamfHelperIconSIZE="$iconSizeJamfOPTION"
	fi
	defaults write "$superPLIST" IconSizeJamf -string "$jamfHelperIconSIZE"
elif [[ -n $iconSizeJamfOPTION ]] && ! [[ $iconSizeJamfOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The Ibm Notifier icon size must only be a number."; parameterERROR="TRUE"
fi

# Manage $preferJamfOPTION and save to $superPLIST.
if [[ -n $preferJamfOPTION ]]; then
	if [[ $preferJamfOPTION -eq 1 ]] || [[ "$preferJamfOPTION" == "TRUE" ]]; then
		if [[ "$jamfVERSION" != "FALSE" ]]; then
			preferJamfOPTION="TRUE"
			defaults write "$superPLIST" PreferJamf -bool "$preferJamfOPTION"
		else
			sendToLog "Exit: No local Jamf binary found, thus can not prefer jamfHelper."; parameterERROR="TRUE"
		fi
	else
		preferJamfOPTION="FALSE"
		defaults delete "$superPLIST" PreferJamf 2> /dev/null
	fi
fi

# Validate $policyTriggersOPTION input and if valid set $policyTRIGGERS and save to $superPLIST.
if [[ "$policyTriggersOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for Jamf Pro Policy triggers."
	defaults delete "$superPLIST" PolicyTriggers 2> /dev/null
elif [[ -n $policyTriggersOPTION ]]; then
	policyTRIGGERS="$policyTriggersOPTION"
	defaults write "$superPLIST" PolicyTriggers -string "$policyTRIGGERS"
fi
if [[ "$jamfVERSION" == "FALSE" ]] && [[ -n $policyTRIGGERS ]]; then
	sendToLog "Exit: Unable to run Jamf Pro Policy Triggers due to missing Jamf binary."; parameterERROR="TRUE"
fi

# Manage $skipUpdatesOPTION and save to $superPLIST.
if [[ $skipUpdatesOPTION -eq 1 ]] || [[ "$skipUpdatesOPTION" == "TRUE" ]]; then
	skipUpdatesOPTION="TRUE"
	defaults write "$superPLIST" SkipUpdates -bool "$skipUpdatesOPTION"
else
	skipUpdatesOPTION="FALSE"
	defaults delete "$superPLIST" SkipUpdates 2> /dev/null
fi

# Manage $forceRestartOPTION and save to $superPLIST.
if [[ $forceRestartOPTION -eq 1 ]] || [[ "$forceRestartOPTION" == "TRUE" ]]; then
	forceRestartOPTION="TRUE"
	defaults write "$superPLIST" ForceRestart -bool "$forceRestartOPTION"
else
	forceRestartOPTION="FALSE"
	defaults delete "$superPLIST" ForceRestart 2> /dev/null
fi

# Manage $testModeOPTION and save to $superPLIST.
if [[ $testModeOPTION -eq 1 ]] || [[ "$testModeOPTION" == "TRUE" ]]; then
	testModeOPTION="TRUE"
	defaults write "$superPLIST" TestMode -bool "$testModeOPTION"
else
	testModeOPTION="FALSE"
	defaults delete "$superPLIST" TestMode 2> /dev/null
fi
if [[ "$testModeOPTION" == "TRUE" ]] && [[ "$currentUSER" == "FALSE" ]]; then
	sendToLog "Exit: Test mode requires that a valid user is logged in."; parameterERROR="TRUE"
fi

# Validate $testModeTimeoutOPTION input and if valid set $testModeTIMEOUT and save to $superPLIST.
if [[ "$testModeTimeoutOPTION" == "X" ]]; then
	sendToLog "Starter: Deleting local preference for test mode timeout."
	defaults delete "$superPLIST" TestModeTimeout 2> /dev/null
elif [[ -n $testModeTimeoutOPTION ]] && [[ $testModeTimeoutOPTION =~ $regexNUMBER ]]; then
	testModeTIMEOUT="$testModeTimeoutOPTION"
	defaults write "$superPLIST" TestModeTimeout -string "$testModeTIMEOUT"
elif [[ -n $testModeTimeoutOPTION ]] && ! [[ $testModeTimeoutOPTION =~ $regexNUMBER ]]; then
	sendToLog "Exit: The test mode timeout must only be a number."; parameterERROR="TRUE"
fi
}

# Manage update credentials given $deleteACCOUNTS, $localACCOUNT, $adminACCOUNT, $superACCOUNT, or $jamfACCOUNT. Any errors set $parameterERROR.
manageUpdateCredentials () {

# Local update credentials are only validated for Apple Silicon computers.
if [[ "$macosARCH" == "arm64" ]]; then
	# Validate that $localOPTION and $localPASSWORD are simultaneously provided.
	if [[ -n $localOPTION ]] && [[ -z $localPASSWORD ]]; then
		sendToLog "Exit: A local volume owner account name requires that you also set a local volume owner password."; parameterERROR="TRUE"
	fi
	if [[ -z $localOPTION ]] && [[ -n $localPASSWORD ]]; then
		sendToLog "Exit: A local volume owner password requires that you also set a local volume owner account name."; parameterERROR="TRUE"
	fi

	# Validate that $localOPTION exists, is a volume owner, and that $localPASSWORD is correct.
	if [[ -n $localOPTION ]] && [[ "$parameterERROR" != "TRUE" ]]; then
		localGUID=$(dscl . read "/Users/$localOPTION" GeneratedUID 2> /dev/null | awk '{print $2;}')
		if [[ -n $localGUID ]]; then
			if ! [[ $(diskutil apfs listcryptousers / | grep -c "$localGUID") -ne 0 ]]; then
				sendToLog "Exit: Provided account \"$localOPTION\" is not a system volume owner."; parameterERROR="TRUE"
			fi
			localVALID=$(dscl /Local/Default -authonly "$localOPTION" "$localPASSWORD" 2>&1)
			if ! [[ "$localVALID" == "" ]];then
				sendToLog "Exit: The provided password for account \"$localOPTION\" is not valid."; parameterERROR="TRUE"
			fi
		else
			sendToLog "Exit: Could not retrieve GUID for account \"$localOPTION\". Verify that account exists locally."; parameterERROR="TRUE"
		fi
	fi

	# Validate that $adminACCOUNT and $adminPASSWORD are simultaneously provided.
	if [[ -n $adminACCOUNT ]] && [[ -z $adminPASSWORD ]]; then
		sendToLog "Exit: A local admin account name requires that you also set a local admin password."; parameterERROR="TRUE"
	fi
	if [[ -z $adminACCOUNT ]] && [[ -n $adminPASSWORD ]]; then
		sendToLog "Exit: A local admin password requires that you also set a local admin account name."; parameterERROR="TRUE"
	fi

	# Validate that $adminACCOUNT is also specified with $superOPTION.
	if [[ -n $superOPTION ]] && [[ -z $adminACCOUNT ]]; then
		sendToLog "Exit: Local admin credentials are required to set a custom super service account name."; parameterERROR="TRUE"
	fi

	# Validate that $adminACCOUNT exists, is a volume owner, a local admin, and that $adminPASSWORD is correct.
	if [[ -n $adminACCOUNT ]] && [[ "$parameterERROR" != "TRUE" ]]; then
		adminGUID=$(dscl . read "/Users/$adminACCOUNT" GeneratedUID 2> /dev/null | awk '{print $2;}')
		if [[ -n $adminGUID ]]; then
			if [[ $(groups "$adminACCOUNT" | grep "admin" -c) -eq 0 ]]; then
				sendToLog "Exit: Provided account \"$adminACCOUNT\" is not a local administrator."; parameterERROR="TRUE"
			fi
			if ! [[ $(diskutil apfs listcryptousers / | grep -c "$adminGUID") -ne 0 ]]; then
				sendToLog "Exit: Provided account \"$adminACCOUNT\" is not a system volume owner."; parameterERROR="TRUE"
			fi
			adminVALID=$(dscl /Local/Default -authonly "$adminACCOUNT" "$adminPASSWORD" 2>&1)
			if ! [[ "$adminVALID" == "" ]];then
				sendToLog "Exit: The provided password for account \"$adminACCOUNT\" is not valid."; parameterERROR="TRUE"
			fi
		else
			sendToLog "Exit: Could not retrieve GUID for account \"$adminACCOUNT\". Verify that account exists locally."; parameterERROR="TRUE"
		fi
	fi
fi

# Validate that $jamfOPTION is only used on computers with the jamf binary installed.
if [[ -n $jamfOPTION ]] && [[ "$jamfVERSION" == "FALSE" ]]; then
	sendToLog "Exit: A Jamf Pro API account name requires that this computer is enrolled in Jamf Pro."; parameterERROR="TRUE"
fi

# Validate that $jamfOPTION and $jamfPASSWORD are simultaneously provided.
if [[ -n $jamfOPTION ]] && [[ -z $jamfPASSWORD ]]; then
	sendToLog "Exit: A Jamf Pro API account name requires that you also set a Jamf Pro API password."; parameterERROR="TRUE"
fi
if [[ -z $jamfOPTION ]] && [[ -n $jamfPASSWORD ]]; then
	sendToLog "Exit: A Jamf Pro API password requires that you also set a Jamf Pro API account name."; parameterERROR="TRUE"
fi

# Validate that the account $jamfOPTION and $jamfPASSWORD are valid.
if [[ -n $jamfOPTION ]] && [[ "$parameterERROR" != "TRUE" ]]; then
	jamfACCOUNT="$jamfOPTION"
	jamfKEYCHAIN="$jamfPASSWORD"
	getJamfProServer
	if [[ "$jamfSERVER" != "FALSE" ]]; then
		getJamfProAccount
		[[ "$jamfERROR" == "TRUE" ]] && parameterERROR="TRUE"
	else
		sendToLog "Exit: Unable to connect to Jamf Pro to validate user account."; parameterERROR="TRUE"
	fi
	unset jamfACCOUNT
	unset jamfKEYCHAIN
fi

# Collect any previously saved account names from $superPLIST.
localPROPERTY=$(defaults read "$superPLIST" LocalAccount 2> /dev/null)
superPROPERTY=$(defaults read "$superPLIST" SuperAccount 2> /dev/null)
jamfPROPERTY=$(defaults read "$superPLIST" JamfAccount 2> /dev/null)

# Some messaging to indicate if there are no saved accounts when a delete is requested.
{ [[ -z $localPROPERTY ]] && [[ -z $superPROPERTY ]] && [[ -z $jamfPROPERTY ]] && [[ -n $deleteACCOUNTS ]]; } && sendToLog "Starter: No saved accounts to delete."

# If there was a previous $localPROPERTY account and the user specified $localOPTION or $deleteACCOUNTS then delete any previously saved local account credentials.
if [[ -n $localPROPERTY ]] && { [[ -n $localOPTION ]] || [[ "$deleteACCOUNTS" == "TRUE" ]]; }; then
	sendToLog "Starter: Deleting saved credentials for local account \"$localPROPERTY\"."
	defaults delete "$superPLIST" LocalAccount > /dev/null 2>&1
	security delete-generic-password -a "$localPROPERTY" -s "Super Local Account" /Library/Keychains/System.keychain > /dev/null 2>&1
	unset localPROPERTY
	localCREDENTIAL="FALSE"
fi

# If there was a previous $superPROPERTY account and the user specified $adminACCOUNT or $deleteACCOUNTS then delete any previously saved super service account and credentials.
if [[ -n $superPROPERTY ]] && { [[ -n $adminACCOUNT ]] || [[ "$deleteACCOUNTS" == "TRUE" ]]; } then
	sendToLog "Starter: Deleting local account and saved cedentials for super service account \"$superPROPERTY\"."
	sysadminctl -deleteUser "$superPROPERTY" > /dev/null 2>&1
	defaults delete "$superPLIST" SuperAccount > /dev/null 2>&1
	security delete-generic-password -a "$superPROPERTY" -s "Super Service Account" /Library/Keychains/System.keychain > /dev/null 2>&1
	unset superPROPERTY
	superCREDENTIAL="FALSE"
fi

# If there was a previous $jamfPROPERTY account and the user specified $jamfOPTION or $deleteACCOUNTS then delete any previously saved Jamf Pro API credentials.
if [[ -n $jamfPROPERTY ]] && { [[ -n $jamfOPTION ]] || [[ "$deleteACCOUNTS" == "TRUE" ]]; } then
	sendToLog "Starter: Deleting saved credentials for Jamf Pro API account \"$jamfPROPERTY\"."
	defaults delete "$superPLIST" JamfAccount > /dev/null 2>&1
	security delete-generic-password -a "$jamfPROPERTY" -s "Super MDM Account" /Library/Keychains/System.keychain > /dev/null 2>&1
	unset jamfPROPERTY
	jamfCREDENTIAL="FALSE"
fi

# If any previous validation generated a $parameterERROR then it's not necessary to continue this function.
[[ $parameterERROR == "TRUE" ]] && return 0

# On Apple Silicon, if a new local account was specified, save $localOPTION and $localPASSWORD credentials and then validate retrieval.
if [[ "$macosARCH" == "arm64" ]] && [[ -n $localOPTION ]]; then
	sendToLog "Starter: Saving new credentials for local account \"$localOPTION\"..."
	defaults write "$superPLIST" LocalAccount -string "$localOPTION"
	localACCOUNT=$(defaults read "$superPLIST" LocalAccount 2> /dev/null)
	if [[ "$localOPTION" == "$localACCOUNT" ]]; then
		security add-generic-password -a "$localACCOUNT" -s "Super Local Account" -w "$localPASSWORD" -T /usr/bin/security /Library/Keychains/System.keychain
		localKEYCHAIN=$(security find-generic-password -w -a "$localACCOUNT" -s "Super Local Account" /Library/Keychains/System.keychain 2> /dev/null)
		if [[ "$localPASSWORD" == "$localKEYCHAIN" ]]; then
			sendToLog "Starter: Validated saved credentials for local account \"$localACCOUNT\"."
			localCREDENTIAL="TRUE"
		else
			sendToLog "Exit: Unable to validate saved password for local account \"$localACCOUNT\", deleting saved password."; parameterERROR="TRUE"
			security delete-generic-password -a "$localACCOUNT" -s "Super Local Account" /Library/Keychains/System.keychain > /dev/null 2>&1
		fi
	else
		sendToLog "Exit: Unable to validate saved name for local account \"$localOPTION\", deleting saved name."; parameterERROR="TRUE"
		defaults delete "$superPLIST" LocalAccount > /dev/null 2>&1
	fi
fi

# On Apple Silicon, if an $adminACCOUNT was specified then a new super service account needs to be created and its credentials saved.
if [[ "$macosARCH" == "arm64" ]] && [[ -n $adminACCOUNT ]]; then
	# If the a custom super service account name is requested via $superOPTION.
	if [[ -n $superOPTION ]]; then
		superNEWACCT="$superOPTION"
		superNEWFULL="$superOPTION"
	else # Use the default names for the super service account.
		superNEWACCT="super"
		superNEWFULL="Super Update Service"
	fi

	# If a custom super service account password is requested via $superPASSWORD.
	if [[ -n $superPASSWORD ]]; then
		superNEWPASS="$superPASSWORD"
	else # Use the default random password for the super service account.
		superNEWPASS=$(uuidgen)
	fi

	# Save and validate new super service account credentials, and validate retrieval.
	sendToLog "Starter: Saving new credentials for super service account \"$superNEWACCT\"..."
	defaults write "$superPLIST" SuperAccount -string "$superNEWACCT"
	superACCOUNT=$(defaults read "$superPLIST" SuperAccount 2> /dev/null)
	if [[ "$superNEWACCT" == "$superACCOUNT" ]]; then
		security add-generic-password -a "$superACCOUNT" -s "Super Service Account" -w "$superNEWPASS" -T /usr/bin/security /Library/Keychains/System.keychain
		superKEYCHAIN=$(security find-generic-password -w -a "$superACCOUNT" -s "Super Service Account" /Library/Keychains/System.keychain 2> /dev/null)
		if [[ "$superNEWPASS" == "$superKEYCHAIN" ]]; then # Only if saved credentials are valid do we create the new super service account.
			sendToLog "Starter: Validated saved credentials for new super service account \"$superACCOUNT\"."
			if [[ $(id "$superACCOUNT" 2>&1 | grep "no such user" -c) -eq 1 ]]; then
				sendToLog "Starter: Deleting existing super service account \"$superACCOUNT\" in preparation for new account."
				sysadminctl -deleteUser "$superACCOUNT" > /dev/null 2>&1
			fi
			# Loop through local IDs to find the first vacant id after 500.
			newUID=501
			while [[ $(id $newUID 2>&1 | grep "no such user" -c) -ne 1 ]]; do
				newUID=$((newUID + 1))
			done
			sendToLog "Starter: Creating new super service account \"$superNEWACCT\" with full name \"$superNEWFULL\" and UID $newUID..."
			addRESULT=$(sysadminctl -addUser "$superNEWACCT" -fullName "$superNEWFULL" -password "$superNEWPASS" -UID $newUID -GID 20 -shell /dev/null -home /dev/null -picture "$cachedICON" -adminUser "$adminACCOUNT" -adminPassword "$adminPASSWORD" 2>&1)
			[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: addRESULT: \n$addRESULT"
			dscl . create /Users/"$superNEWACCT" IsHidden 1
			updateACCOUNT="$superACCOUNT"
			updateKEYCHAIN="$superKEYCHAIN"
			checkLocalUpdateAccount
			if [[ "$accountERROR" != "TRUE" ]]; then
				sendToLog "Starter: Validated the creation of new super service account \"$superACCOUNT\"."
				superCREDENTIAL="TRUE"
			else
				sendToLog "Exit: Unable to validate newly created super service account \"$superACCOUNT\", deleting account"; parameterERROR="TRUE"
				sysadminctl -deleteUser "$superACCOUNT" > /dev/null 2>&1
				defaults delete "$superPLIST" SuperAccount > /dev/null 2>&1
				security delete-generic-password -a "$superACCOUNT" -s "Super Service Account" /Library/Keychains/System.keychain > /dev/null 2>&1
				unset superPROPERTY
			fi
		else
			sendToLog "Exit: Unable to validate saved password for new super service account \"$superNEWACCT\", deleting saved password."; parameterERROR="TRUE"
			security delete-generic-password -a "$superACCOUNT" -s "Super Service Account" /Library/Keychains/System.keychain > /dev/null 2>&1
		fi
	else
		sendToLog "Exit: Unable to validate saved name for new super service account \"$superNEWACCT\",deleting saved name."; parameterERROR="TRUE"
		defaults delete "$superPLIST" SuperAccount > /dev/null 2>&1
	fi
fi

# If a new Jamf Pro API account was specified, save $jamfOPTION and $jamfPASSWORD credentials and then validate retrieval.
if [[ -n $jamfOPTION ]]; then
	sendToLog "Starter: Saving new credentials for Jamf Pro API account \"$jamfOPTION\"..."
	defaults write "$superPLIST" JamfAccount -string "$jamfOPTION"
	jamfACCOUNT=$(defaults read "$superPLIST" JamfAccount 2> /dev/null)
	if [[ "$jamfOPTION" == "$jamfACCOUNT" ]]; then
		security add-generic-password -a "$jamfACCOUNT" -s "Super MDM Account" -w "$jamfPASSWORD" -T /usr/bin/security /Library/Keychains/System.keychain
		jamfKEYCHAIN=$(security find-generic-password -w -a "$jamfACCOUNT" -s "Super MDM Account" /Library/Keychains/System.keychain 2> /dev/null)
		if [[ "$jamfPASSWORD" == "$jamfKEYCHAIN" ]]; then
			sendToLog "Starter: Validated saved credentials for Jamf Pro API account \"$jamfACCOUNT\"."
			jamfCREDENTIAL="TRUE"
		else
			sendToLog "Exit: Unable to validate saved password for Jamf Pro API account \"$jamfACCOUNT\", deleting saved password."; parameterERROR="TRUE"
			security delete-generic-password -a "$jamfACCOUNT" -s "Super MDM Account" /Library/Keychains/System.keychain > /dev/null 2>&1
		fi
	else
		sendToLog "Exit: Unable to validate saved name for Jamf Pro API account \"$jamfOPTION\", deleting saved name."; parameterERROR="TRUE"
		defaults delete "$superPLIST" JamfAccount > /dev/null 2>&1
	fi
fi

# On Apple Silicon, if there is a previously saved local account (that wasn't just deleted), validate the account and set $localACCOUNT and $localPASSWORD.
if [[ "$macosARCH" == "arm64" ]] && [[ -n $localPROPERTY ]]; then
	localACCOUNT="$localPROPERTY"
	localKEYCHAIN=$(security find-generic-password -w -a "$localACCOUNT" -s "Super Local Account" /Library/Keychains/System.keychain 2> /dev/null)
	if [[ -n $localKEYCHAIN ]]; then
		sendToLog "Starter: Found saved credentials for local account \"$localACCOUNT\"."
		updateACCOUNT="$localACCOUNT"
		updateKEYCHAIN="$localKEYCHAIN"
		checkLocalUpdateAccount
		if [[ "$accountERROR" != "TRUE" ]]; then
			sendToLog "Starter: Validated saved credentials for local account \"$localACCOUNT\"."
			localCREDENTIAL="TRUE"
		else
			sendToLog "Exit: Unable to validate saved credentials for local account \"$localACCOUNT\"."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: Unable to retrieve password for saved local account \"$localACCOUNT\"."; parameterERROR="TRUE"
	fi
fi

# On Apple Silicon, if there is a previously saved super service account (that wasn't just deleted), validate the account and set $superACCOUNT and $superPASSWORD.
if [[ "$macosARCH" == "arm64" ]] && [[ -n $superPROPERTY ]]; then
	superACCOUNT="$superPROPERTY"
	superKEYCHAIN=$(security find-generic-password -w -a "$superACCOUNT" -s "Super Service Account" /Library/Keychains/System.keychain 2> /dev/null)
	if [[ -n $superKEYCHAIN ]]; then
		sendToLog "Starter: Found saved credentials for super service account \"$superACCOUNT\"."
		updateACCOUNT="$superACCOUNT"
		updateKEYCHAIN="$superKEYCHAIN"
		checkLocalUpdateAccount
		if [[ "$accountERROR" != "TRUE" ]]; then
			sendToLog "Starter: Validated saved credentials for super service account \"$superACCOUNT\"."
			superCREDENTIAL="TRUE"
		else
			sendToLog "Exit: Unable to validate saved credentials for super service account \"$superACCOUNT\"."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: Unable to retrieve password for saved super service account \"$superACCOUNT\"."; parameterERROR="TRUE"
	fi
fi

# If there is a previously saved Jamf PRO API account (that wasn't just deleted), validate the account and set $jamfACCOUNT and $jamfPASSWORD.
if [[ -n $jamfPROPERTY ]]; then
	jamfACCOUNT="$jamfPROPERTY"
	jamfKEYCHAIN=$(security find-generic-password -w -a "$jamfACCOUNT" -s "Super MDM Account" /Library/Keychains/System.keychain 2> /dev/null)
	if [[ -n $jamfKEYCHAIN ]]; then
		sendToLog "Starter: Found saved credentials for Jamf Pro API account \"$jamfACCOUNT\"."
		getJamfProServer
		if [[ "$jamfSERVER" != "FALSE" ]]; then
			getJamfProAccount
			if [[ "$jamfERROR" != "TRUE" ]]; then
				sendToLog "Starter: Validated saved credentials for Jamf Pro API account \"$jamfACCOUNT\"."
				if [[ $(profiles status -type bootstraptoken 2> /dev/null | grep "YES" -c) -eq 2 ]]; then
					sendToLog "Starter: Bootstrap token escrow validated."
					jamfCREDENTIAL="TRUE"
				else
					sendToLog "Exit: Can not use MDM update workflow because this computer's Bootstrap token is not escrowed."; parameterERROR="TRUE"
				fi
			else
				parameterERROR="TRUE"
			fi
		else
			sendToLog "Exit: Unable to connect to Jamf Pro to validate user account."; parameterERROR="TRUE"
		fi
	else
		sendToLog "Exit: Unable to retrieve password for saved Jamf Pro API account \"$jamfACCOUNT\"."; parameterERROR="TRUE"
	fi
fi
}

######## FUNCTIONS - STARTUP ########

# Download and install the IBM Notifier.app.
getIbmNotifier() {
ibmNotifierVALID="FALSE"
sendToLog "Installer: Attempting to download and install IBM Notifier.app..."
downloadRESULT=$(curl "$ibmNotifierURL" -L -o "/tmp/IBM.Notifier.zip" 2>&1)
if [[ -f "/tmp/IBM.Notifier.zip" ]]; then
	unzipRESULT=$(unzip "/tmp/IBM.Notifier.zip" -d "$superFOLDER/" 2>&1)
	if [[ -d "$ibmNotifierAPP" ]]; then
		[[ -d "$superFOLDER/__MACOSX" ]] && rm -Rf "$superFOLDER/__MACOSX" > /dev/null 2>&1
		chmod -R a+rx "$ibmNotifierAPP"
		ibmNotifierVALID="TRUE"
	else
		sendToLog "Warning: Unable to install IBM Notifier.app."
		sendToLog "Verbose Mode: unzipRESULT: \n$unzipRESULT"
	fi
else
	sendToLog "Warning: Unable to download IBM Notifier.app from: $ibmNotifierURL"
	sendToLog "Verbose Mode: downloadRESULT: \n$downloadRESULT"
fi
}


# Check the IBM Notifier.app for validity.
checkIbmNotifier() {
ibmNotifierVALID="FALSE"
ibmNotifierCODESIGN=$(codesign --verify --verbose "$ibmNotifierAPP" 2>&1)
if [[ $(echo "$ibmNotifierCODESIGN" | grep -c "valid on disk") -eq 1 ]]; then
	ibmNotifierRESULT=$(defaults read "$ibmNotifierAPP/Contents/Info.plist" CFBundleShortVersionString)
	if [[ "$ibmNotifierVERSION" == "$ibmNotifierRESULT" ]]; then
		ibmNotifierVALID="TRUE"
	else
		sendToLog "Warning: IBM Notifier at path: $ibmNotifierAPP is version $ibmNotifierRESULT, this does not match target version $ibmNotifierVERSION"
	fi
else
	sendToLog "Warning: unable validate signature for IBM Notifier at path: $ibmNotifierAPP."
	sendToLog "Verbose Mode: ibmNotifierCODESIGN: \n$ibmNotifierCODESIGN"
fi
}

# Install items required by super.
superInstaller() {
# Figure out where super is running from and start Installer log if anything needs to be installed.
superPATH="$(dirname "$0")"
{ [[ ! -d "$superFOLDER" ]] || [[ ! -d "$ibmNotifierAPP" ]] || ! { [[ "$superPATH" == "$superFOLDER" ]] || [[ "$superPATH" == "$(dirname "$superLINK")" ]]; } } && sendToLog "**** S.U.P.E.R.M.A.N. INSTALLER ****"

# Make sure the $superFOLDER exists.
if [[ ! -d "$superFOLDER" ]]; then
	mkdir -p "$superFOLDER"
	sendToLog "Installer: Made working folder: $superFOLDER"
fi

# Validate the IBM Notifier.app, if missing or invalid then install and check again.
if [[ "$macosMAJOR" != "10" ]] || { [[ "$macosMAJOR" == "10" ]] && [[ "$macosMINOR" -ge 15 ]]; }; then
	if [[ ! -d "$ibmNotifierAPP" ]]; then
		getIbmNotifier
		[[ -d "$ibmNotifierAPP" ]] && checkIbmNotifier
		[[ "$ibmNotifierVALID" == "FALSE" ]] && sendToLog "Warning: Unable to validate IBM Notifier.app after installation, will attempt fallback to jamfHelper."
	else
		checkIbmNotifier
		if [[ "$ibmNotifierVALID" == "FALSE" ]]; then
			sendToLog "Installer: Removing existing IBM Notifier.app."
			rm -Rf "$ibmNotifierAPP" > /dev/null 2>&1
			[[ -d "$superFOLDER/__MACOSX" ]] && rm -Rf "$superFOLDER/__MACOSX" > /dev/null 2>&1
			getIbmNotifier
			[[ -d "$ibmNotifierAPP" ]] && checkIbmNotifier
		fi
		[[ "$ibmNotifierVALID" == "FALSE" ]] && sendToLog "Warning: Unable to validate IBM Notifier.app after re-installation, will attempt fallback to jamfHelper."
	fi
else
	sendToLog "Warning: IBM Notifier.app is not compatible with this version of macOS, will attempt fallback to jamfHelper."
	ibmNotifierVALID="FALSE"
fi

# Install super if it's running from any location that is not in the $superFOLDER or from the $superLINK.
if ! { [[ "$superPATH" == "$superFOLDER" ]] || [[ "$superPATH" == "$(dirname "$superLINK")" ]]; }; then
	sendToLog "Installer: Copying file: $superFOLDER/super"
	cp "$0" "$superFOLDER/super" > /dev/null 2>&1
	sendToLog "Installer: Creating default path link: $superLINK"
	ln -s "$superFOLDER/super" "$superLINK" > /dev/null 2>&1
	sendToLog "Installer: Creating file: $superFOLDER/super-starter"
/bin/cat <<EOSS > "$superFOLDER/super-starter"
#!/bin/sh
echo "\$(date +"%a %b %d %T") \$(hostname -s) \$(basename "\$0")[\$\$]: **** S.U.P.E.R.M.A.N. LAUNCHDAEMON ****" | tee -a "$superLOG"
"$superFOLDER/super" "\$@" &
disown
exit 0
EOSS
	[[ "$macosVERSION" -ge 1105 ]] && touch "$mdmLOG"
	[[ "$macosMAJOR" -gt 10 ]] && touch "$updateLOG"
	sendToLog "Installer: Setting permissions in: $superFOLDER"
	chown -R root:wheel "$superFOLDER"
	chown root:wheel "$superLINK"
	chmod -R a+r "$superFOLDER"
	chmod a+r "$superLINK"
	chmod a+x "$superFOLDER/super"
	chmod a+x "$superFOLDER/super-starter"
	chmod a+x "$superLINK"
	sendToLog "**** S.U.P.E.R.M.A.N. INSTALLER END ****"
fi
}

# Prepare super by cleaning after previous super runs, record various maintenance modes, validate parameters, and liberate super from Jamf Policy runs.
superStarter() {
# Check for any previous super process still running, if so kill it.
if [[ -f "$superPIDFILE" ]]; then
	previousPID=$(cat "$superPIDFILE")
	sendToLog "Starter: Found previous super instance running with PID $previousPID, killing..."
	kill -9 "$previousPID" > /dev/null 2>&1
fi

# Kill any already running helper processes.
killall -9 "softwareupdate" > /dev/null 2>&1
killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
killall -9 "jamfHelper" > /dev/null 2>&1

# Create $superPIDFILE for this instance of super.
echo $$ > "$superPIDFILE"

# This unloads and deletes any previous LaunchDaemons.
if [[ -f "/Library/LaunchDaemons/$launchDaemonNAME.plist" ]]; then
	sendToLog "Starter: Deleting previous LaunchDaemon $launchDaemonNAME.plist."
	launchctl bootout system "/Library/LaunchDaemons/$launchDaemonNAME.plist" 2> /dev/null
	rm -f "/Library/LaunchDaemons/$launchDaemonNAME.plist"
fi

# Manage the $verboseModeOPTION and if enabled start additional logging.
if [[ $verboseModeOPTION -eq 1 ]] || [[ "$verboseModeOPTION" == "TRUE" ]]; then
	verboseModeOPTION="TRUE"
	defaults write "$superPLIST" VerboseMode -bool "$verboseModeOPTION"
else
	verboseModeOPTION="FALSE"
	defaults delete "$superPLIST" VerboseMode 2> /dev/null
fi
if [[ "$verboseModeOPTION" == "TRUE" ]]; then
	sendToLog "Starter: Verbose mode enabled."
	sendToLog "Starter: Uptime: $(uptime)"
	sendToLog "Starter: Managed preference file $superMANAGEDPLIST:\n$(defaults read "$superMANAGEDPLIST" 2> /dev/null)"
	sendToLog "Starter: Local preference file before validation $superPLIST:\n$(defaults read "$superPLIST" 2> /dev/null)"
fi

# Parameter and saved credential validation and management.
checkCurrentUser
manageParameters
manageUpdateCredentials
if [[ "$parameterERROR" == "TRUE" ]]; then
	[[ -n "$jamfProTOKEN" ]] && deleteJamfProServerToken
	rm -f "$superPIDFILE"
	sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
	exit 1
fi

# Workflow for for $openLOGS.
if [[ "$openLOGS" == "TRUE" ]]; then
	if [[ "$currentUSER" != "FALSE" ]]; then
		sendToLog "Starter: Opening logs for user $currentUSER..."
		sudo -u "$currentUSER" open "$superLOG" &
		if [[ "$macosMAJOR" != "10" ]]; then
			{ [[ "$jamfCREDENTIAL" == "TRUE" ]] && { [[ "$localCREDENTIAL" != "TRUE" ]] || [[ "$superCREDENTIAL" != "TRUE" ]]; } } && sudo -u "$currentUSER" open "$mdmLOG" &
			sudo -u "$currentUSER" open "$updateLOG" &
		fi
	else
		sendToLog "Starter: Open logs request denied because there is currently no local user logged into the GUI."
	fi
fi

# Feedback for various alternate workflow modes.
[[ "$preferJamfOPTION" == "TRUE" ]] && sendToLog "Starter: Prefer jamfHelper mode enabled."
[[ "$skipUpdatesOPTION" == "TRUE" ]] && sendToLog "Starter: Skip Apple software udates mode enabled."
[[ "$forceRestartOPTION" == "TRUE" ]] && sendToLog "Starter: Forced restart mode enabled."
[[ "$testModeOPTION" == "TRUE" ]] && sendToLog "Starter: Test mode enabled with $testModeTIMEOUT second timeout."
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Starter: Local preference file after validation $superPLIST:\n$(defaults read "$superPLIST" 2> /dev/null)"
[[ "$verboseModeOPTION" == "TRUE" ]] && logParameters

# If super is running via Jamf, then restsart via LaunchDaemon to release the jamf process.
# This is late in the starter workflow so as to only create a valid LaunchDaemon after parameter validation and housekeeping.
if [[ $1 == "/" ]] || [[ $(ps -p "$PPID" | awk '{print $4;}' | grep -c "jamf") -gt 0 ]]; then
	sendToLog "Starter: Found that Jamf is installing or is the parent process, restarting with new LaunchDaemon..."
	makeLaunchDaemonRestartNow
fi
# If super is running from outside the $superFOLDER, then restsart via LaunchDaemon to release any parent installer process.
if ! { [[ "$superPATH" == "$superFOLDER" ]] || [[ "$superPATH" == "$(dirname "$superLINK")" ]]; }; then
	sendToLog "Starter: Found that super is installing, restarting with new LaunchDaemon..."
	makeLaunchDaemonRestartNow
fi

# Make sure we have a network connection before moving on.
# If there is still no network after two minutes, an automatic deferral is started.
networkTIMEOUT=0
while [[ $(ifconfig -a inet 2>/dev/null | sed -n -e '/127.0.0.1/d' -e '/0.0.0.0/d' -e '/inet/p' | wc -l) -le 0 ]] && [[ $networkTIMEOUT -lt 120 ]]; do
	sendToLog "Starter: Waiting for network..."
	sleep 5
	networkTIMEOUT=$((networkTIMEOUT + 5))
done
if [[ $(ifconfig -a inet 2>/dev/null | sed -n -e '/127.0.0.1/d' -e '/0.0.0.0/d' -e '/inet/p' | wc -l) -le 0 ]]; then
	sendToLog "Starter: Network unavailalbe, trying again in $defaultDeferSECONDS seconds."
	makeLaunchDaemonCalendar
fi

# If super is running after an update restart and set $updateVALIDATE appropriately.
[[ $(defaults read "$superPLIST" UpdateValidate 2> /dev/null) ]] && updateVALIDATE="TRUE"
}

######## FUNCTIONS - LOGGING ########

# Append input to a log located at $superLOG.
sendToLog() {
echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: $*" | tee -a "$superLOG"
}

# Append input to the command line only, so as not to save secrets to the $superLOG.
sendToEcho() {
echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: Not Logged: $*"
}

# Log any parameters that have values.
logParameters() {
sendToLog "Verbose Mode: macosVERSION: $macosVERSION"
sendToLog "Verbose Mode: macosARCH: $macosARCH"
sendToLog "Verbose Mode: jamfVERSION: $jamfVERSION"
[[ -n $jamfSERVER ]] && sendToLog "Verbose Mode: jamfSERVER: $jamfSERVER"
[[ -n $ibmNotifierVALID ]] && sendToLog "Verbose Mode: ibmNotifierVALID: $ibmNotifierVALID"
[[ -n $defaultDeferSECONDS ]] && sendToLog "Verbose Mode: defaultDeferSECONDS: $defaultDeferSECONDS"
[[ -n $focusDeferSECONDS ]] && sendToLog "Verbose Mode: focusDeferSECONDS: $focusDeferSECONDS"
[[ -n $menuDeferSECONDS ]] && sendToLog "Verbose Mode: menuDeferSECONDS: $menuDeferSECONDS"
[[ -n $recheckDeferSECONDS ]] && sendToLog "Verbose Mode: recheckDeferSECONDS: $recheckDeferSECONDS"
[[ -n $focusCountMAX ]] && sendToLog "Verbose Mode: focusCountMAX: $focusCountMAX"
[[ -n $softCountMAX ]] && sendToLog "Verbose Mode: softCountMAX: $softCountMAX"
[[ -n $hardCountMAX ]] && sendToLog "Verbose Mode: hardCountMAX: $hardCountMAX"
[[ -n $focusDaysMAX ]] && sendToLog "Verbose Mode: focusDaysMAX: $focusDaysMAX"
[[ -n $softDaysMAX ]] && sendToLog "Verbose Mode: softDaysMAX: $softDaysMAX"
[[ -n $hardDaysMAX ]] && sendToLog "Verbose Mode: hardDaysMAX: $hardDaysMAX"
[[ -n $zeroDayOVERRIDE ]] && sendToLog "Verbose Mode: zeroDayOVERRIDE: $zeroDayOVERRIDE"
[[ -n $focusDateMAX ]] && sendToLog "Verbose Mode: focusDateMAX: $focusDateMAX"
[[ -n $softDateMAX ]] && sendToLog "Verbose Mode: softDateMAX: $softDateMAX"
[[ -n $hardDateMAX ]] && sendToLog "Verbose Mode: hardDateMAX: $hardDateMAX"
[[ -n $displayTimeoutSECONDS ]] && sendToLog "Verbose Mode: displayTimeoutSECONDS: $displayTimeoutSECONDS"
[[ -n $displayRedrawSECONDS ]] && sendToLog "Verbose Mode: displayRedrawSECONDS: $displayRedrawSECONDS"
[[ -n $ibmNotifierIconSIZE ]] && sendToLog "Verbose Mode: ibmNotifierIconSIZE: $ibmNotifierIconSIZE"
[[ -n $jamfHelperIconSIZE ]] && sendToLog "Verbose Mode: jamfHelperIconSIZE: $jamfHelperIconSIZE"
[[ -n $preferJamfOPTION ]] && sendToLog "Verbose Mode: preferJamfOPTION: $preferJamfOPTION"
[[ -n $localOPTION ]] && sendToLog "Verbose Mode: localOPTION: $localOPTION"
[[ -n $localPASSWORD ]] && sendToEcho "Verbose Mode: localPASSWORD: $localPASSWORD"
[[ -n $localACCOUNT ]] && sendToLog "Verbose Mode: localACCOUNT: $localACCOUNT"
[[ -n $localKEYCHAIN ]] && sendToEcho "Verbose Mode: localKEYCHAIN: $localKEYCHAIN"
[[ -n $localCREDENTIAL ]] && sendToLog "Verbose Mode: localCREDENTIAL: $localCREDENTIAL"
[[ -n $adminACCOUNT ]] && sendToLog "Verbose Mode: adminACCOUNT: $adminACCOUNT"
[[ -n $adminPASSWORD ]] && sendToEcho "Verbose Mode: adminPASSWORD: $adminPASSWORD"
[[ -n $superOPTION ]] && sendToLog "Verbose Mode: superOPTION: $superOPTION"
[[ -n $superPASSWORD ]] && sendToEcho "Verbose Mode: superPASSWORD: $superPASSWORD"
[[ -n $superACCOUNT ]] && sendToLog "Verbose Mode: superACCOUNT: $superACCOUNT"
[[ -n $superKEYCHAIN ]] && sendToEcho "Verbose Mode: superKEYCHAIN: $superKEYCHAIN"
[[ -n $superCREDENTIAL ]] && sendToLog "Verbose Mode: superCREDENTIAL: $superCREDENTIAL"
[[ -n $JamfProID ]] && sendToLog "Verbose Mode: JamfProID: $JamfProID"
[[ -n $jamfOPTION ]] && sendToLog "Verbose Mode: jamfOPTION: $jamfOPTION"
[[ -n $jamfPASSWORD ]] && sendToEcho "Verbose Mode: jamfPASSWORD: $jamfPASSWORD"
[[ -n $jamfACCOUNT ]] && sendToLog "Verbose Mode: jamfACCOUNT: $jamfACCOUNT"
[[ -n $jamfKEYCHAIN ]] && sendToEcho "Verbose Mode: jamfKEYCHAIN: $jamfKEYCHAIN"
[[ -n $jamfCREDENTIAL ]] && sendToLog "Verbose Mode: jamfCREDENTIAL: $jamfCREDENTIAL"
[[ -n $deleteACCOUNTS ]] && sendToLog "Verbose Mode: deleteACCOUNTS: $deleteACCOUNTS"
[[ -n $policyTRIGGERS ]] && sendToLog "Verbose Mode: policyTRIGGERS: $policyTRIGGERS"
}

######## FUNCTIONS - JAMF PRO API ########

# Validate the connection to a managed computer's Jamf Pro service and set $jamfSERVER accordingly.
getJamfProServer() {
jamfSTATUS=$("$jamfBINARY" checkJSSConnection -retry 1)
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: jamfSTATUS is: $jamfSTATUS"
if [[ $(echo "$jamfSTATUS" | grep -c "available") -ne 0 ]]; then
	jamfSERVER=$(defaults read /Library/Preferences/com.jamfsoftware.jamf.plist jss_url)
else
	jamfSERVER="FALSE"
	sendToLog "Status: Jamf Pro service unavaiable."
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: jamfSERVER is: $jamfSERVER"
}

# Attempt to acquire a Jamf Pro $jamfProTOKEN via $jamfACCOUNT and $jamfKEYCHAIN credentials.
getJamfProToken() {
if [[ "$macosMAJOR" -eq 10 ]] || [[ "$macosMAJOR" -eq 11 ]]; then
	jamfProTOKEN=$(curl -X POST -u "$jamfACCOUNT:$jamfKEYCHAIN" -s "${jamfSERVER}api/v1/auth/token" | python -c 'import sys, json; print json.load(sys.stdin)["token"]')
else
	jamfProTOKEN=$(curl -X POST -u "$jamfACCOUNT:$jamfKEYCHAIN" -s "${jamfSERVER}api/v1/auth/token" | plutil -extract token raw -)
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: jamfProTOKEN is: \n$jamfProTOKEN"
}

# Validate that the account $jamfACCOUNT and $jamfKEYCHAIN are valid credentials and has appropriate permissions to send MDM commands. If not set $jamfERROR.
getJamfProAccount() {
getJamfProToken
if [[ -n $jamfProTOKEN ]]; then
	getJamfProComputerID
	if [[ -n $jamfProID ]]; then
		sendBlankPush
			if [[ $commandRESULT != 201 ]]; then
				sendToLog "Exit: Unable to request Blank Push via Jamf Pro API user account \"$jamfACCOUNT\". Verify this account has has the privileges \"Jamf Pro Server Objects > Computers > Create & Read\"."; jamfERROR="TRUE"
			fi
	else
		sendToLog "Exit: Unable to acquire Jamf Pro ID for computer with UDID \"$computerUDID\". Verify that this computer is enrolled in Jamf Pro."
		sendToLog "Exit: Also verify that the Jamf Pro API account \"$jamfACCOUNT\" has the privileges \"Jamf Pro Server Objects > Computers > Create & Read\"."; jamfERROR="TRUE"
	fi
else
	sendToLog "Exit: Unable to acquire authentication token via Jamf Pro API user account \"$jamfACCOUNT\". Verify account name and password."; jamfERROR="TRUE"
fi
}

# Use $jamfProIdMANAGED or $jamfProTOKEN to find the computer's Jamf Pro ID and set $jamfProID.
getJamfProComputerID() {
computerUDID=$(system_profiler SPHardwareDataType | awk '/UUID/ { print $3; }')
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: computerUDID is: $computerUDID"
if [[ -n $jamfProIdMANAGED ]]; then
	jamfProID="$jamfProIdMANAGED"
else
	sendToLog "Warning: Using a Jamf Pro API account with \"Computers > Read\" privileges to collect the computer ID is a security risk. Instead use a custom Configuration Profile with the following; Preference Domain \"com.macjutsu.super\", Key \"JamfProID\", String \"\$JSSID\"."
	jamfProID=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --header "Accept: application/xml" --request GET --url "${jamfSERVER}JSSResource/computers/udid/${computerUDID}/subset/General" 2> /dev/null | xpath -e /computer/general/id 2>&1 | awk -F'<id>|</id>' '{print $2}' | xargs)
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: jamfProID is: $jamfProID"
}

# Attempt to send a Blank Push to Jamf Pro.
sendBlankPush() {
commandRESULT=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --write-out "%{http_code}" --silent --output /dev/null --request POST --url "${jamfSERVER}JSSResource/computercommands/command/BlankPush/id/${jamfProID}")
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: commandRESULT is: \n$commandRESULT"
}

# Validate $jamfProTOKEN and if found invalid, a new token is requested and again validated.
checkJamfProServerToken() {
tokenCHECK=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --write-out "%{http_code}" --silent --output /dev/null --request GET --url "${jamfSERVER}api/v1/auth")
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: tokenCHECK is: $tokenCHECK"
if [[ $tokenCHECK -ne 200 ]]; then
	getJamfProToken
	tokenCHECK=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --write-out "%{http_code}" --silent --output /dev/null --request GET --url "${jamfSERVER}api/v1/auth")
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: tokenCHECK is: $tokenCHECK"
	if [[ $tokenCHECK -ne 200 ]]; then
		sendToLog "Exit: Could not retrieve Jamf Pro API token for account \"$jamfACCOUNT\", verify account credentials."
		[[ -n "$jamfProTOKEN" ]] && deleteJamfProServerToken
		rm -f "$superPIDFILE"
		sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
		exit 1
	fi
fi
}

# Invalidate and remove from local memory the $jamfProTOKEN.
deleteJamfProServerToken() {
invalidateTOKEN=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --write-out "%{http_code}" --silent --output /dev/null --request POST --url "${jamfSERVER}api/v1/auth/invalidate-token")
if [[ $invalidateTOKEN -eq 204 ]]; then
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: Jamf Pro API token successfully invalidated."
	unset jamfProTOKEN
elif [[ $invalidateTOKEN -eq 401 ]]; then
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: Jamf Pro API token already invalid."
	unset jamfProTOKEN
else
	sendToLog "Error: Invalidating Jamf Pro API token."
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: invalidateTOKEN is: $invalidateTOKEN"
fi
}

######## FUNCTIONS - EVALUATE CONDITIONS ########

# Verify that super is running with root privileges.
checkRoot() {
if [[ "$(id -u)" -ne 0 ]]; then
	sendToEcho "Exit: $(basename "$0") must run with root privleges."
	exit 1
fi
}

# Set $currentUSER and $currentUID to the currently logged in GUI user or "FALSE" if there is none or a system account.
checkCurrentUser() {
currentUSER=$(scutil <<< "show State:/Users/ConsoleUser" | awk '/Name :/ { print $3 }')
if [[ -z $currentUSER ]]; then
	sendToLog "Status: No GUI user currently logged in."
	currentUSER="FALSE"
	currentUID="FALSE"
elif [[ "$currentUSER" = "root" ]] || [[ "$currentUSER" = "_mbsetupuser" ]] || [[ "$currentUSER" = "loginwindow" ]]; then
	sendToLog "Status: Current GUI user is system account $currentUSER."
	currentUSER="FALSE"
	currentUID="0"
else
	currentUID=$(id -u "$currentUSER")
	sendToLog "Status: Current GUI user is $currentUSER with a UID of $currentUID."
fi
}

# Validate that the account $updateACCOUNT and $updateKEYCHAIN are valid credentials is a volume owner. If not set $accountERROR.
checkLocalUpdateAccount() {
accountGUID=$(dscl . read "/Users/$updateACCOUNT" GeneratedUID 2> /dev/null | awk '{print $2;}')
if [[ -n $accountGUID ]]; then
	if ! [[ $(diskutil apfs listcryptousers / | grep -c "$accountGUID") -ne 0 ]]; then
		sendToLog "Exit: Provided account \"$updateACCOUNT\" is not a system volume owner."; accountERROR="TRUE"
	fi
	accountVALID=$(dscl /Local/Default -authonly "$updateACCOUNT" "$updateKEYCHAIN" 2>&1)
	if ! [[ "$accountVALID" == "" ]];then
		sendToLog "Exit: The provided password for account \"$updateACCOUNT\" is not valid."; accountERROR="TRUE"
	fi
else
	sendToLog "Exit: Could not retrieve GUID for account \"$updateACCOUNT\". Verify that account exists locally."; accountERROR="TRUE"
fi
}

# Delete the maximum deferral counters in $superPLIST to restart the counters.
restartZeroDay() {
sendToLog "Status: Restarting automaticly set zero day date."
defaults delete "$superPLIST" ZeroDayAuto 2> /dev/null
}

# Delete the maximum deferral counters in $superPLIST to restart the counters.
restartDeferralCounters() {
sendToLog "Status: Restarting maximum deferral counters."
defaults delete "$superPLIST" FocusCounter 2> /dev/null
defaults delete "$superPLIST" SoftCounter 2> /dev/null
defaults delete "$superPLIST" HardCounter 2> /dev/null
}

# Evaluate $zeroDayOVERRIDE and $zeroDayPREVIOUS, then set $zeroDaySTART, $zeroDayEPOCH, and $zeroDayDISPLAY accordingly.
checkZeroDay() {
if [[ -n $zeroDayOVERRIDE ]]; then # If there is a $zeroDayOVERRIDE then use that first.
	zeroDaySTART="$zeroDayOVERRIDE"
	sendToLog "Status: Using manualy set zero day date of $zeroDaySTART."
else
	zeroDayPREVIOUS=$(defaults read "$superPLIST" ZeroDayAuto 2> /dev/null)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: zeroDayPREVIOUS: $zeroDayPREVIOUS"
	if [[ -n $zeroDayPREVIOUS ]]; then # If there was a previously saved zero day date then use that.
		zeroDaySTART="$zeroDayPREVIOUS"
		sendToLog "Status: Using previously set automatic zero day date of $zeroDaySTART."
	else # Otherwise this is a new zero day date, so save to $superPLIST.
		zeroDaySTART=$(date +"%Y-%m-%d:%H:%M")
		sendToLog "Status: Setting new automatic day zero date to $zeroDaySTART."
		defaults write "$superPLIST" ZeroDayAuto -string "$zeroDaySTART"
	fi
fi
zeroDayEPOCH=$(date -j -f "%Y-%m-%d:%H:%M" "$zeroDaySTART" +"%s")
zeroDayDATE=$(date -r "$zeroDayEPOCH" "$dateFORMAT")
zeroDayTIME=$(date -r "$zeroDayEPOCH" "$timeFORMAT" | sed 's/^ *//g')
if [[ $(date -r "$zeroDayEPOCH" "+%H:%M") == "00:00" ]]; then
	zeroDayDISPLAY="$zeroDayDATE"
else
	zeroDayDISPLAY="$zeroDayDATE - $zeroDayTIME"
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: zeroDayEPOCH: $zeroDayEPOCH"
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: zeroDayDATE: $zeroDayDATE"
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: zeroDayTIME: $zeroDayTIME"
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: zeroDayDISPLAY: $zeroDayDISPLAY"
}

# Evaluate if a process has told the display to not sleep or the user has enabled Focus or Do Not Disturb, and set $focusDEFER accordingly.
checkUserFocus() {
focusDEFER="FALSE"
if [[ -n $focusDeferSECONDS ]]; then
	if [[ $macosMAJOR -eq 10 ]]; then
		focusSTATUS=$(sudo -u "$currentUSER" defaults -currentHost read "/Users/$currentUSER/Library/Preferences/ByHost/com.apple.notificationcenterui" doNotDisturb 2>/dev/null)
	elif [[ $macosMAJOR -eq 11 ]]; then
		focusSTATUS=$(plutil -extract dnd_prefs xml1 -o - "/Users/$currentUSER/Library/Preferences/com.apple.ncprefs.plist" | xmllint --xpath "string(//data)" - | base64 --decode | plutil -convert xml1 - -o - | grep -ic userPref)
	else
		focusSTATUS=$(plutil -extract data.0.storeAssertionRecords.0.assertionDetails.assertionDetailsModeIdentifier raw -o - "/Users/$currentUSER/Library/DoNotDisturb/DB/Assertions.json" | grep -ic com.apple.)
	fi
	if [[ $focusSTATUS -gt 0 ]]; then
		sendToLog "Status: Focus or Do Not Disturb enabled for user $currentUSER."
		focusDEFER="TRUE"
	fi
	oldIFS="$IFS"; IFS=$'\n'
	displayASSERTIONS=($(pmset -g assertions | awk '/NoDisplaySleepAssertion | PreventUserIdleDisplaySleep/ && match($0,/\(.+\)/) && ! /coreaudiod/ {gsub(/^\ +/,"",$0); print};'))
	if [[ -n ${displayASSERTIONS[*]} ]]; then
		for assertionITEM in "${displayASSERTIONS[@]}"; do
			sendToLog "Status: The following Display Sleep Assertions found: $(echo "${assertionITEM}" | awk -F: '{print $1}')"
		done
		focusDEFER="TRUE"
	fi
	IFS="$oldIFS"
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: focusDEFER is: $focusDEFER"
}

# Evaluate $focusDateMAX, $softDateMAX, and $hardDateMAX, then set $deadlineDateSTATUS, $deadlineDateEPOCH, and $deadlineDateDISPLAY accordingly.
checkDateDeadlines() {
deadlineDateSTATUS="FALSE"
if [[ -n $focusDateMAX ]]; then
	if [[ $focusDateEPOCH -lt $(date +%s) ]]; then
		sendToLog "Status: Focus date deadline of $focusDateMAX HAS passed."
		deadlineDateSTATUS="FOCUS"
	else
		sendToLog "Status: Focus date deadline of $focusDateMAX NOT passed."
	fi
fi
if [[ -n $softDateMAX ]]; then
	if [[ $softDateEPOCH -lt $(date +%s) ]]; then
		sendToLog "Status: Soft date deadline of $softDateMAX HAS passed."
		deadlineDateSTATUS="SOFT"
	else
		sendToLog "Status: Soft date deadline of $softDateMAX NOT passed."
	fi
fi
if [[ -n $hardDateMAX ]]; then
	if [[ $hardDateEPOCH -lt $(date +%s) ]]; then
		sendToLog "Status: Hard date deadline of $hardDateMAX HAS passed."
		deadlineDateSTATUS="HARD"
	else
		sendToLog "Status: Hard date deadline of $hardDateMAX NOT passed."
	fi
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineDateSTATUS is: $deadlineDateSTATUS"

# For display the $softDateMAX will always result in a sooner date than the $hardDateMAX.
[[ -n $hardDateMAX ]] && deadlineDateEPOCH="$hardDateEPOCH"
[[ -n $softDateMAX ]] && deadlineDateEPOCH="$softDateEPOCH"
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineDateEPOCH is: $deadlineDateEPOCH"
if [[ -n $deadlineDateEPOCH ]]; then
	deadlineDateDATE=$(date -r "$deadlineDateEPOCH" "$dateFORMAT")
	deadlineDateTIME=$(date -r "$deadlineDateEPOCH" "$timeFORMAT" | sed 's/^ *//g')
	if [[ $(date -r "$deadlineDateEPOCH" "+%H:%M") == "00:00" ]]; then
		deadlineDateDISPLAY="$deadlineDateDATE"
	else
		deadlineDateDISPLAY="$deadlineDateDATE - $deadlineDateTIME"
	fi
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineDateDATE is: $deadlineDateDATE"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineDateTIME is: $deadlineDateTIME"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineDateDISPLAY is: $deadlineDateDISPLAY"
fi
}

# Evaluate $focusDaysMAX, $softDaysMAX, and $hardDaysMAX, then set $deadlineDaysSTATUS, $deadlineDaysEPOCH, and $deadlineDaysDISPLAY accordingly.
checkDaysDeadlines() {
deadlineDaysSTATUS="FALSE"
if [[ -n $focusDaysMAX ]]; then
	focusDaysEPOCH=$((zeroDayEPOCH + focusDaysSECONDS))
	focusDaysDATE=$(date -r "$focusDaysEPOCH" +%Y-%m-%d:%H:%M)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: focusDaysEPOCH: $focusDaysEPOCH"
	if [[ $focusDaysEPOCH -lt $(date +%s) ]]; then
		sendToLog "Status: Focus days deadline of $focusDaysDATE ($focusDaysMAX day(s) after $zeroDaySTART) HAS passed."
		deadlineDaysSTATUS="FOCUS"
	else
		sendToLog "Status: Focus days deadline of $focusDaysDATE ($focusDaysMAX day(s) after $zeroDaySTART) NOT passed."
	fi
fi
if [[ -n $softDaysMAX ]]; then
	softDaysEPOCH=$((zeroDayEPOCH + softDaysSECONDS))
	softDaysDATE=$(date -r "$softDaysEPOCH" +%Y-%m-%d:%H:%M)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: softDaysEPOCH: $softDaysEPOCH"
	if [[ $softDaysEPOCH -lt $(date +%s) ]]; then
		sendToLog "Status: Soft days deadline of $softDaysDATE ($softDaysMAX day(s) after $zeroDaySTART) HAS passed."
		deadlineDaysSTATUS="SOFT"
	else
		sendToLog "Status: Soft days deadline of $softDaysDATE ($softDaysMAX day(s) after $zeroDaySTART) NOT passed."
	fi
fi
if [[ -n $hardDaysMAX ]]; then
	hardDaysEPOCH=$((zeroDayEPOCH + hardDaysSECONDS))
	hardDaysDATE=$(date -r "$hardDaysEPOCH" +%Y-%m-%d:%H:%M)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: hardDaysEPOCH: $hardDaysEPOCH"
	if [[ $hardDaysEPOCH -lt $(date +%s) ]]; then
		sendToLog "Status: Hard days deadline of $hardDaysDATE ($hardDaysMAX day(s) after $zeroDaySTART) HAS passed."
		deadlineDaysSTATUS="HARD"
	else
		sendToLog "Status: Hard days deadline of $hardDaysDATE ($hardDaysMAX day(s) after $zeroDaySTART) NOT passed."
	fi
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineDaysSTATUS is: $deadlineDaysSTATUS"

# For display the $softDaysMAX will always result in a sooner date than the $hardDaysMAX.
[[ -n $hardDaysMAX ]] && deadlineDaysEPOCH="$hardDaysEPOCH"
[[ -n $softDaysMAX ]] && deadlineDaysEPOCH="$softDaysEPOCH"
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineDaysEPOCH is: $deadlineDaysEPOCH"
if [[ -n $deadlineDaysEPOCH ]]; then
	deadlineDaysDATE=$(date -r "$deadlineDaysEPOCH" "$dateFORMAT")
	deadlineDaysTIME=$(date -r "$deadlineDaysEPOCH" "$timeFORMAT" | sed 's/^ *//g')
	if [[ $(date -r "$deadlineDaysEPOCH" "+%H:%M") == "00:00" ]]; then
		deadlineDaysDISPLAY="$deadlineDaysDATE"
	else
		deadlineDaysDISPLAY="$deadlineDaysDATE - $deadlineDaysTIME"
	fi
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineDaysDATE is: $deadlineDaysDATE"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineDaysTIME is: $deadlineDaysTIME"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineDaysDISPLAY is: $deadlineDaysDISPLAY"
fi

# For display this sets $deadlineDISPLAY based on the soonest available date or days deadline.
if [[ -n $deadlineDateDISPLAY ]] && [[ -n $deadlineDaysDISPLAY ]]; then
	if [[ $deadlineDateEPOCH -le $deadlineDaysEPOCH ]]; then
		deadlineDISPLAY="$deadlineDateDISPLAY"
	else
		deadlineDISPLAY="$deadlineDaysDISPLAY"
	fi
elif [[ -n $deadlineDateDISPLAY ]]; then
	deadlineDISPLAY="$deadlineDateDISPLAY"
elif [[ -n $deadlineDaysDISPLAY ]]; then
	deadlineDISPLAY="$deadlineDaysDISPLAY"
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineDISPLAY is: $deadlineDISPLAY"
}

# Evaluate $focusCountMAX, $softCountMAX, and $hardCountMAX, then set $focusDEFER, $deadlineCountSTATUS, $countDISPLAY, and $countMaxDISPLAY accordingly.
checkCountDeadlines() {
deadlineCountSTATUS="FALSE"
if [[ "$focusDEFER" == "TRUE" ]]; then
	if [[ -n $focusCountMAX ]]; then
		focusCounterPREVIOUS=$(defaults read "$superPLIST" FocusCounter 2> /dev/null)
		if [[ -z $focusCounterPREVIOUS ]]; then
			sendToLog "Status: Creating new focus deferral counter in $superPLIST."
			focusCounterCURRENT=0
			defaults write "$superPLIST" FocusCounter -int $focusCounterCURRENT
		else
			focusCounterCURRENT=$((focusCounterPREVIOUS + 1))
			defaults write "$superPLIST" FocusCounter -int $focusCounterCURRENT
		fi
		if [[ $focusCounterCURRENT -ge $focusCountMAX ]]; then
			sendToLog "Status: Focus maximum deferral count of $focusCountMAX HAS passed."
			deadlineCountSTATUS="FOCUS"
			focusDEFER="FALSE"
		else
			focusCountDISPLAY=$((focusCountMAX - focusCounterCURRENT))
			sendToLog "Status: Focus maximum deferral count of $focusCountMAX NOT passed with $focusCountDISPLAY remaining."
		fi
	else
		sendToLog "Status: Focus or Do Not Disturb active, and no maximum focus deferral, so not incrementing deferral counters."
	fi
fi
if [[ "$focusDEFER" == "FALSE" ]]; then
	if [[ -n $softCountMAX ]]; then
		softCounterPREVIOUS=$(defaults read "$superPLIST" SoftCounter 2> /dev/null)
		if [[ -z $softCounterPREVIOUS ]]; then
			sendToLog "Status: Creating new soft deferral counter in $superPLIST."
			softCounterCURRENT=0
			defaults write "$superPLIST" SoftCounter -int $softCounterCURRENT
		else
			softCounterCURRENT=$((softCounterPREVIOUS + 1))
			defaults write "$superPLIST" SoftCounter -int $softCounterCURRENT
		fi
		if [[ $softCounterCURRENT -ge $softCountMAX ]]; then
			sendToLog "Status: Soft maximum deferral count of $softCountMAX HAS passed."
			deadlineCountSTATUS="SOFT"
		else
			softCountDISPLAY=$((softCountMAX - softCounterCURRENT))
			sendToLog "Status: Soft maximum deferral count of $softCountMAX NOT passed with $softCountDISPLAY remaining."
		fi
		countDISPLAY="$softCountDISPLAY"
		countMaxDISPLAY="$softCountMAX"
	fi
	if [[ -n $hardCountMAX ]]; then
		hardCounterPREVIOUS=$(defaults read "$superPLIST" HardCounter 2> /dev/null)
		if [[ -z $hardCounterPREVIOUS ]]; then
			sendToLog "Status: Creating new hard deferral counter in $superPLIST."
			hardCounterCURRENT=0
			defaults write "$superPLIST" HardCounter -int $hardCounterCURRENT
		else
			hardCounterCURRENT=$((hardCounterPREVIOUS + 1))
			defaults write "$superPLIST" HardCounter -int $hardCounterCURRENT
		fi
		if [[ $hardCounterCURRENT -ge $hardCountMAX ]]; then
			sendToLog "Status: Hard maximum deferral count of $hardCountMAX HAS passed."
			deadlineCountSTATUS="HARD"
		else
			hardCountDISPLAY=$((hardCountMAX - hardCounterCURRENT))
			sendToLog "Status: Hard maximum deferral count of $hardCountMAX NOT passed with $hardCountDISPLAY remaining."
		fi
		countDISPLAY="$hardCountDISPLAY"
		countMaxDISPLAY="$hardCountMAX"
	fi
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: deadlineCountSTATUS is: $deadlineCountSTATUS"
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: focusDEFER is: $focusDEFER"
}

######## FUNCTIONS - UPDATES ########

# Collect available Apple software updates and set $updateRESULT, $recommendedLABLES[], $updatesRECOMMENDED, $updatesRESTART, and $downloadREQUIRED accordingly.
checkAppleUpdates() {
# Collect Apple software updates list.
sendToLog "Status: Checking available Apple software updates..."
availableOSUPDATES=$(/usr/libexec/mdmclient AvailableOSUpdates 2>&1)
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: availableOSUPDATES is: \n$availableOSUPDATES"
updateRESULT=$(softwareupdate --list 2>&1)
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: updateRESULT is: $updateRESULT"

# Double-checking for false positives on macOS 11 or later.
if [[ "$macosMAJOR" != "10" ]] && [[ $(echo "$updateRESULT" | grep "No new software available." -c) -eq 1 ]]; then
	sendToLog "Status: Double-checking available Apple software updates..."
	launchctl kickstart -k system/com.apple.softwareupdated
	sleep 10
	availableOSUPDATES=$(/usr/libexec/mdmclient AvailableOSUpdates 2>&1)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: availableOSUPDATES is: \n$availableOSUPDATES"
	updateRESULT=$(softwareupdate --list 2>&1)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: updateRESULT is: $updateRESULT"

	# If no updates still reported, but there was a previously downloaded system update... then try again in 15 minutes.
	if [[ $(echo "$updateRESULT" | grep "No new software available." -c) -eq 1 ]]; then
		previousDOWNLOADS=$(defaults read "$superPLIST" UpdateDownloads 2> /dev/null)
		if [[ -n $previousDOWNLOADS ]]; then
			sendToLog "Exit: A system update was previously downloaded but the softwareupdate is not finding any available updates, trying again in 15 minutes."
			defaultDeferSECONDS=900
			makeLaunchDaemonCalendar
		fi
	fi
fi

# After checking updates parse the $updateRESULT and set $updatesRECOMMENDED, $updatesRESTART, and $downloadREQUIRED accordingly.
updatesRECOMMENDED="FALSE"
updatesRESTART="FALSE"
downloadREQUIRED="FALSE"
if [[ $(echo "$updateRESULT" | grep "No new software available." -c) -eq 1 ]]; then
	sendToLog "Status: No Apple software updates available. Some may be deferred via MDM."
else
	oldIFS="$IFS"; IFS=$'\n'
	allLABLES=()
	allTITLES=()
	restartLABLES=()
	recommendedLABLES=()
	# Parse $updateRESULT for individual update labels and save to $allLABLES[], $restartLABLES[], and $recommendedLABLES[].
	if [[ $macosMAJOR -gt 10 ]] || [[ $macosVERSION -eq 1015 ]]; then
		allLABLES=($(echo "$updateRESULT" | awk -F': ' '/Label:/{print $2}'))
		allTITLES=($(echo "$updateRESULT" | awk -F',' '/Title:/ {print $1}' | cut -d ' ' -f 2-))
		restartLABLES=($(echo "$updateRESULT" | grep -B 1 "restart" | awk -F': ' '/Label:/{print $2}'))
	else
		allLABLES=($(echo "$updateRESULT" | awk -F'*' '/\*/{print $2}' | sed 's/^ //'))
		allTITLES=($(echo "$updateRESULT" | awk -F'(' '/\t/ {print $1}' | cut -d $'\t' -f 2 | sed 's/.$//'))
		restartLABLES=($(echo "$updateRESULT" | grep -B 1 "restart" | awk -F'*' '/\*/{print $2}' | sed 's/^ //'))
	fi
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: allLABLES[] is: \n${allLABLES[*]}"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: allTITLES[] is: \n${allTITLES[*]}"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: restartLABLES[] is: \n${restartLABLES[*]}"
	[[ "${allLABLES[*]}" != "${restartLABLES[*]}" ]] && recommendedLABLES=($(echo -e "${allLABLES[*]}\n${restartLABLES[*]}" | sort | uniq -u))
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: recommendedLABLES[] is: \n${recommendedLABLES[*]}"

	# If any updates are available, send to log and evaluate download status.
	if [[ -n ${allLABLES[*]} ]]; then
		if [[ -n ${recommendedLABLES[*]} ]]; then
			sendToLog "Status: ${#recommendedLABLES[@]} available non-restart \"recommended\" software udpate(s)."
			for i in "${!recommendedLABLES[@]}"; do
				sendToLog "Status: Recommended Software Update $((i + 1)): ${recommendedLABLES[i]}"
			done
			updatesRECOMMENDED="TRUE"
		else
			sendToLog "Status: No available non-restart \"recommended\" software udpate(s). Some may be deferred via MDM."
		fi
		if [[ -n ${restartLABLES[*]} ]]; then
			sendToLog "Status: ${#restartLABLES[@]} available restart required system udpate(s)."
			for i in "${!restartLABLES[@]}"; do
				sendToLog "Status: Restart Required System Update $((i + 1)): ${restartLABLES[i]}"
			done
			updatesRESTART="TRUE"
		else
			sendToLog "Status: No available restart required system udpate(s). Some may be deferred via MDM."
		fi
		# Evaluate previously downloaded updates and compare them to currently available updates, setting $downloadREQUIRED accordingly.
		previousDOWNLOADS=$(defaults read "$superPLIST" UpdateDownloads 2> /dev/null)
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: previousDOWNLOADS is: \n$previousDOWNLOADS"
		if [[ -n $previousDOWNLOADS ]]; then
			downloadedTITLES=($(echo "$previousDOWNLOADS" | grep -wv -e '(' -e ')' | sed -e 's/    //g' -e 's/"//g' -e 's/,//g'))
			[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: downloadedTITLES is: \n${downloadedTITLES[*]}"
			if [[ ! $(echo -e "${downloadedTITLES[*]}\n${allTITLES[*]}" | sort | uniq -u) ]]; then
				sendToLog "Status: Previously downloaded update title(s) match currently available updates."
			else
				sendToLog "Status: Previously downloaded update title(s) do not match currently available updates."
				downloadREQUIRED="TRUE"
				defaults delete "$superPLIST" UpdateDownloads 2> /dev/null
				restartZeroDay
			fi
		else
			downloadREQUIRED="TRUE"
		fi
	else
		IFS="$oldIFS"
		sendToLog "Exit: Unable to parse Apple softwareupdate results."
		[[ -n "$jamfProTOKEN" ]] && deleteJamfProServerToken
		rm -f "$superPIDFILE"
		sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
		exit 1
	fi
	IFS="$oldIFS"
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: updatesRECOMMENDED is: $updatesRECOMMENDED"
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: updatesRESTART is: $updatesRESTART"
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: downloadREQUIRED is: $downloadREQUIRED"
}

# This function checks the update status after recommended/non-restart software updates are installed.
checkAfterRecommendedUpdates() {
checkAppleUpdates
if [[ "$updatesRECOMMENDED" == "TRUE" ]]; then
	# Double-checking for false positives after recommended software updates
	sendToLog "Status: Double-checking available Apple software updates..."
	launchctl kickstart -k system/com.apple.softwareupdated
	sleep 5
	availableOSUPDATES=$(/usr/libexec/mdmclient AvailableOSUpdates 2>&1)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: availableOSUPDATES is: \n$availableOSUPDATES"
	checkAppleUpdates
fi
if [[ "$updatesRECOMMENDED" == "FALSE" ]]; then
	if [[ "$jamfVERSION" != "FALSE" ]]; then
		getJamfProServer
		if [[ "$jamfSERVER" != "FALSE" ]]; then
			sendToLog "Status: Submiting updated inventory to Jamf Pro. Use \"--verbose-mode\" or check /var/log/jamf.log for more detail..."
			if [[ "$verboseModeOPTION" == "TRUE" ]]; then
				jamfRESULT=$("$jamfBINARY" recon -verbose 2>&1)
				sendToLog "Verbose Mode: jamfRESULT is: \n$jamfRESULT"
			else
				"$jamfBINARY" recon > /dev/null 2>&1
			fi
		else
			sendToLog "Status: Unable to submit inventory to Jamf Pro, continuing update workflow."
		fi
	else
		sendToLog "Status: All recommended software updates complete, but Jamf binary not present, continuing update workflow."
	fi
else
	sendToLog "Exit: All recommended software updates did not complete after attempted installation, trying again in $defaultDeferSECONDS seconds."
	makeLaunchDaemonCalendar
fi
}

# This function checks the update status after a previous super system update.
checkAfterRestartUpdates() {
checkAppleUpdates
if [[ "$updatesRECOMMENDED" == "FALSE" ]] && [[ "$updatesRESTART" == "FALSE" ]]; then
	if [[ "$jamfVERSION" != "FALSE" ]]; then
		getJamfProServer
		if [[ "$jamfSERVER" != "FALSE" ]]; then
			defaults delete "$superPLIST" UpdateValidate 2> /dev/null
			sendToLog "Status: Submiting updated inventory to Jamf Pro. Use \"--verbose-mode\" or check /var/log/jamf.log for more detail..."
			if [[ "$verboseModeOPTION" == "TRUE" ]]; then
				jamfRESULT=$("$jamfBINARY" recon -verbose 2>&1)
				sendToLog "Verbose Mode: jamfRESULT is: \n$jamfRESULT"
			else
				"$jamfBINARY" recon > /dev/null 2>&1
			fi
			sleep 5
			sendToLog "Status: Running Jamf Pro check-in policies. Use \"--verbose-mode\" or check /var/log/jamf.log for more detail..."
			if [[ "$verboseModeOPTION" == "TRUE" ]]; then
				jamfRESULT=$("$jamfBINARY" policy -verbose 2>&1)
				sendToLog "Verbose Mode: jamfRESULT is: \n$jamfRESULT"
			else
				"$jamfBINARY" policy > /dev/null 2>&1
			fi
		else
			sendToLog "Exit: Unable to submit inventory to Jamf Pro, trying again in $defaultDeferSECONDS seconds."
			makeLaunchDaemonCalendar
		fi
	else
		defaults delete "$superPLIST" UpdateValidate 2> /dev/null
		sendToLog "Status: All system updates complete, but Jamf binary not present."
	fi
else
	sendToLog "Status: Apple system updates did not complete after last restart, continuing update workflow."
fi
}

# Install only recommended/non-restart updates via the softwareupdate command, and also save results to $superLOG and $updateLOG.
installRecommendedUpdatesASU() {
# Start log streaming for softwareupdate progress and send to $updateLOG.
if [[ "$macosMAJOR" != "10" ]]; then
	sendToLog "Status: Starting softwareupdate install of recommended updates. Check $updateLOG or /var/log/install.log for more detail..."
	echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. ASU RECOMMENDED UPDATES START ****" >> "$updateLOG"
	log stream --predicate '(subsystem == "com.apple.SoftwareUpdateMacController") && (eventMessage CONTAINS[c] "reported progress")' >> "$updateLOG" &
	updateStreamPID=$!
	disown
else
	sendToLog "Status: Starting softwareupdate install of recommended updates. Check /var/log/install.log for more detail..."
fi

# Loop through and install only recommended/non-restart updates.
oldIFS="$IFS"; IFS=$'\n'
for i in "${!recommendedLABLES[@]}"; do
	sendToLog "Status: Installing Recommended Software Update $((i + 1)): ${recommendedLABLES[i]}..."
	if [[ $macosMAJOR -ge 12 ]]; then
			if [[ "$currentUSER" == "FALSE" ]]; then
				recommendedRESULT=$(sudo -i softwareupdate --install "${recommendedLABLES[i]}" --force --no-scan --agree-to-license 2>&1)
			else # Local user is logged in.
				recommendedRESULT=$(launchctl asuser "$currentUID" sudo -i softwareupdate --install "${recommendedLABLES[i]}" --force --no-scan --agree-to-license 2>&1)
			fi
	elif [[ $macosMAJOR -eq 11 ]]; then
		recommendedRESULT=$(softwareupdate --install "${recommendedLABLES[i]}" --force --no-scan --agree-to-license 2>&1)
	else # macOS 10.X
		recommendedRESULT=$(softwareupdate --install "${recommendedLABLES[i]}" --force --no-scan 2>&1)
	fi
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: recommendedRESULT is: $recommendedRESULT"
	updateRECOMMENDED=$(echo "$recommendedRESULT" | grep "Done with" | cut -c 11-)
	if [[ -n $updateRECOMMENDED ]]; then
		sendToLog "Status: Installed Recommended Software Update: $updateRECOMMENDED."
	else
		sendToLog "Error: Apple softwareupdate failed to install recommended software update: ${recommendedLABLES[i]}."; updateERROR="TRUE"
	fi
done
IFS="$oldIFS"
if [[ "$macosMAJOR" != "10" ]]; then
	kill -9 $updateStreamPID > /dev/null 2>&1
	echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. ASU RECOMMENDED UPDATES END ****" >> "$updateLOG"
fi
}

# Download restart-required system update via softwareupdate command, and also save results to $superLOG, $updateLOG, and $superPLIST.
downloadSystemUpdateASU() {
# For macOS 12 or later restarting the Software Update Notification Manager daemon prevents system updates from hanging.
if [[ $macosMAJOR -ge 12 ]] && [[ "$currentUSER" != "FALSE" ]]; then
	sendToLog "Status: Restarting Software Update Notification Manager daemon..."
	if ! launchctl kickstart -k "gui/$currentUID/com.apple.SoftwareUpdateNotificationManager"; then
		echo "Restarting Software Update Notification Manager didn't respond, trying again in one minute..."
		sleep 60
		launchctl kickstart -k "gui/$currentUID/com.apple.SoftwareUpdateNotificationManager"
	fi
fi

# Start log streaming for softwareupdate progress and send to $updateLOG.
sendToLog "Status: Starting download of system update via softwareupdate command..."
if [[ "$macosMAJOR" != "10" ]]; then
	echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. ASU SYSTEM DOWNLOAD START ****" >> "$updateLOG"
	log stream --predicate '(subsystem == "com.apple.SoftwareUpdateMacController") && (eventMessage CONTAINS[c] "reported progress")' >> "$updateLOG" &
	updateStreamPID=$!
	disown
fi

# Start the softwareupdate download, different requirements between macOS versions.
if [[ $macosMAJOR -ge 12 ]]; then
	if [[ "$macosARCH" == "arm64" ]]; then
		downloadRESULT=$(launchctl asuser "$currentUID" sudo -u root softwareupdate --download --all --force --no-scan --agree-to-license --user "$asuACCOUNT" --stdinpass "$asuPASSWORD" 2>&1)
	else # Intel.
		downloadRESULT=$(launchctl asuser "$currentUID" sudo -u root softwareupdate --download --all --force --no-scan --agree-to-license 2>&1)
	fi
elif [[ $macosMAJOR -eq 11 ]]; then
	if [[ "$macosARCH" == "arm64" ]]; then
		downloadRESULT=$(expect -c "
		set timeout -1
		spawn softwareupdate --download --all --force --no-scan --agree-to-license 2>&1
		expect \"Password:\"
		send {${asuPASSWORD}}
		send \r
		expect eof
		wait
		")
	else # Intel.
		downloadRESULT=$(softwareupdate --download --all --force --no-scan --agree-to-license 2>&1)
	fi
else # macOS 10.X
	downloadRESULT=$(softwareupdate --download --all --force --no-scan 2>&1)
fi

# Stop log streaming the softwareupdate progress.
if [[ "$macosMAJOR" != "10" ]]; then
	kill -9 $updateStreamPID > /dev/null 2>&1
	echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. ASU SYSTEM DOWNLOAD END ****" >> "$updateLOG"
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: downloadRESULT is: $downloadRESULT"

# Parse $downloadRESULT for individual downloads and write to $superLOG and $superPLIST.
oldIFS="$IFS"; IFS=$'\n'
downloadedTITLES=($(echo "$downloadRESULT" | grep "Downloaded" | cut -d " " -f 2-))
if [[ ${#downloadedTITLES[@]} -gt 0 ]]; then
	sendToLog "Status: Downloaded ${#downloadedTITLES[@]} system udpate(s)."
	defaults delete "$superPLIST" UpdateDownloads 2> /dev/null
	for i in "${!downloadedTITLES[@]}"; do
		sendToLog "Status: Downloaded System Update $((i + 1)): ${downloadedTITLES[i]}"
		defaults write "$superPLIST" UpdateDownloads -array-add "${downloadedTITLES[i]}"
	done
	downloadREQUIRED="FALSE"
else
	sendToLog "Exit: Apple softwareupdate failed to download any updates, trying again in $defaultDeferSECONDS seconds. "
	makeLaunchDaemonCalendar
fi
IFS="$oldIFS"
}

# Download restart-required system update via MDM push command, and also save results to $superLOG, $mdmLOG, $updateLOG, and $superPLIST.
downloadSystemUpdateMDM() {
sendToLog "Status: Starting download of system udpate via MDM command..."
# This pre-flights the MDM query locally and may also be useful for troubleshooting.
availableOSUPDATES=$(/usr/libexec/mdmclient AvailableOSUpdates 2>&1)
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: availableOSUPDATES is: \n$availableOSUPDATES"

# Make sure we still have a valid Jamf Pro API token.
checkJamfProServerToken

# Start log streaming for MDM push acknowledgements and send to $mdmLOG.
echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM DOWNLOAD START ****" >> "$mdmLOG"
log stream --predicate '(subsystem == "com.apple.ManagedClient") && (category == "HTTPUtil")' >> "$mdmLOG" &
mdmStreamPID=$!
disown

# Start log streaming for softwareupdate progress and send to $updateLOG.
echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM DOWNLOAD START ****" >> "$updateLOG"
log stream --predicate '(subsystem == "com.apple.SoftwareUpdateMacController") && (eventMessage CONTAINS[c] "reported progress")' >> "$updateLOG" &
updateStreamPID=$!
disown

# Send the Jamf Pro API command to download via MDM.
if [[ $jamfVERSION -ge 1038 ]]; then
	jamfAPIURL="${jamfSERVER}api/v1/macos-managed-software-updates/send-updates"
	jamfJSON='{ "deviceIds": ["'${jamfProID}'"], "skipVersionVerification": false, "applyMajorUpdate": false, "updateAction": "DOWNLOAD_ONLY" }'
	commandRESULT=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --header "Content-Type: application/json" --write-out "%{http_code}" --silent --output /dev/null --request POST --url "$jamfAPIURL" --data "$jamfJSON")
else
	sendToLog "Warning: Using legacy Jamf Pro Classic API. You should upgrade your Jamf Pro instance to 10.38 or later."
	commandRESULT=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --write-out "%{http_code}" --silent --output /dev/null --request POST --url "${jamfSERVER}JSSResource/computercommands/command/ScheduleOSUpdate/action/download/id/${jamfProID}")
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: commandRESULT is: \n$commandRESULT"

# If the Jamf Pro API command was successfully created, monitor the download progress.
if [[ $commandRESULT -eq 200 ]] || [[ $commandRESULT -eq 201 ]]; then
	sendToLog "Status: Successful MDM download command request."
	sendBlankPush

	# Some helpfull logging while waiting for Jamf Pro's mandatory 5 minute delay.
	tail -n 0 -f "$mdmLOG" | while read -r logLINE ; do
		if echo "$logLINE" | grep -q -w 'Received HTTP response (200) \[Acknowledged(ScheduleOSUpdateScan)'; then
			sendToLog "Status: Recieved MDM command \"ScheduleOSUpdateScan\", checking back after Jamf Pro's mandatory 5 minute delay..."
			pkill -P $$ tail
			break
		fi
	done
	timerEND=300
	while [[ $timerEND -ge 0 ]]; do
		echo -ne "Waiting for Jamf Pro's mandatory 5 minute delay: -$(date -u -r $timerEND +%M:%S)\r"
		timerEND=$((timerEND - 1))
		sleep 1
	done
	echo
	sendToLog "Status: Jamf Pro's mandatory 5 minute delay should be complete, sending Blank Push..."
	sendBlankPush

	# Watch $mdmLOG while waiting for the MDM workflow to complete.
	tail -n 0 -f "$mdmLOG" | while read -r logLINE ; do
		if echo "$logLINE" | grep -q -w 'Received HTTP response (200) \[Idle\]'; then
			sendToLog "Status: Recieved MDM blank push."
		elif echo "$logLINE" | grep -q -w 'Received HTTP response (200) \[Acknowledged(AvailableOSUpdates)'; then
			sendToLog "Status: Recieved MDM command \"AvailableOSUpdates\"."
		elif echo "$logLINE" | grep -q -w 'Received HTTP response (200) \[Acknowledged(ScheduleOSUpdate)'; then
			sendToLog "Status: Recieved MDM command \"ScheduleOSUpdate\", download should start soon..."
			kill -9 "$mdmStreamPID" > /dev/null 2>&1
			echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM DOWNLOAD END ****" >> "$mdmLOG"
			pkill -P $$ tail; break
		fi
	done

	# Watch $updateLOG while waiting for the download workflow to complete.
	logPROGRESS=""
	tail -n 0 -f "$updateLOG" | while read -r logLINE ; do
		if echo "$logLINE" | grep -q -w 'phase:DOWNLOADING_SFR\|phase:DOWNLOADING_UPDATE'; then
			[[ "$logPROGRESS" != "Downloading" ]] && sendToLog "Status: Downloading system update..."
			logPROGRESS="Downloading"
			[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: Downloading/preparing percentage complete: $(echo "$logLINE" | awk -F '[ :]+' '{ print $23*100; }' | cut -c 1-4)%"
		elif echo "$logLINE" | grep -q -w 'phase:PREPARING_UPDATE'; then
			[[ "$logPROGRESS" != "Preparing" ]] && sendToLog "Status: Download complete, now preparing system update, should be done in a few minutes..."
			logPROGRESS="Preparing"
			[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: Downloading/preparing update percentage complete: $(echo "$logLINE" | awk -F '[ :]+' '{ print $23*100; }' | cut -c 1-4)%"
		elif echo "$logLINE" | grep -q -w 'phase:COMPLETED'; then
			sendToLog "Status: System update is downloaded and prepared."
			kill -9 "$updateStreamPID" > /dev/null 2>&1
			echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM DOWNLOAD END ****" >> "$updateLOG"
			defaults delete "$superPLIST" UpdateDownloads 2> /dev/null
			oldIFS="$IFS", IFS=$'\n'
			for i in "${!allTITLES[@]}"; do
				sendToLog "Status: Downloaded System Update $((i + 1)): ${allTITLES[i]}"
				defaults write "$superPLIST" UpdateDownloads -array-add "${allTITLES[i]}"
			done
			IFS="$oldIFS"
			pkill -P $$ tail; break
		fi
	done
	downloadREQUIRED="FALSE"
else
	sendToLog "Exit: Failed to send MDM download request. Verify that the Jamf Pro API account \"$jamfACCOUNT\" has the privileges \"Jamf Pro Server Objects > Computers > Create & Read\" and \"Jamf Pro Server Actions > Send Computer Remote Command to Download and Install macOS Update\"."
	kill -9 $mdmStreamPID > /dev/null 2>&1
	[[ -n "$jamfProTOKEN" ]] && deleteJamfProServerToken
	rm -f "$superPIDFILE"
	sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
	exit 1
fi
}

# Install any optional $policyTRIGGERS.
runJamfPolicies() {
sendToLog "Status: Starting Jamf Policy triggers. Use \"--verbose-mode\" or check /var/log/jamf.log for more detail..."
oldIFS="$IFS"; IFS=','
read -r -a triggerARRAY <<< "$policyTRIGGERS"
for trigger in "${triggerARRAY[@]}"; do
	if [[ "$testModeOPTION" != "TRUE" ]]; then
		sendToLog "Status: Jamf Policy with Trigger \"$trigger\" is starting..."
		if [[ "$verboseModeOPTION" == "TRUE" ]]; then
			jamfRESULT=$("$jamfBINARY" policy -event "$trigger" -verbose 2>&1)
			jamfRETURN=$?
			sendToLog "Verbose Mode: jamfRESULT is: \n$jamfRESULT"
			sendToLog "Verbose Mode: jamfRETURN is: $jamfRETURN"
		else
			"$jamfBINARY" policy -event "$trigger" > /dev/null 2>&1
			jamfRETURN=$?
		fi
		if [ $jamfRETURN -ne 0 ]; then
			sendToLog "Error: Jamf Policy with Trigger \"$trigger\" failed!"; jamfERROR="TRUE"
		else
			sendToLog "Status: Jamf Policy with Trigger \"$trigger\" was succesfull."
		fi
	else
		sendToLog "Test Mode: Skipping Jamf Policy with Trigger: $trigger."
	fi
done
IFS="$oldIFS"
if [[ "$testModeOPTION" != "TRUE" ]]; then
	if [[ "$jamfERROR" != "TRUE" ]]; then
		sendToLog "Status: All Jamf Policies completed, deleting local policy triggers preference."
		defaults delete "$superPLIST" PolicyTriggers 2> /dev/null
	else
		sendToLog "Status: Some Jamf Policies failed, not deleting local policy triggers preference."
	fi
else
	sendToLog "Test Mode: Killing update restart notification in $testModeTIMEOUT seconds..."
	sleep "$testModeTIMEOUT"
	kill -9 "$notifyPID" > /dev/null 2>&1
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
	else
		killall -9 "jamfHelper" > /dev/null 2>&1
	fi
fi
}

# This is the install and restart workflow when a user is NOT logged in.
installRestartNoUser(){
if [[ "$updatesRESTART" == "TRUE" ]]; then # Install restart required system updates if needed.
	if [[ "$updateWORKFLOW" == "ASU" ]]; then
		[[ -n $policyTRIGGERS ]] && runJamfPolicies # If requested, run Jamf Policy Triggers before system update.
		installSystemUpdateASU
	elif [[ "$updateWORKFLOW" == "JAMF" ]]; then
		[[ -n $policyTRIGGERS ]] && runJamfPolicies # If requested, run Jamf Policy Triggers before system update.
		installSystemUpdateMDM
	else # Apple Silicon with no valid update credentials.
		sendToLog "Status: No valid Apple Silicon credentials and no current local user, trying again in $defaultDeferSECONDS seconds."
		makeLaunchDaemonCalendar
	fi
else # Otherwise, this is the workflow when there are no restart required system updates.
	if [[ -n $policyTRIGGERS ]]; then # If requested then run Jamf Policy Triggers, but...
		if [[ "$skipUpdatesOPTION" == "TRUE" ]]; then # Only when in skip updates mode.
			runJamfPolicies
		else
			sendToLog "Warning: Jamf Policy Triggers only run before a restart required system udpate or you specify the --skip-updates option."
		fi
	fi
	if [[ "$forceRestartOPTION" == "TRUE" ]]; then # If requested, force the computer to restart.
		if [[ "$testModeOPTION" != "TRUE" ]]; then
			sendToLog "Forced Restart Mode: Restarting computer..."
			shutdown -o -r +1 &
			disown
		else
			sendToLog "Test Mode: Skipping forced restart."
		fi
	fi
fi
}

# This is the install and restart workflow when a user is logged in.
installRestartMain(){
if [[ "$updatesRESTART" == "TRUE" ]]; then # Install restart required system updates if needed.
	if [[ "$updateWORKFLOW" == "ASU" ]]; then
		notifyRestart
		[[ -n $policyTRIGGERS ]] && runJamfPolicies # If needed run Jamf Policy Triggers.
		installSystemUpdateASU
	elif [[ "$updateWORKFLOW" == "JAMF" ]]; then
		notifyPrepMDM
		[[ -n $policyTRIGGERS ]] && runJamfPolicies # If needed run Jamf Policy Triggers.
		installSystemUpdateMDM
	else # Can only encourage manual self-update if Apple Silicon with no valid update credentials.
		[[ -n $policyTRIGGERS ]] && sendToLog "Warning: Skipping Jamf Policy triggers because there are no valid Apple Silicon update crednetials to ensure a proper workflow."
		notifySelfUpdate &
		disown
	fi
else # Otherwise, this is the workflow when there are no restart required system updates.
	notifyRestart
	if [[ -n $policyTRIGGERS ]]; then # If requested then run Jamf Policy Triggers, but...
		if [[ "$skipUpdatesOPTION" == "TRUE" ]]; then # Only when in skip updates mode.
			runJamfPolicies
		else
			sendToLog "Warning: Jamf Policy Triggers only run before a restart required system udpate or you specify the --skip-updates option."
		fi
	fi
	if [[ "$forceRestartOPTION" == "TRUE" ]]; then # If requested, force the computer to restart.
		if [[ "$testModeOPTION" != "TRUE" ]]; then
			sendToLog "Forced Restart Mode: Restarting computer..."
			shutdown -o -r +1 &
			disown
		else
			sendToLog "Test Mode: Skipping forced restart, killing restart notification in $testModeTIMEOUT seconds..."
			sleep "$testModeTIMEOUT"
			kill -9 "$notifyPID" > /dev/null 2>&1
			if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
				killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
			else
				killall -9 "jamfHelper" > /dev/null 2>&1
			fi
		fi
	fi
fi
}

# Install restart-required system via the softwareupdate command, and also save results to $superLOG, $updateLOG, and $superPLIST.
installSystemUpdateASU() {
if [[ "$testModeOPTION" != "TRUE" ]]; then
	# For macOS 12 or later restarting the Software Update Notification Manager daemon or the softwareupdate daemon prevents system updates from hanging.
	if [[ $macosMAJOR -ge 12 ]]; then
		if [[ "$currentUSER" != "FALSE" ]]; then
			sendToLog "Status: Restarting Software Update Notification Manager daemon..."
			if ! launchctl kickstart -k "gui/$currentUID/com.apple.SoftwareUpdateNotificationManager"; then
				echo "Restarting Software Update Notification Manager didn't respond, trying again in one minute..."
				sleep 60
				launchctl kickstart -k "gui/$currentUID/com.apple.SoftwareUpdateNotificationManager"
			fi
		else # No user is logged in, so just restart the softwareupdate process.
			sendToLog "Status: Restarting softwareupdate daemon..."
			launchctl kickstart -k system/com.apple.softwareupdated
			sleep 60
		fi
	fi

	# If no $currentUSER then the sytem update was not pre-downloaded.
	if [[ "$downloadREQUIRED" == "TRUE" ]]; then
		sendToLog "Status: Starting download and install of system update via softwareupdate command..."
	else
		sendToLog "Status: Starting install of system update via softwareupdate command..."
	fi

	# Start log streaming for softwareupdate install progress and send to $updateLOG.
	if [[ "$macosMAJOR" != "10" ]]; then
		if [[ "$downloadREQUIRED" == "TRUE" ]]; then
			echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. ASU SYSTEM DOWNLOAD AND UPDATE START ****" >> "$updateLOG"
		else
			echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. ASU SYSTEM UPDATE START ****" >> "$updateLOG"
		fi
		log stream --predicate '(subsystem == "com.apple.SoftwareUpdateMacController") && (eventMessage CONTAINS[c] "reported progress")' >> "$updateLOG" &
		updateStreamPID=$!
		disown
	fi

	# Start the softwareupdate installation in the background, different requirements between macOS versions.
	if [[ $macosMAJOR -ge 12 ]]; then
		if [[ "$currentUSER" == "FALSE" ]]; then
			if [[ "$macosARCH" == "arm64" ]]; then
				sudo -u root softwareupdate --install --all --restart --force --no-scan --agree-to-license --user "$asuACCOUNT" --stdinpass "$asuPASSWORD" &
			else # Intel.
				sudo -u root softwareupdate --install --all --restart --force --no-scan --agree-to-license &
			fi
		else # Local user is logged in.
			if [[ "$macosARCH" == "arm64" ]]; then
				launchctl asuser "$currentUID" sudo -u root softwareupdate --install --all --restart --force --no-scan --agree-to-license --user "$asuACCOUNT" --stdinpass "$asuPASSWORD" &
			else # Intel.
				launchctl asuser "$currentUID" sudo -u root softwareupdate --install --all --restart --force --no-scan --agree-to-license &
			fi
		fi
	elif [[ $macosMAJOR -eq 11 ]]; then
		if [[ "$macosARCH" == "arm64" ]]; then
			expect -c "
			set timeout -1
			spawn softwareupdate --install --all --restart --force --no-scan --agree-to-license
			expect \"Password:\"
			send {${asuPASSWORD}}
			expect eof
			wait
			" &
		else # Intel.
			softwareupdate --install --all --restart --force --no-scan --agree-to-license &
		fi
	else # macOS 10.X
		softwareupdate --install --all --restart --force --no-scan &
	fi

	# Reset various items after system update is complete.
	defaults delete "$superPLIST" UpdateDownloads 2> /dev/null
	defaults write "$superPLIST" UpdateValidate -bool true
	restartZeroDay
	restartDeferralCounters
	unset recheckDeferSECONDS
	makeLaunchDaemonOnStartup
else
	sendToLog "Test Mode: Skipping softwareupdate install of all updates and restart."
	sendToLog "Test Mode: Killing update restart notification in $testModeTIMEOUT seconds..."
	sleep "$testModeTIMEOUT"
	kill -9 "$notifyPID" > /dev/null 2>&1
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
	else
		killall -9 "jamfHelper" > /dev/null 2>&1
	fi
fi
}

# Install restart-required system update via MDM push command, and also save results to $superLOG, $mdmLOG, $updateLOG, and $superPLIST.
installSystemUpdateMDM() {
if [[ "$testModeOPTION" != "TRUE" ]]; then
	# If no $currentUSER then the sytem update was not pre-downloaded.
	if [[ "$downloadREQUIRED" == "TRUE" ]]; then
		sendToLog "Status: Starting download and install of system udpate via MDM command..."
	else
		sendToLog "Status: Starting install of system udpate via MDM command..."
	fi

	# This pre-flights the MDM query locally and may also be useful for troubleshooting.
	availableOSUPDATES=$(/usr/libexec/mdmclient AvailableOSUpdates 2>&1)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: availableOSUPDATES is: \n$availableOSUPDATES"

	# Make sure we still have a valid Jamf Pro API token.
	checkJamfProServerToken

	# Start log streaming for MDM push acknowledgements and send to $mdmLOG.
	if [[ "$downloadREQUIRED" == "TRUE" ]]; then
		echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM DOWNLOAD AND UPDATE START ****" >> "$mdmLOG"
	else
		echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM UPDATE START ****" >> "$mdmLOG"
	fi
	log stream --predicate '(subsystem == "com.apple.ManagedClient") && (category == "HTTPUtil")' >> "$mdmLOG" &
	mdmStreamPID=$!
	disown

	# Start log streaming for softwareupdate progress and send to $updateLOG.
	if [[ "$downloadREQUIRED" == "TRUE" ]]; then
		echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM DOWNLOAD AND UPDATE START ****" >> "$updateLOG"
	else
		echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM UPDATE START ****" >> "$updateLOG"
	fi
	log stream --predicate '(subsystem == "com.apple.SoftwareUpdateMacController") && (eventMessage CONTAINS[c] "reported progress")' >> "$updateLOG" &
	updateStreamPID=$!
	disown

	# Send the Jamf Pro API command to update and restart via MDM.
	if [[ $jamfVERSION -ge 1038 ]]; then
		jamfAPIURL="${jamfSERVER}api/v1/macos-managed-software-updates/send-updates"
		jamfJSON='{ "deviceIds": ["'${jamfProID}'"], "skipVersionVerification": false, "applyMajorUpdate": false, "updateAction": "DOWNLOAD_AND_INSTALL", "forceRestart": true }'
		commandRESULT=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --header "Content-Type: application/json" --write-out "%{http_code}" --silent --output /dev/null --request POST --url "${jamfAPIURL}" --data "${jamfJSON}")
	else
		sendToLog "Warning: Using legacy Jamf Pro Classic API. You should upgrade your Jamf Pro instance to 10.38 or later."
		commandRESULT=$(curl --header "Authorization: Bearer ${jamfProTOKEN}" --write-out "%{http_code}" --silent --output /dev/null --request POST --url "${jamfSERVER}JSSResource/computercommands/command/ScheduleOSUpdate/action/install/id/${jamfProID}")
	fi
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: commandRESULT is: \n$commandRESULT"

	# If the Jamf Pro API command was successfully created, monitor the update progress.
	if [[ $commandRESULT -eq 200 ]] || [[ $commandRESULT -eq 201 ]]; then
		sendToLog "Status: Successful MDM update and restart command request."
		sendBlankPush

		# Some helpfull logging while waiting for Jamf Pro's mandatory 5 minute delay.
		tail -n 0 -f "$mdmLOG" | while read -r logLINE ; do
			if echo "$logLINE" | grep -q -w 'Received HTTP response (200) \[Acknowledged(ScheduleOSUpdateScan)'; then
				sendToLog "Status: Recieved MDM command \"ScheduleOSUpdateScan\", checking back after Jamf Pro's mandatory 5 minute delay..."
				pkill -P $$ tail
				break
			fi
		done
		timerEND=300
		while [[ $timerEND -ge 0 ]]; do
			echo -ne "Waiting for Jamf Pro's mandatory 5 minute delay: -$(date -u -r $timerEND +%M:%S)\r"
			timerEND=$((timerEND - 1))
			sleep 1
		done
		echo
		kill -9 "$notifyPID" > /dev/null 2>&1
		if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
			killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
		else
			killall -9 "jamfHelper" > /dev/null 2>&1
		fi
		sendToLog "Status: Jamf Pro's mandatory 5 minute delay should be complete, sending Blank Push..."
		sendBlankPush
		[[ "$currentUSER" != "FALSE" ]] && notifyRestart

		# Watch $mdmLOG while waiting for the MDM workflow to complete.
		tail -n 0 -f "$mdmLOG" | while read -r logLINE ; do
			if echo "$logLINE" | grep -q -w 'Received HTTP response (200) \[Idle\]'; then
				sendToLog "Status: Recieved MDM blank push."
			elif echo "$logLINE" | grep -q -w 'Received HTTP response (200) \[Acknowledged(AvailableOSUpdates)'; then
				sendToLog "Status: Recieved MDM command \"AvailableOSUpdates\"."
			elif echo "$logLINE" | grep -q -w 'Received HTTP response (200) \[Acknowledged(ScheduleOSUpdate)'; then
				if [[ "$downloadREQUIRED" == "TRUE" ]]; then
					sendToLog "Status: Recieved MDM command \"ScheduleOSUpdate\", download and update should start soon..."
					echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM DOWNLOAD AND UPDATE END ****" >> "$mdmLOG"
				else
					sendToLog "Status: Recieved MDM command \"ScheduleOSUpdate\", restart should be soon..."
					echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM UPDATE END ****" >> "$mdmLOG"
				fi
				kill -9 "$mdmStreamPID" > /dev/null 2>&1
				pkill -P $$ tail; break
			fi
		done

		# Watch $updateLOG while waiting for the update and restart workflow to complete.
		if [[ "$downloadREQUIRED" == "TRUE" ]]; then
			logPROGRESS=""
			tail -n 0 -f "$updateLOG" | while read -r logLINE ; do
				if echo "$logLINE" | grep -q -w 'phase:DOWNLOADING_SFR\|phase:DOWNLOADING_UPDATE'; then
					[[ "$logPROGRESS" != "Downloading" ]] && sendToLog "Status: Downloading system update..."
					logPROGRESS="Downloading"
					[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: Downloading/preparing percentage complete: $(echo "$logLINE" | awk -F '[ :]+' '{ print $23*100; }' | cut -c 1-4)%"
				elif echo "$logLINE" | grep -q -w 'phase:PREPARING_UPDATE'; then
					[[ "$logPROGRESS" != "Preparing" ]] && sendToLog "Status: Download complete, now preparing system update, should be done in a few minutes..."
					logPROGRESS="Preparing"
					[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: Downloading/preparing update percentage complete: $(echo "$logLINE" | awk -F '[ :]+' '{ print $23*100; }' | cut -c 1-4)%"
				elif echo "$logLINE" | grep -q -w 'phase:APPLYING'; then
					sendToLog "Status: Software update process is complete, restart is imminent..."
					kill -9 "$updateStreamPID" > /dev/null 2>&1
					echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM DOWNLOAD AND UPDATE END ****" >> "$updateLOG"
					pkill -P $$ tail; break
				fi
			done
		else
			tail -n 0 -f "$updateLOG" | while read -r logLINE ; do
				if echo "$logLINE" | grep -q -w 'phase:APPLYING'; then
					sendToLog "Status: Software update process is complete, restart is imminent..."
					kill -9 "$updateStreamPID" > /dev/null 2>&1
					echo -e "$(date +"%a %b %d %T") $(hostname -s) $(basename "$0")[$$]: **** S.U.P.E.R.M.A.N. MDM SYSTEM UPDATE END ****" >> "$updateLOG"
					pkill -P $$ tail; break
				fi
			done
		fi

		# Reset various items after system update is complete.
		defaults delete "$superPLIST" UpdateDownloads 2> /dev/null
		defaults write "$superPLIST" UpdateValidate -bool true
		restartZeroDay
		restartDeferralCounters
		unset recheckDeferSECONDS
		makeLaunchDaemonOnStartup
	else
		sendToLog "Exit: Failed to send MDM update request. Verify that the Jamf Pro API account \"$jamfACCOUNT\" has the privileges \"Jamf Pro Server Objects > Computers > Create & Read\" and \"Jamf Pro Server Actions > Send Computer Remote Command to Download and Install macOS Update\"."
		kill -9 "$mdmStreamPID" > /dev/null 2>&1
		[[ -n "$jamfProTOKEN" ]] && deleteJamfProServerToken
		rm -f "$superPIDFILE"
		sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
		exit 1
	fi
else
	sendToLog "Test Mode: Skipping MDM update and restart request."
	sendToLog "Test Mode: Killing MDM preparation notification in $testModeTIMEOUT seconds..."
	sleep "$testModeTIMEOUT"
	kill -9 "$notifyPID" > /dev/null 2>&1
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
	else
		killall -9 "jamfHelper" > /dev/null 2>&1
	fi
	[[ "$currentUSER" != "FALSE" ]] && notifyRestart
	sendToLog "Test Mode: Killing update restart notification in $testModeTIMEOUT seconds..."
	sleep "$testModeTIMEOUT"
	kill -9 "$notifyPID" > /dev/null 2>&1
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
	else
		killall -9 "jamfHelper" > /dev/null 2>&1
	fi
fi
}

######## FUNCTIONS - LAUNCHDAEMON ########

# Create a LaunchDaemon to run super-starter again right now, thus releasing any Jamf Pro Policy that may have started super.
makeLaunchDaemonRestartNow() {
# This creates a LaunchDaemon.plist file.
/bin/cat <<EOLDL > "/Library/LaunchDaemons/$launchDaemonNAME.plist"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>$launchDaemonNAME</string>
	<key>LaunchOnlyOnce</key>
	<true/>
	<key>AbandonProcessGroup</key>
	<true/>
	<key>UserName</key>
	<string>root</string>
	<key>ProgramArguments</key>
	<array>
		<string>$superFOLDER/super-starter</string>
	</array>
	<key>RunAtLoad</key>
	<true/>
</dict>
</plist>
EOLDL

[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "LaunchDaemon: $launchDaemonNAME.plist...\n$(cat "/Library/LaunchDaemons/$launchDaemonNAME.plist")"

# Set proper permissions and load the LaunchDaemon.
chmod 644 "/Library/LaunchDaemons/$launchDaemonNAME.plist"
chown root:wheel "/Library/LaunchDaemons/$launchDaemonNAME.plist"
sendToLog "Exit: LaunchDaemon $launchDaemonNAME.plist is scheduled to start right now."
launchctl bootstrap system "/Library/LaunchDaemons/$launchDaemonNAME.plist"
[[ -n "$jamfProTOKEN" ]] && deleteJamfProServerToken
rm -f "$superPIDFILE"
sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
exit 0
}

# Create a LaunchDaemon to run super-starter again after system restart so we can validate the update progress.
makeLaunchDaemonOnStartup() {
# This creates a LaunchDaemon.plist file.
/bin/cat <<EOLDL > "/Library/LaunchDaemons/$launchDaemonNAME.plist"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>$launchDaemonNAME</string>
	<key>LaunchOnlyOnce</key>
	<true/>
	<key>AbandonProcessGroup</key>
	<true/>
	<key>UserName</key>
	<string>root</string>
	<key>ProgramArguments</key>
	<array>
		<string>$superFOLDER/super-starter</string>
	</array>
	<key>RunAtLoad</key>
	<true/>
</dict>
</plist>
EOLDL

[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "LaunchDaemon: $launchDaemonNAME.plist...\n$(cat "/Library/LaunchDaemons/$launchDaemonNAME.plist")"

# Set proper permissions and load the LaunchDaemon.
chmod 644 "/Library/LaunchDaemons/$launchDaemonNAME.plist"
chown root:wheel "/Library/LaunchDaemons/$launchDaemonNAME.plist"
sendToLog "Exit: LaunchDaemon $launchDaemonNAME.plist is scheduled at next startup."
}

# Create a LaunchDaemon to run super-starter again $defaultDeferSECONDS from now.
makeLaunchDaemonCalendar() {
# Calculate the appropriate deferment timer for the LaunchDaemon.
deferCALC=$(($(date +%s) + defaultDeferSECONDS))
month=$(date -j -f "%s" "$deferCALC" "+%m" | xargs)
day=$(date -j -f "%s" "$deferCALC" "+%e" | xargs)
hour=$(date -j -f "%s" "$deferCALC" "+%H" | xargs)
minute=$(date -j -f "%s" "$deferCALC" "+%M" | xargs)

# This creates a LaunchDaemon.plist file.
/bin/cat <<EOLDL > "/Library/LaunchDaemons/$launchDaemonNAME.plist"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>$launchDaemonNAME</string>
	<key>LaunchOnlyOnce</key>
	<true/>
	<key>AbandonProcessGroup</key>
	<true/>
	<key>UserName</key>
	<string>root</string>
	<key>ProgramArguments</key>
	<array>
		<string>$superFOLDER/super-starter</string>
	</array>
	<key>StartCalendarInterval</key>
	<array>
		<dict>
		<key>Month</key>
		<integer>$month</integer>
		<key>Day</key>
		<integer>$day</integer>
		<key>Hour</key>
		<integer>$hour</integer>
		<key>Minute</key>
		<integer>$minute</integer>
		</dict>
	</array>
</dict>
</plist>
EOLDL

[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "LaunchDaemon: $launchDaemonNAME.plist...\n$(cat "/Library/LaunchDaemons/$launchDaemonNAME.plist")"

# Set proper permissions and load the LaunchDaemon.
chmod 644 "/Library/LaunchDaemons/$launchDaemonNAME.plist"
chown root:wheel "/Library/LaunchDaemons/$launchDaemonNAME.plist"
sendToLog "Exit: LaunchDaemon $launchDaemonNAME.plist is scheduled to start at $hour:$minute on $month/$day."
launchctl bootstrap system "/Library/LaunchDaemons/$launchDaemonNAME.plist"
[[ -n "$jamfProTOKEN" ]] && deleteJamfProServerToken
rm -f "$superPIDFILE"
sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
exit 0
}

######## FUNCTIONS - USER INTERACTION ########

# Set language strings for notifications and dialogs.
setDisplayLanguage(){
#### Langauge for the restart button in dialogs. Note that for deadline dialogs this is the default button.
restartButtonTEXT="Restart"

#### Language for the deferral button in dialogs. Note that for non-deadline dialogs this is the default button.
deferButtonTEXT="Defer"

#### Useful display variables:
# $countDISPLAY is the current number of user soft/hard deferrals.
# $countMaxDISPLAY is the maximum number of user soft/hard deferrals.
# $softDaysMAX is the maximum number of deferral days before a soft deadline.
# $hardDaysMAX is the maximum number of deferral days before a hard deadline.
# $zeroDayDISPLAY is the date:time of the zero day that is used for calculating the maximum days deferral deadlines.
# $deadlineDaysDISPLAY is the soonest date:time based on evaluating the maximum days deferral deadlines.
# $deadlineDateDISPLAY is the soonest date:time based on evaluating the maximum date deferral deadlines.
# $deadlineDISPLAY is the soonest date:time based on evaluating both the maximum date and days deferral deadlines.
# See $dateFORMAT and $timeFORMAT in the setDefaults() function to adjust how the date:time is shown.

#### Language for dialogAskForUpdate(), an interactive dialog giving the user a choice to defer the update or restart.
dialogAskForUpdateTITLE="Software Updates Require Restart"
dialogAskForUpdateDeferMenuTitleIBM="Defer software update for:" # jamfHelper does not allow for customizing the deferral menu language.
dialogAskForUpdateDeferMenuMinutesIBM="minutes"
dialogAskForUpdateDeferMenuHourIBM="hour"
dialogAskForUpdateDeferMenuHoursIBM="hours"
dialogAskForUpdateDeferMenuDayIBM="day"
dialogAskForUpdateTimeoutTEXT="Please make selection in" # jamfHelper does not allow for customizing the display timeout language.
# Note that IBM Notifier interprets "\n" as a return, while jamfHelper interprets "real" returns.
dialogAskForUpdateBodyUnlimitedIBM="• No deadline date and unlimited deferrals.\n"
dialogAskForUpdateBodyUnlimitedJAMF="• No deadline date and unlimited deferrals."
dialogAskForUpdateBodyDateIBM="• Deferral available until $deadlineDISPLAY.\n"
dialogAskForUpdateBodyDateJAMF="• Deferral available until $deadlineDISPLAY."
dialogAskForUpdateBodyCountIBM="• $countDISPLAY out of $countMaxDISPLAY deferrals remaining.\n"
dialogAskForUpdateBodyCountJAMF="• $countDISPLAY out of $countMaxDISPLAY deferrals remaining."
dialogAskForUpdateBodyDateCountIBM="• Deferral available until $deadlineDISPLAY.\n\n• $countDISPLAY out of $countMaxDISPLAY deferrals remaining.\n"
dialogAskForUpdateBodyDateCountJAMF="• Deferral available until $deadlineDISPLAY.

• $countDISPLAY out of $countMaxDISPLAY deferrals remaining."

#### Language for dialogSoftDeadline(), an interactive dialog when a soft deadline has passed, giving the user only one button to continue the workflow.
dialogSoftDeadlineTITLE="Software Updates Require Restart"
dialogSoftDeadlineTimeoutTEXT="Update will automatically start in" # jamfHelper does not allow for customizing the display timeout language.
# Note that IBM Notifier interprets "\n" as a return, while jamfHelper interprets "real" returns.
dialogSoftDeadlineBodyCountIBM="You have deferred the maximum number of $countMaxDISPLAY times."
dialogSoftDeadlineBodyCountJAMF="You have deferred the maximum number of $countMaxDISPLAY times."
dialogSoftDeadlineBodyDaysIBM="You have deferred the maximum number of $softDaysMAX days."
dialogSoftDeadlineBodyDaysJAMF="You have deferred the maximum number of $softDaysMAX days."
dialogSoftDeadlineBodyDateIBM="The deferrment deadline has passed:\n$deadlineDateDISPLAY."
dialogSoftDeadlineBodyDateJAMF="The deferrment deadline has passed:

$deadlineDateDISPLAY."

#### Language for notifyPrepMDM(), a non-interactive notification informing the user that the MDM update process has started.
# This is used for both non-deadline and hard deadline workflows.
notifyPrepTITLE="Software Updates Require Restart"
# Note that IBM Notifier interprets "\n" as a return, while jamfHelper interprets "real" returns.
notifyPrepBodyDefaultIBM="A required software update will automatically restart this computer in about 5 minutes.\n\nDuring this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process."
notifyPrepBodyDefaultJAMF="A required software update will automatically restart this computer in about 5 minutes.

During this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process."
notifyPrepBodyHardCountIBM="You have deferred the maximum number of $countMaxDISPLAY times.\n\nA required software update will automatically restart this computer in about 5 minutes.\n\nDuring this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process."
notifyPrepBodyHardCountJAMF="You have deferred the maximum number of $countMaxDISPLAY times.

A required software update will automatically restart this computer in about 5 minutes.

During this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process."
notifyPrepBodyHardDaysIBM="You have deferred the maximum number of $hardDaysMAX days.\n\nA required software update will automatically restart this computer in about 5 minutes.\n\nDuring this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process."
notifyPrepBodyHardDaysJAMF="You have deferred the maximum number of $hardDaysMAX days.

A required software update will automatically restart this computer in about 5 minutes.

During this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process."
notifyPrepBodyHardDateIBM="The deferrment deadline of $deadlineDateDISPLAY has passed.\n\nA required software update will automatically restart this computer in about 5 minutes.\n\nDuring this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process."
notifyPrepBodyHardDateJAMF="The deferrment deadline of $deadlineDateDISPLAY has passed.

A required software update will automatically restart this computer in about 5 minutes.

During this time you can continue to use the computer or lock the screen, but please do not restart or sleep the computer as it will prolong the update process."

#### Language for notifyRestart(), a non-interactive notification informing the user that the computer is going to restart very soon.
# This is used for all softwareupdate workflows and near the end of the MDM workflow.
# This is used for both non-deadline and hard deadline workflows.
notifyRestartTITLE="Software Updates Require Restart"
# Note that IBM Notifier interprets "\n" as a return, while jamfHelper interprets "real" returns.
notifyRestartBodyDefaultIBM="This computer will automatically restart very soon.\n\nSave any open documents now."
notifyRestartBodyDefaultJAMF="This computer will automatically restart very soon.

Save any open documents now."
notifyRestartBodyHardCountIBM="You have deferred the maximum number of $countMaxDISPLAY times.\n\nThis computer will automatically restart very soon.\n\nSave any open documents now."
notifyRestartBodyHardCountJAMF="You have deferred the maximum number of $countMaxDISPLAY times.

This computer will automatically restart very soon.

Save any open documents now."
notifyRestartBodyHardDaysIBM="You have deferred the maximum number of $hardDaysMAX days.\n\nThis computer will automatically restart very soon.\n\nSave any open documents now."
notifyRestartBodyHardDaysJAMF="You have deferred the maximum number of $hardDaysMAX days.

This computer will automatically restart very soon.

Save any open documents now."
notifyRestartBodyHardDateIBM="The deferrment deadline of $deadlineDateDISPLAY has passed.\n\nThis computer will automatically restart very soon.\n\nSave any open documents now."
notifyRestartBodyHardDateJAMF="The deferrment deadline of $deadlineDateDISPLAY has passed.

This computer will automatically restart very soon.

Save any open documents now."

#### Language for notifySelfUpdate(), a non-interactive notification informing the user that they must perform their own update.
# This is used if there is no valid system update enforcement workflow possible.
notifySelfUpdateTITLE="Software Updates Require Restart"
# Note that IBM Notifier interprets "\n" as a return, while jamfHelper interprets "real" returns.
notifySelfUpdateBodyIBM="You need to update this Mac as soon as possible by clicking the \"Update Now\" or \"Restart Now\" button in the Software Update preferences."
notifySelfUpdateBodyJAMF="You need to update this Mac as soon as possible by clicking the \"Update Now\" or \"Restart Now\" button in the Software Update preferences."
}

# Open $ibmNotifierBINARY using the $ibmNotifierARRAY[] options including the handling of any $displayTimeoutSECONDS and $displayRedrawSECONDS options.
openIbmNotifier() {
unset dialogRESULT
unset dialogRETURN
if [[ -n $displayRedrawSECONDS ]]; then
	[[ -n $displayTimeoutSECONDS ]] && displayTimeoutSECONDS=$((displayTimeoutSECONDS - 1))
	while [[ -z $dialogRETURN ]] || [[ "$dialogRETURN" -eq 137 ]]; do
		{ [[ -n $displayTimeoutSECONDS ]] && [[ -z $menuDeferSECONDS ]]; } && ibmNotifierARRAY+=(-accessory_view_type timer -accessory_view_payload "$displayTimeoutTEXT %@" -timeout "$displayTimeoutSECONDS")
		{ [[ -n $displayTimeoutSECONDS ]] && [[ -n $menuDeferSECONDS ]]; } && ibmNotifierARRAY+=(-secondary_accessory_view_type timer -secondary_accessory_view_payload "$displayTimeoutTEXT %@" -timeout "$displayTimeoutSECONDS")
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Ibm Notifier.app options: ${ibmNotifierARRAY[*]}"
		(sleep "$displayRedrawSECONDS"; killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1) &
		killerPID=$!
		dialogRESULT=$("$ibmNotifierBINARY" "${ibmNotifierARRAY[@]}")
		dialogRETURN="$?"
		kill -0 $killerPID && kill -9 $killerPID > /dev/null 2>&1
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog result: $dialogRESULT"
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog return: $dialogRETURN"
		[[ -n $displayTimeoutSECONDS ]] && displayTimeoutSECONDS=$((displayTimeoutSECONDS - displayRedrawSECONDS))
	done
else
	{ [[ -n $displayTimeoutSECONDS ]] && [[ -z $menuDeferSECONDS ]]; } && ibmNotifierARRAY+=(-accessory_view_type timer -accessory_view_payload "$displayTimeoutTEXT %@" -timeout "$displayTimeoutSECONDS")
	{ [[ -n $displayTimeoutSECONDS ]] && [[ -n $menuDeferSECONDS ]]; } && ibmNotifierARRAY+=(-secondary_accessory_view_type timer -secondary_accessory_view_payload "$displayTimeoutTEXT %@" -timeout "$displayTimeoutSECONDS")
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Ibm Notifier.app options: ${ibmNotifierARRAY[*]}"
	dialogRESULT=$("$ibmNotifierBINARY" "${ibmNotifierARRAY[@]}")
	dialogRETURN="$?"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog result: $dialogRESULT"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog return: $dialogRETURN"
fi
}

# Open $jamfHELPER using the $jamfHelperARRAY[] options including the handling of any $displayTimeoutSECONDS and $displayRedrawSECONDS options.
openJamfHelper() {
unset dialogRESULT
unset dialogRETURN
if [[ -n $displayRedrawSECONDS ]]; then
	[[ -n $displayTimeoutSECONDS ]] && displayTimeoutSECONDS=$((displayTimeoutSECONDS - 1))
	while [[ -z $dialogRESULT ]]; do
		[[ -n $displayTimeoutSECONDS ]] && jamfHelperARRAY+=(-timeout "$displayTimeoutSECONDS" -countdown)
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "jamfHelper options: ${jamfHelperARRAY[*]}"
		(sleep "$displayRedrawSECONDS"; killall -9 "jamfHelper" > /dev/null 2>&1) &
		killerPID=$!
		dialogRESULT=$("$jamfHELPER" "${jamfHelperARRAY[@]}")
		dialogRETURN="$?"
		kill -0 $killerPID && kill -9 $killerPID > /dev/null 2>&1
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog result: $dialogRESULT"
		[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog return: $dialogRETURN"
		[[ -n $displayTimeoutSECONDS ]] && displayTimeoutSECONDS=$((displayTimeoutSECONDS - displayRedrawSECONDS))
	done
else
	[[ -n $displayTimeoutSECONDS ]] && jamfHelperARRAY+=(-timeout "$displayTimeoutSECONDS" -countdown)
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "jamfHelper options: ${jamfHelperARRAY[*]}"
	dialogRESULT=$("$jamfHELPER" "${jamfHelperARRAY[@]}")
	dialogRETURN="$?"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog result: $dialogRESULT"
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Dialog return: $dialogRETURN"
fi
}

# Display a non-interactive notification informing the user that the MDM update process has started.
# This is used for both non-deadline and hard deadline workflows.
notifyPrepMDM() {
# The initial $ibmNotifierARRAY[] settings for the MDM update notification.
ibmNotifierARRAY=(-type popup -always_on_top -position top_right -bar_title "$notifyPrepTITLE" -icon_path "$cachedICON" -icon_width "$ibmNotifierIconSIZE" -icon_height "$ibmNotifierIconSIZE" -accessory_view_type progressbar -accessory_view_payload "/percent indeterminate")

# The initial $jamfHelperARRAY[] settings for the MDM update notification.
jamfHelperARRAY=(-windowType hud -windowPosition ur -lockHUD -title "$notifyPrepTITLE" -icon "$cachedICON" -iconSize "$jamfHelperIconSIZE")

# Variations for the main body text of the MDM update notification.
if [[ "$deadlineDateSTATUS" == "HARD" ]]; then # Hard date deadline MDM update notification.
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		sendToLog "IBM Notifier: Hard date deadline MDM update notification."
		ibmNotifierARRAY+=(-subtitle "$notifyPrepBodyHardDateIBM")
	else
		sendToLog "jamfHelper Notification: Hard date deadline MDM update notification."
		jamfHelperARRAY+=(-description "$notifyPrepBodyHardDateJAMF")
	fi
elif [[ "$deadlineDaysSTATUS" == "HARD" ]]; then # Hard days deadline MDM update notification.
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		sendToLog "IBM Notifier: Hard days deadline MDM update notification."
		ibmNotifierARRAY+=(-subtitle "$notifyPrepBodyHardDaysIBM")
	else
		sendToLog "jamfHelper Notification: Hard days deadline MDM update notification."
		jamfHelperARRAY+=(-description "$notifyPrepBodyHardDaysJAMF")
	fi
elif [[ "$deadlineCountSTATUS" == "HARD" ]]; then # Hard count deadline MDM update notification.
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		sendToLog "IBM Notifier: Hard count deadline MDM update notification."
		ibmNotifierARRAY+=(-subtitle "$notifyPrepBodyHardCountIBM")
	else
		sendToLog "jamfHelper Notification: Hard count deadline MDM update notification."
		jamfHelperARRAY+=(-description "$notifyPrepBodyHardCountJAMF")
	fi
else # No deadlines, this is the default MDM update notification.
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		sendToLog "IBM Notifier: Default MDM update notification."
		ibmNotifierARRAY+=(-subtitle "$notifyPrepBodyDefaultIBM")
	else
		sendToLog "jamfHelper: Default MDM update notification."
		jamfHelperARRAY+=(-description "$notifyPrepBodyDefaultJAMF")
	fi
fi

# Non-interactive notifications do not need a redraw or timeout.
unset displayRedrawSECONDS
unset displayTimeoutSECONDS

# Open notification in the background allowing super to continue.
if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
	openIbmNotifier &
	notifyPID=$!
	disown
else
	openJamfHelper &
	notifyPID=$!
	disown
fi
}

# Display a non-interactive notification informing the user that the computer going to restart soon.
# This is used for both non-deadline and hard deadline workflows.
notifyRestart() {
# The initial $ibmNotifierARRAY[] settings for the restart notification.
ibmNotifierARRAY=(-type popup -always_on_top -position top_right -bar_title "$notifyRestartTITLE" -icon_path "$cachedICON" -icon_width "$ibmNotifierIconSIZE" -icon_height "$ibmNotifierIconSIZE" -accessory_view_type progressbar -accessory_view_payload "/percent indeterminate")

# The initial $jamfHelperARRAY[] settings for the restart notification.
jamfHelperARRAY=(-windowType hud -windowPosition ur -lockHUD -title "$notifyRestartTITLE" -icon "$cachedICON" -iconSize "$jamfHelperIconSIZE")

# Variations for the main body text of the restart notification.
if [[ "$deadlineDateSTATUS" == "HARD" ]]; then # Hard date deadline restart notification.
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		sendToLog "IBM Notifier: Hard date deadline restart soon notification."
		ibmNotifierARRAY+=(-subtitle "$notifyRestartBodyHardDateIBM")
	else
		sendToLog "jamfHelper Notification: Hard date deadline restart soon notification."
		jamfHelperARRAY+=(-description "$notifyRestartBodyHardDateJAMF")
	fi
elif [[ "$deadlineDaysSTATUS" == "HARD" ]]; then # Hard days deadline restart notification.
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		sendToLog "IBM Notifier: Hard days deadline restart soon notification."
		ibmNotifierARRAY+=(-subtitle "$notifyRestartBodyHardDaysIBM")
	else
		sendToLog "jamfHelper Notification: Hard days deadline restart soon notification."
		jamfHelperARRAY+=(-description "$notifyRestartBodyHardDaysJAMF")
	fi
elif [[ "$deadlineCountSTATUS" == "HARD" ]]; then # Hard count deadline restart notification.
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		sendToLog "IBM Notifier: Hard count deadline restart soon notification."
		ibmNotifierARRAY+=(-subtitle "$notifyRestartBodyHardCountIBM")
	else
		sendToLog "jamfHelper Notification: Hard count deadline restart soon notification."
		jamfHelperARRAY+=(-description "$notifyRestartBodyHardCountJAMF")
	fi
else # No deadlines, this is the default restart notification.
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		sendToLog "IBM Notifier: Default restart soon notification."
		ibmNotifierARRAY+=(-subtitle "$notifyRestartBodyDefaultIBM")
	else
		sendToLog "jamfHelper: Default restart soon notification."
		jamfHelperARRAY+=(-description "$notifyRestartBodyDefaultJAMF")
	fi
fi

# Non-interactive notifications do not need a redraw or timeout.
unset displayRedrawSECONDS
unset displayTimeoutSECONDS

# Open notification in the background allowing super to continue.
if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
	openIbmNotifier &
	notifyPID=$!
	disown
else
	openJamfHelper &
	notifyPID=$!
	disown
fi
}

# Open both a non-interactive notification and the Software Update System Preference in the case where there is no valid system update enforcement workflow possible.
notifySelfUpdate() {
if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
	sendToLog "IBM Notifier: Opening self-update notification..."
	# Create initial $ibmNotifierARRAY[] settings for the notification.
	ibmNotifierARRAY=(-type popup -always_on_top -position top_left -bar_title "$notifySelfUpdateTITLE" -icon_path "$cachedICON" -icon_width "$ibmNotifierIconSIZE" -icon_height "$ibmNotifierIconSIZE" -accessory_view_type progressbar -accessory_view_payload "/percent indeterminate")
	ibmNotifierARRAY+=(-subtitle "$notifySelfUpdateBodyIBM")
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Ibm Notifier.app options: ${ibmNotifierARRAY[*]}"
else
	sendToLog "jamfHelper: Opening self-update notification..."
	# Create initial $jamfHelperARRAY[] settings for the dialog.
	jamfHelperARRAY=(-windowType hud -windowPosition ul -lockHUD -title "$notifySelfUpdateTITLE" -icon "$cachedICON" -iconSize "$jamfHelperIconSIZE")
	jamfHelperARRAY+=(-description "$notifySelfUpdateBodyJAMF")
	[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "jamfHelper Options: ${jamfHelperARRAY[*]}"
fi

# Start System Preferences and the notification.
unset dialogRESULT
unset displayTimeoutSECONDS
if [[ -n $displayRedrawSECONDS ]]; then
	[[ "$testModeOPTION" == "TRUE" ]] && redrawCOUNTER=0
	[[ "$testModeOPTION" == "TRUE" ]] && sendToLog "Test Mode: Killing self-update notification after 3 attempts..."
	[[ "$testModeOPTION" != "TRUE" ]] && sendToLog "Warning: The self-update notification will re-display every $displayRedrawSECONDS seconds until the user restarts the computer."
	while [[ -z $dialogRESULT ]] && [[ redrawCOUNTER -lt 3 ]]; do
		sudo -u "$currentUSER" open "/System/Library/PreferencePanes/SoftwareUpdate.prefPane" -a "/System/Applications/System Preferences.app"
		if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
			"$ibmNotifierBINARY" "${ibmNotifierARRAY[@]}" &
		else
			"$jamfHELPER" "${jamfHelperARRAY[@]}" &
		fi
		sleep "$displayRedrawSECONDS"
		[[ "$testModeOPTION" == "TRUE" ]] && redrawCOUNTER=$((redrawCOUNTER + 1))
		if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
			killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
		else
			killall -9 "jamfHelper" > /dev/null 2>&1
		fi
		killall -9 "System Preferences" > /dev/null 2>&1
	done
else
	[[ "$testModeOPTION" != "TRUE" ]] && sendToLog "Warning: The self-update notification will not close until the user restarts the computer."
	sudo -u "$currentUSER" open "/System/Library/PreferencePanes/SoftwareUpdate.prefPane" -a "/System/Applications/System Preferences.app"
	if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
		"$ibmNotifierBINARY" "${ibmNotifierARRAY[@]}" &
	else
		"$jamfHELPER" "${jamfHelperARRAY[@]}" &
	fi
	if [[ "$testModeOPTION" == "TRUE" ]]; then
		sendToLog "Test Mode: Killing self-update notification in $testModeTIMEOUT seconds..."
		sleep "$testModeTIMEOUT"
		if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
			killall -9 "IBM Notifier" "IBM Notifier Popup" > /dev/null 2>&1
		else
			killall -9 "jamfHelper" > /dev/null 2>&1
		fi
		killall -9 "System Preferences" > /dev/null 2>&1
	fi
fi
}

# Display an interactive dialog when a soft deadline has passed, giving the user only one button to continue the workflow.
dialogSoftDeadline() {
if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
	# The initial $ibmNotifierARRAY[] settings for the soft deadline dialog.
	ibmNotifierARRAY=(-type popup -always_on_top -bar_title "$dialogSoftDeadlineTITLE" -icon_path "$cachedICON" -icon_width "$ibmNotifierIconSIZE" -icon_height "$ibmNotifierIconSIZE" -main_button_label "$restartButtonTEXT")

	# Variations for the main body text of the soft deadline dialog.
	if [[ "$deadlineDateSTATUS" == "SOFT" ]]; then
		sendToLog "IBM Notifier: soft date deadline dialog..."
		ibmNotifierARRAY+=(-subtitle "$dialogSoftDeadlineBodyDateIBM")
	elif [[ "$deadlineDaysSTATUS" == "SOFT" ]]; then
		sendToLog "IBM Notifier: soft days deadline dialog..."
		ibmNotifierARRAY+=(-subtitle "$dialogSoftDeadlineBodyDaysIBM")
	elif [[ "$deadlineCountSTATUS" == "SOFT" ]]; then
		sendToLog "IBM Notifier: soft count deadline dialog..."
		ibmNotifierARRAY+=(-subtitle "$dialogSoftDeadlineBodyCountIBM")
	fi
	displayTimeoutTEXT="$dialogSoftDeadlineTimeoutTEXT"

	# Start the dialog.
	openIbmNotifier

	# The $dialogRETURN contains the IBM Notifier.app return code.
	case "$dialogRETURN" in
		0)
			sendToLog "Status: User chose to restart."
		;;
		255)
			sendToLog "Status: Display timeout automatically chose to restart."
		;;
	esac
else
	# The initial $jamfHelperARRAY[] settings for the soft deadline dialog.
	jamfHelperARRAY=(-windowType utility -title "$dialogSoftDeadlineTITLE" -icon "$cachedICON" -iconSize "$jamfHelperIconSIZE" -button1 "$restartButtonTEXT" -defaultButton 1)

	# Variations for the main body text of the soft deadline dialog
	if [[ "$deadlineDateSTATUS" == "SOFT" ]]; then
		sendToLog "jamfHelper: soft date deadline dialog..."
		jamfHelperARRAY+=(-description "$dialogSoftDeadlineBodyDateJAMF")
	elif [[ "$deadlineDaysSTATUS" == "SOFT" ]]; then
		sendToLog "jamfHelper: soft days deadline dialog..."
		jamfHelperARRAY+=(-description "$dialogSoftDeadlineBodyDaysJAMF")
	elif [[ "$deadlineCountSTATUS" == "SOFT" ]]; then
		sendToLog "jamfHelper soft count deadline dialog..."
		jamfHelperARRAY+=(-description "$dialogSoftDeadlineBodyCountJAMF")
	fi

	# Start the dialog.
	openJamfHelper
	sendToLog "Status: User or display timeout accepted soft deadline dialog."
fi
}

# Generate the $jamfHelperARRAY[] to display an interactive dialog with deferral options. This sets $choiceINSTALL and if $menuDeferSECONDS then also sets $defaultDeferSECONDS.
dialogAskForUpdate() {
if [[ "$ibmNotifierVALID" == "TRUE" ]] && [[ "$preferJamfOPTION" != "TRUE" ]]; then
	sendToLog "IBM Notifier: Ask for restart or defer dialog..."
	# Create initial $ibmNotifierARRAY[] settings for the dialog.
	ibmNotifierARRAY=(-type popup -always_on_top -bar_title "$dialogAskForUpdateTITLE" -icon_path "$cachedICON" -icon_width "$ibmNotifierIconSIZE" -icon_height "$ibmNotifierIconSIZE" -main_button_label "$deferButtonTEXT" -secondary_button_label "$restartButtonTEXT")

	# Body text variations based on deadline options.
	if [[ -n "$deadlineDISPLAY" ]] && [[ -n "$countDISPLAY" ]]; then # Show both date and maximum deferral count deadlines.
		ibmNotifierARRAY+=(-subtitle "$dialogAskForUpdateBodyDateCountIBM")
	elif [[ -n "$deadlineDISPLAY" ]]; then # Show only date deadline.
		ibmNotifierARRAY+=(-subtitle "$dialogAskForUpdateBodyDateIBM")
	elif [[ -n "$countDISPLAY" ]]; then # Show only maximum deferral count deadline.
		ibmNotifierARRAY+=(-subtitle "$dialogAskForUpdateBodyCountIBM")
	else # Show no deadlines.
		ibmNotifierARRAY+=(-subtitle "$dialogAskForUpdateBodyUnlimitedIBM")
	fi
	displayTimeoutTEXT="$dialogAskForUpdateTimeoutTEXT"

	# If needed, add the $menuDeferSECONDS option to the $ibmNotifierARRAY[].
	if [[ -n $menuDeferSECONDS ]]; then
		oldIFS="$IFS"; IFS=','
		read -r -a menuDeferSecondsARRAY <<< "$menuDeferSECONDS"
		read -r -a menuDeferDisplayARRAY <<< "$menuDeferSECONDS"
		for i in "${!menuDeferDisplayARRAY[@]}"; do
			if [[ ${menuDeferDisplayARRAY[i]} -lt 3600 ]]; then
				menuDeferDisplayARRAY[i]="$((menuDeferDisplayARRAY[i] / 60)) $dialogAskForUpdateDeferMenuMinutesIBM"
			elif [[ ${menuDeferDisplayARRAY[i]} -eq 3600 ]]; then
				menuDeferDisplayARRAY[i]="1 $dialogAskForUpdateDeferMenuHourIBM"
			elif [[ ${menuDeferDisplayARRAY[i]} -gt 3600 ]] && [[ ${menuDeferDisplayARRAY[i]} -lt 7200 ]]; then
				menuDeferDisplayARRAY[i]="1 $dialogAskForUpdateDeferMenuHourIBM $((menuDeferDisplayARRAY[i] % 3600 / 60)) $dialogAskForUpdateDeferMenuMinutesIBM"
			elif [[ ${menuDeferDisplayARRAY[i]} -ge 7200 ]] && [[ ${menuDeferDisplayARRAY[i]} -lt 86400 ]] && [[ $((menuDeferDisplayARRAY[i] % 3600)) -eq 0 ]]; then
				menuDeferDisplayARRAY[i]="$((menuDeferDisplayARRAY[i] / 3600)) $dialogAskForUpdateDeferMenuHoursIBM"
			elif [[ ${menuDeferDisplayARRAY[i]} -gt 7200 ]] && [[ ${menuDeferDisplayARRAY[i]} -lt 86400 ]] && [[ $((menuDeferDisplayARRAY[i] % 3600)) -ne 0 ]]; then
				menuDeferDisplayARRAY[i]="$((menuDeferDisplayARRAY[i] / 3600)) $dialogAskForUpdateDeferMenuHoursIBM $((menuDeferDisplayARRAY[i] % 3600 / 60)) $dialogAskForUpdateDeferMenuMinutesIBM"
			elif [[ ${menuDeferDisplayARRAY[i]} -eq 86400 ]]; then
				menuDeferDisplayARRAY[i]="1 $dialogAskForUpdateDeferMenuDayIBM"
			fi
		done
		IFS=$'\n'
		menuDisplayTEXT="${menuDeferDisplayARRAY[*]}"
		IFS="$oldIFS"
		ibmNotifierARRAY+=(-accessory_view_type dropdown -accessory_view_payload "/title $dialogAskForUpdateDeferMenuTitleIBM /list $menuDisplayTEXT /selected 0")
	fi

	# Start the dialog.
	openIbmNotifier

	# The $dialogRETURN contains the IBM Notifier.app return code. If $menuDeferSECONDS was enabled then set $defaultDeferSECONDS.
	case "$dialogRETURN" in
		0)
			choiceINSTALL="FALSE"
			if [[ -n $menuDeferSECONDS ]]; then
				defaultDeferSECONDS="${menuDeferSecondsARRAY[$dialogRESULT]}"
				sendToLog "Status: User chose to defer update for $defaultDeferSECONDS seconds."
			else
				sendToLog "Status: User chose to defer update, using the default defer of $defaultDeferSECONDS seconds."
			fi
		;;
		255)
			choiceINSTALL="FALSE"
			if [[ -n $menuDeferSECONDS ]]; then
				defaultDeferSECONDS="${menuDeferSecondsARRAY[$dialogRESULT]}"
				sendToLog "Status: Display timeout automatically chose to defer update for $defaultDeferSECONDS seconds."
			else
				sendToLog "Status: Display timeout automatically chose to defer update, using the default defer of $defaultDeferSECONDS seconds."
			fi
		;;
		2)
			sendToLog "Status: User chose to restart now."
			choiceINSTALL="TRUE"
		;;
	esac
else
	sendToLog "jamfHelper: Ask for restart or defer dialog..."
	# Create initial $jamfHelperARRAY[] settings for the dialog.
	jamfHelperARRAY=(-windowType utility -title "$dialogAskForUpdateTITLE" -icon "$cachedICON" -iconSize "$jamfHelperIconSIZE" -button1 "$deferButtonTEXT" -button2 "$restartButtonTEXT" -defaultButton 1 -cancelButton 2)

	# Body text variations based on deadline options. Note that any invisible characters (tabs and new line) will be "shown" in the jamfHelper dialog.
	if [[ -n "$deadlineDISPLAY" ]] && [[ -n "$countDISPLAY" ]]; then # Show both date and maximum deferral count deadlines.
		jamfHelperARRAY+=(-description "$dialogAskForUpdateBodyDateCountJAMF")
	elif [[ -n "$deadlineDISPLAY" ]]; then # Show only date deadline.
		jamfHelperARRAY+=(-description "$dialogAskForUpdateBodyDateJAMF")
	elif [[ -n "$countDISPLAY" ]]; then # Show only maximum deferral count deadline.
		jamfHelperARRAY+=(-description "$dialogAskForUpdateBodyCountJAMF")
	else # Show no deadlines.
		jamfHelperARRAY+=(-description "$dialogAskForUpdateBodyUnlimitedJAMF")
	fi

	# If needed, add the $menuDeferSECONDS option to the $jamfHelperARRAY[].
	if [[ -n $menuDeferSECONDS ]]; then
		menuDeferSECONDS=$(echo "$menuDeferSECONDS" | sed 's/,/, /g')
		jamfHelperARRAY+=(-showDelayOptions "$menuDeferSECONDS")
	fi

	# Start the dialog.
	openJamfHelper

	# The $dialogRESULT contains the user's selection; "0" or "1" for deferral and "2" for restart. If $menuDeferSECONDS was enabled then set $defaultDeferSECONDS.
	case "$dialogRESULT" in
		0 | 1 | *1)
			choiceINSTALL="FALSE"
			if [[ -n $menuDeferSECONDS ]]; then
				defaultDeferSECONDS=$(echo "$dialogRESULT" | sed 's/.$//')
				sendToLog "Status: User or display timeout chose to defer update for $defaultDeferSECONDS seconds."
			else
				sendToLog "Status: User or display timeout chose to defer update, using the default defer of $defaultDeferSECONDS seconds."
			fi
		;;
		*2)
			sendToLog "Status: User chose to restart now."
			choiceINSTALL="TRUE"
		;;
	esac
fi
}

######## MAIN WORKFLOW ########

mainWorkflow(){
# Initial super workflow preparations.
checkRoot
setDefaults
superInstaller
sendToLog "**** S.U.P.E.R.M.A.N. STARTER ****"
getOptions "$@"
getPreferences
superStarter "$@"
sendToLog "**** S.U.P.E.R.M.A.N. STARTER END ****"

# This logic determines what $updateWORKFLOW will run; JAMF, ASU, or USER
if [[ "$macosARCH" == "arm64" ]]; then
	if [[ "$localCREDENTIAL" == "TRUE" ]]; then
		sendToLog "**** S.U.P.E.R.M.A.N. UPDATE APPLE SILICON ASU LOCAL ACCOUNT ****"
		updateWORKFLOW="ASU"
		asuACCOUNT="$localACCOUNT"
		asuPASSWORD="$localKEYCHAIN"
	elif [[ "$superCREDENTIAL" == "TRUE" ]]; then
		sendToLog "**** S.U.P.E.R.M.A.N. UPDATE APPLE SILICON ASU SERVICE ACCOUNT ****"
		updateWORKFLOW="ASU"
		asuACCOUNT="$superACCOUNT"
		asuPASSWORD="$superKEYCHAIN"
	elif [[ "$jamfCREDENTIAL" == "TRUE" ]]; then
		if [[ "$macosVERSION" -ge 1105 ]]; then
			sendToLog "**** S.U.P.E.R.M.A.N. UPDATE APPLE SILICON JAMF PRO MDM ****"
			updateWORKFLOW="JAMF"
		else
			sendToLog "Warning: System updates via MDM can only be enforced on Apple Silicon computers with macOS 11.5 or later."
			sendToLog "**** S.U.P.E.R.M.A.N. UPDATE APPLE SILICON USER REQUEST ****"
			updateWORKFLOW="USER"
		fi
	else
		sendToLog "**** S.U.P.E.R.M.A.N. UPDATE APPLE SILICON USER REQUEST ****"
		updateWORKFLOW="USER"
	fi
else # Mac computers with Intel.
	if [[ "$jamfCREDENTIAL" == "TRUE" ]]; then
		if [[ "$macosVERSION" -ge 1105 ]]; then
			sendToLog "**** S.U.P.E.R.M.A.N. UPDATE INTEL JAMF PRO MDM ****"
			updateWORKFLOW="JAMF"
		else
			sendToLog "Warning: System updates via MDM can only be enforced on Apple Silicon computers with macOS 11.5 or later."
			sendToLog "**** S.U.P.E.R.M.A.N. UPDATE INTEL ASU ****"
			updateWORKFLOW="ASU"
		fi
	else
		sendToLog "**** S.U.P.E.R.M.A.N. UPDATE INTEL ASU ****"
		updateWORKFLOW="ASU"
	fi
fi
[[ "$verboseModeOPTION" == "TRUE" ]] && sendToLog "Verbose Mode: updateWORKFLOW: $updateWORKFLOW"

# If requested then restart counters.
[[ "$restartDAYS" == "TRUE" ]] && restartZeroDay
[[ "$restartCOUNTS" == "TRUE" ]] && restartDeferralCounters

# Use local Apple software update to check for updates. This sets $updatesRECOMMENDED, $updatesRESTART, and $downloadREQUIRED.
if [[ "$updateVALIDATE" == "TRUE" ]]; then # Checking after previous super system update, if successful, submit inventory to Jamf and check for Jamf Policies.
	sendToLog "Status: System update restart validation."
	checkAfterRestartUpdates
else # Default super workflow.
	updatesRECOMMENDED="FALSE"
	updatesRESTART="FALSE"
	if [[ "$testModeOPTION" == "TRUE" ]]; then # Test mode logic and logging.
		if [[ "$skipUpdatesOPTION" == "TRUE" ]]; then
			if [[ "$forceRestartOPTION" != "TRUE" ]] && [[ -z $policyTRIGGERS ]]; then
				sendToLog "Test Mode and Skip Update Mode: You need to also use \"--force-restart\" or \"--policy-triggers\" to simulate notificaiton and dialog workflows."
			fi
		else
			sendToLog "Test Mode: Simulating that restart required system updates are available."
			updatesRESTART="TRUE"
		fi
	elif [[ "$skipUpdatesOPTION" == "TRUE" ]]; then
		sendToLog "Skip Update Mode: Not checking for Apple software updates."
	else # Not $testModeOPTION, $skipUpdatesOPTION, or $updateVALIDATE, so it's time to check for new updates.
		checkAppleUpdates
	fi
fi

# If non-restart required "recommended" Apple software updates are available, then install all available recommended software updates.
if [[ "$updatesRECOMMENDED" == "TRUE" ]]; then
	installRecommendedUpdatesASU
	if [[ "$updateERROR" != "TRUE" ]]; then # If all recommended software updates are successful, check Apple softwareupdate again and continue workflow.
		sendToLog "Status: Completed install of all recommended software updates."
		checkAfterRecommendedUpdates
	else
		sendToLog "Exit: Apple softwareupdate failed to install all recommended updates, trying again in $defaultDeferSECONDS seconds."
		makeLaunchDaemonCalendar
	fi
fi

# This is the main logic for determining what to do in the case of available restart required system updates, $policyTRIGGERS, or the $forceRestartOPTION.
if [[ "$updatesRESTART" == "TRUE" ]] || [[ -n $policyTRIGGERS ]] || [[ "$forceRestartOPTION" == "TRUE" ]]; then
	checkCurrentUser # Checking the user again because it may have been quite a while since the workflow started (due to earlier installations).
	if [[ "$currentUSER" == "FALSE" ]]; then # A normal user is not logged in, start installation immediately.
		installRestartNoUser
	else # A normal user is currently logged in.
		if [[ "$testModeOPTION" != "TRUE" ]]; then # Not in test mode.
			if [[ "$downloadREQUIRED" == "TRUE" ]]; then # Updates have not been downloaded yet.
				if [[ "$updateWORKFLOW" == "ASU" ]]; then
					downloadSystemUpdateASU
				elif [[ "$updateWORKFLOW" == "JAMF" ]]; then
					downloadSystemUpdateMDM
				else
					sendToLog "Status: Self-update workflow, unable to automatically download system udpates."
				fi
			else # Updates were previously downloaded.
				sendToLog "Status: Previously downloaded ${#downloadedTITLES[@]} software udpate(s)."
				for i in "${!downloadedTITLES[@]}"; do
					sendToLog "Previous Download $((i + 1)): ${downloadedTITLES[i]}"
				done
			fi
		else
			sendToLog "Test Mode: Skipping download of restart required system update."
		fi
		checkZeroDay # This may need to start the automatic day zero date, so it always runs first.
		checkDateDeadlines
		checkDaysDeadlines
		# User Focus only needs to be checked if there are no date or day deadlines.
		if [[ "$deadlineDateSTATUS" == "FALSE" ]] && [[ "$deadlineDaysSTATUS" == "FALSE" ]]; then
			checkUserFocus
		else # At this point any date or days deadline would rule out any $focusDEFER option.
			focusDEFER="FALSE"
		fi
		checkCountDeadlines
		setDisplayLanguage
		if [[ "$deadlineDateSTATUS" == "HARD" ]] || [[ "$deadlineDaysSTATUS" == "HARD" ]] || [[ "$deadlineCountSTATUS" == "HARD" ]]; then # A hard deadline has passed, similar to no logged in user but with a notification.
			installRestartMain
		elif [[ "$deadlineDateSTATUS" == "SOFT" ]] || [[ "$deadlineDaysSTATUS" == "SOFT" ]] || [[ "$deadlineCountSTATUS" == "SOFT" ]]; then # A soft deadline has passed.
			dialogSoftDeadline
			installRestartMain
		elif [[ "$focusDEFER" == "TRUE" ]]; then # No deadlines have passed but a process has told the display to not sleep or the user has enabled Focus or Do Not Disturb.
			defaultDeferSECONDS="$focusDeferSECONDS"
			makeLaunchDaemonCalendar
		else # Logically, this is the only time the choice dialog is shown.
			dialogAskForUpdate
			if [[ "$choiceINSTALL" == "TRUE" ]]; then
				installRestartMain
			else
				makeLaunchDaemonCalendar
			fi
		fi
	fi
fi

# Logically, at this point there are no required restarts, so check for $recheckDeferSECONDS, and if so then make a new LaunchDaemon.
if [[ -n "$recheckDeferSECONDS" ]]; then
	sendToLog "Status: Recheck deferral should restart super in $recheckDeferSECONDS seconds."
	defaultDeferSECONDS="$recheckDeferSECONDS"
	makeLaunchDaemonCalendar
fi
}

mainWorkflow "$@"
rm -f "$superPIDFILE"
[[ -n "$jamfProTOKEN" ]] && deleteJamfProServerToken
sendToLog "**** S.U.P.E.R.M.A.N. EXIT ****"
exit 0
